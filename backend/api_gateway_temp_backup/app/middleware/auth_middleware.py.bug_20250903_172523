"""
Authentication Middleware - Phase 2 Implementation
Based on MilkyHoop Phase 2 Authentication System Documentation
"""

import grpc
from fastapi import Request, Response, HTTPException
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware
import structlog
from typing import Optional, Dict, Any
import os

# Import auth service proto
import sys
sys.path.append('/app/backend/api_gateway/libs')
try:
    from milkyhoop_protos import auth_pb2, auth_pb2_grpc
except ImportError:
    print("‚ö†Ô∏è Auth proto files not found - using mock auth")
    auth_pb2 = None
    auth_pb2_grpc = None

logger = structlog.get_logger(__name__)

class AuthMiddleware(BaseHTTPMiddleware):
    """
    Authentication Middleware with path segregation and session management
    Implements Phase 2 architecture per documentation
    """
    
    def __init__(self, app, auth_service_host: str = "auth_service:5004"):
        super().__init__(app)
        self.auth_service_host = auth_service_host
        
        # Path configuration per documentation
        self.protected_paths = [
            "/chat/",
            "/api/setup/", 
            "/api/test/",
            "/api/auth/"
        ]
        
        self.public_paths = [
            "/health",
            "/healthz", 
            "/docs",
            "/openapi.json",
            "/redoc",
            "/"  # Root endpoint
        ]
        
        logger.info("üîß AuthMiddleware initialized", 
                   protected_paths=len(self.protected_paths),
                   public_paths=len(self.public_paths))
    
    async def dispatch(self, request: Request, call_next):
        """
        Main middleware dispatch logic
        Implements authentication flow per Phase 2 documentation
        """
        
        # Log request processing
        logger.info("üîß Middleware processing", path=request.url.path)
        
        # Check if path requires authentication
        if self._is_public_path(request.url.path):
            logger.debug("üìÇ Public path - bypassing auth", path=request.url.path)
            return await call_next(request)
        
        if self._is_protected_path(request.url.path):
            logger.info("üîç Protected path detected", path=request.url.path)
            
            # Extract JWT token
            token = self._extract_token(request)
            if not token:
                logger.warning("‚ùå Missing token for protected path", path=request.url.path)
                return JSONResponse(
                    status_code=401,
                    content={
                        "error": "Authentication required",
                        "code": "MISSING_TOKEN", 
                        "message": "This endpoint requires authentication. Please provide Bearer token."
                    }
                )
            
            # Validate token with auth service
            user_context = await self._validate_token(token)
            if not user_context:
                logger.warning("‚ùå Invalid token for protected path", path=request.url.path)
                return JSONResponse(
                    status_code=401,
                    content={
                        "error": "Invalid authentication",
                        "code": "INVALID_TOKEN",
                        "message": "Authentication token is invalid or expired."
                    }
                )
            
            # Inject user context into request
            request.state.user = user_context
            request.state.authenticated = True
            logger.info("‚úÖ Authentication successful", 
                       user_id=user_context.get('user_id'),
                       tenant_id=user_context.get('tenant_id'))
        
        # Process request
        return await call_next(request)
    
    def _is_public_path(self, path: str) -> bool:
        """Check if path is public (no auth required)"""
        if path == "/":
            return True
        return any(path.startswith(public_path) for public_path in self.public_paths)
    
    def _is_protected_path(self, path: str) -> bool:
        """Check if path requires authentication"""
        return any(path.startswith(protected_path) for protected_path in self.protected_paths)
    
    def _extract_token(self, request: Request) -> Optional[str]:
        """Extract JWT token from Authorization header"""
        auth_header = request.headers.get("Authorization")
        if auth_header and auth_header.startswith("Bearer "):
            return auth_header[7:]  # Remove "Bearer " prefix
        return None
    
    async def _validate_token(self, token: str) -> Optional[Dict[str, Any]]:
        """
        Validate JWT token with auth service
        Returns user context if valid, None if invalid
        """
        
        # Mock validation if proto not available
        if not auth_pb2 or not auth_pb2_grpc:
            logger.warning("‚ö†Ô∏è Using mock auth validation - proto files missing")
            return {
                "user_id": "mock_user", 
                "tenant_id": "mock_tenant",
                "username": "mock@example.com"
            }
        
        try:
            # Create gRPC channel
            channel = grpc.aio.insecure_channel(self.auth_service_host)
            stub = auth_pb2_grpc.AuthServiceStub(channel)
            
            # Create validation request
            request = auth_pb2.ValidateTokenRequest(access_token=token)
            
            # Call auth service
            response = await stub.ValidateToken(request)
            
            # Close channel
            await channel.close()
            
            # Check response
            if response.valid:
                return {
                    "user_id": response.user_id,
                    "tenant_id": response.tenant_id,
                    "username": getattr(response, 'username', 'unknown')
                }
            else:
                return None
                
        except Exception as e:
            logger.error("‚ùå Auth service validation failed", error=str(e))
            return None
