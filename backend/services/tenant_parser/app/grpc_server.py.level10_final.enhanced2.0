from backend.api_gateway.libs.milkyhoop_prisma import Prisma
import asyncio
import signal
import logging
import os
import json
import grpc
from grpc import aio
from grpc_health.v1 import health, health_pb2, health_pb2_grpc
from app.config import settings
from app import tenant_parser_pb2_grpc as pb_grpc
from app import tenant_parser_pb2 as pb
from app.services.llm_parser import parse_intent_entities

# RAG CRUD integration
try:
    from app import ragcrud_service_pb2 as rag_pb
    from app import ragcrud_service_pb2_grpc as rag_pb_grpc
    RAG_CRUD_AVAILABLE = True
except ImportError:
    RAG_CRUD_AVAILABLE = False

# Level 10 integrations
try:
    from app import cust_context_pb2 as context_pb
    from app import cust_context_pb2_grpc as context_pb_grpc
    CONTEXT_AVAILABLE = True
except ImportError:
    CONTEXT_AVAILABLE = False

try:
    from app import cust_reference_pb2 as ref_pb
    from app import cust_reference_pb2_grpc as ref_pb_grpc
    REFERENCE_AVAILABLE = True
except ImportError:
    REFERENCE_AVAILABLE = False

print(f"âœ… RAG CRUD: {RAG_CRUD_AVAILABLE}, Context: {CONTEXT_AVAILABLE}, Reference: {REFERENCE_AVAILABLE}")

prisma = Prisma()
logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(name)s: %(message)s")
logger = logging.getLogger(__name__)

class TenantParserServicer(pb_grpc.IntentParserServiceServicer):
    def __init__(self):
        self.rag_crud_target = "ragcrud_service:5001"
        self.context_target = "cust_context:5008"
        self.reference_target = "cust_reference:5013"
        
    async def call_context_service(self, session_id: str, tenant_id: str, message: str):
        """Update conversation context"""
        if not CONTEXT_AVAILABLE:
            return None
            
        try:
            async with grpc.aio.insecure_channel(self.context_target) as channel:
                stub = context_pb_grpc.CustContextServiceStub(channel)
                
                request = context_pb.UpdateContextRequest(
                    session_id=session_id,
                    tenant_id=tenant_id,
                    user_query=message,
                    entities=f"tenant:{tenant_id}"
                )
                
                response = await stub.UpdateContext(request)
                logger.info(f"âœ… Context updated for session {session_id}")
                return response
                
        except Exception as e:
            logger.error(f"âŒ Context service error: {e}")
            return None

    async def call_reference_service(self, session_id: str, tenant_id: str, message: str):
        """Resolve Indonesian references"""
        if not REFERENCE_AVAILABLE:
            return message
            
        try:
            async with grpc.aio.insecure_channel(self.reference_target) as channel:
                stub = ref_pb_grpc.Cust_referenceStub(channel)
                
                request = ref_pb.ReferenceRequest(
                    session_id=session_id,
                    reference_text=message,
                    tenant_id=tenant_id,
                    context_query=message
                )
                
                response = await stub.ResolveReference(request)
                
                if hasattr(response, 'resolved_message') and response.resolved_message:
                    logger.info(f"âœ… Reference resolved: '{message}' â†’ '{response.resolved_message}'")
                    return response.resolved_message
                else:
                    return message
                    
        except Exception as e:
            logger.error(f"âŒ Reference service error: {e}")
            return message

    async def call_rag_crud(self, tenant_id: str, message: str):
        """Get FAQ content from RAG CRUD"""
        if not RAG_CRUD_AVAILABLE:
            return "RAG CRUD service tidak tersedia."
            
        try:
            async with grpc.aio.insecure_channel(self.rag_crud_target) as channel:
                stub = rag_pb_grpc.RagCrudServiceStub(channel)
                
                request = rag_pb.FuzzySearchRequest(
                    tenant_id=tenant_id,
                    search_content=message,
                    similarity_threshold=0.7
                )
                
                response = await stub.FuzzySearchDocuments(request)
                
                if response.documents and len(response.documents) > 0:
                    best_match = response.documents[0]
                    logger.info(f"âœ… RAG CRUD found FAQ match: {best_match.title[:50]}...")
                    return best_match.content
                else:
                    logger.info(f"â„¹ï¸ No FAQ matches found for {tenant_id}: {message}")
                    return "Maaf, informasi yang Anda cari belum tersedia dalam FAQ kami."
                    
        except Exception as e:
            logger.error(f"âŒ RAG CRUD call failed: {e}")
            return f"Maaf ada kendala teknis: {str(e)[:100]}"

    async def DoSomething(self, request, context):
        logger.info("ðŸ“¥ Level 10 customer query: %s", request.input)
        
        session_id = request.user_id
        tenant_id = "bca"  # Extract from context properly later
        message = request.input
        
        try:
            # Step 1: Parse customer intent
            result = parse_intent_entities(message)
            logger.info("ðŸ“ Intent: %s", result.get("intent"))
            
            # Step 2: Level 10 - Update conversation context
            context_response = await self.call_context_service(session_id, tenant_id, message)
            
            # Step 3: Level 10 - Resolve Indonesian references
            resolved_message = await self.call_reference_service(session_id, tenant_id, message)
            
            if resolved_message != message:
                logger.info(f"ðŸŽ¯ Message resolved: '{message}' â†’ '{resolved_message}'")
            
            # Step 4: Get FAQ content with resolved message
            faq_content = await self.call_rag_crud(tenant_id, resolved_message)
            
            # Step 5: Return enhanced response
            enhanced_result = {
                "intent": result.get("intent", "general_inquiry"),
                "entities": result.get("entities", {}),
                "response": faq_content,
                "context_updated": context_response is not None,
                "reference_resolved": resolved_message != message
            }
            
            logger.info("ðŸ“¤ Level 10 enhanced response prepared")
            
            return pb.IntentParserResponse(
                status="success",
                result=json.dumps(enhanced_result, ensure_ascii=False)
            )
            
        except Exception as e:
            logger.error(f"ðŸ”¥ Level 10 error: {e}", exc_info=True)
            return pb.IntentParserResponse(
                status="error",
                result=json.dumps({
                    "intent": "general_inquiry",
                    "entities": {},
                    "response": "Maaf ada kendala teknis, silakan coba lagi."
                }, ensure_ascii=False)
            )

    async def HealthCheck(self, request, context):
        return request

async def serve() -> None:
    listen_addr = f"[::]:{settings.GRPC_PORT}"
    server = aio.server()
    
    servicer = TenantParserServicer()
    pb_grpc.add_IntentParserServiceServicer_to_server(servicer, server)
    
    health_servicer = health.HealthServicer()
    health_pb2_grpc.add_HealthServicer_to_server(health_servicer, server)
    health_servicer.set("tenant_parser.IntentParserService", health_pb2.HealthCheckResponse.SERVING)
    
    server.add_insecure_port(listen_addr)
    
    logger.info("ðŸš€ Level 10 Tenant Parser with Context + Reference integration listening on port %s", settings.GRPC_PORT)
    await server.start()

    def handle_shutdown(*_):
        logger.info("ðŸ›‘ Shutting down Level 10 Tenant Parser...")
        asyncio.create_task(server.stop(grace=10.0))

    for sig in (signal.SIGTERM, signal.SIGINT):
        signal.signal(sig, handle_shutdown)

    await server.wait_for_termination()

if __name__ == "__main__":
    asyncio.run(serve())
