from backend.api_gateway.libs.milkyhoop_prisma import Prisma
import asyncio
import signal
import logging
import os
import json

import grpc
from grpc import aio
from grpc_health.v1 import health, health_pb2, health_pb2_grpc

# âœ… OpenTelemetry tracing
from opentelemetry import trace
from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import OTLPSpanExporter
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.instrumentation.grpc import GrpcInstrumentorServer

from app.config import settings
from app import ragcrud_service_pb2_grpc as pb_grpc
from app import ragcrud_service_pb2 as pb
from app.prisma_client import prisma, connect_prisma, disconnect_prisma
from app.services import rag_crud

# âœ… Logging config
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s"
)
logger = logging.getLogger(settings.SERVICE_NAME)

# âœ… Setup OpenTelemetry tracing
trace.set_tracer_provider(TracerProvider())
tracer_provider = trace.get_tracer_provider()
otlp_exporter = OTLPSpanExporter(endpoint="http://otel-collector:4317", insecure=True)
span_processor = BatchSpanProcessor(otlp_exporter)
tracer_provider.add_span_processor(span_processor)
GrpcInstrumentorServer().instrument()

# âœ… gRPC handler implementasi
class RagCrudServiceServicer(pb_grpc.RagCrudServiceServicer):
    async def DoSomething(self, request, context):
        logger.info("ðŸ“¥ DoSomething request received: %s", request.input)
        return pb.Ragcrud_serviceResponse(
            status="ok",
            result=f"Processed input: {request.input}"
        )

    async def CreateRagDocument(self, request, context):
        doc = await rag_crud.create_rag_document(
            tenant_id=request.tenant_id,
            title=request.title,
            content=request.content
        )

        # âœ… Save document to disk
        data = {
            "id": doc.id,
            "tenant_id": request.tenant_id,
            "title": request.title,
            "content": request.content
        }
        save_rag_data_to_disk(data)

        return pb.RagDocumentResponse(id=doc.id, title=doc.title, content=doc.content)

    async def GetRagDocument(self, request, context):
        doc = await rag_crud.get_rag_document(request.id)
        return pb.RagDocumentResponse(id=doc.id, title=doc.title, content=doc.content)


    async def ListRagDocuments(self, request, context):
        docs = await rag_crud.list_rag_documents(request.tenant_id)
        return pb.ListRagDocumentsResponse(
            documents=[
                pb.RagDocumentResponse(id=d.id, title=d.title, content=d.content)
                for d in docs
            ]
        )






    async def UpdateRagDocument(self, request, context):
        doc = await rag_crud.update_rag_document(
            id=request.id,
            title=request.title,
            content=request.content
        )
        return pb.RagDocumentResponse(id=doc.id, title=doc.title, content=doc.content)



    async def UpdateRagDocument(self, request, context):
        doc = await rag_crud.update_rag_document(
            id=request.id,
            title=request.title,
            content=request.content
        )
        if not doc:
            raise Exception("Document not found")
        return pb.RagDocumentResponse(id=doc.id, title=doc.title, content=doc.content)



    async def UpdateRagDocumentBySearch(self, request, context):
        doc = await rag_crud.update_rag_document_by_search(
            tenant_id=request.tenant_id,
            search_content=request.search_content,
            new_content=request.new_content
        )
        if not doc:
            raise Exception("Document not found with search criteria")
        return pb.RagDocumentResponse(id=doc.id, title=doc.title, content=doc.content)



    async def DeleteRagDocument(self, request, context):
        doc = await rag_crud.delete_rag_document(request.id)
        return pb.RagDocumentResponse(id=doc.id, title=doc.title, content=doc.content)

# âœ… Simpan data RAG ke file JSON
def save_rag_data_to_disk(data, filename="index.json"):
    os.makedirs("/app/data", exist_ok=True)
    filepath = os.path.join("/app/data", filename)
    with open(filepath, "w") as f:
        json.dump(data, f, indent=2)

async def serve() -> None:
    if "DATABASE_URL" in os.environ:
        logger.info("ðŸ”Œ Connecting to Prisma...")
        await connect_prisma()
        logger.info("âœ… Prisma connected")

    server = aio.server()
    pb_grpc.add_RagCrudServiceServicer_to_server(RagCrudServiceServicer(), server)

    # âœ… Health check
    health_servicer = health.HealthServicer()
    health_pb2_grpc.add_HealthServicer_to_server(health_servicer, server)
    health_servicer.set('', health_pb2.HealthCheckResponse.SERVING)

    listen_addr = f"[::]:{settings.GRPC_PORT}"
    server.add_insecure_port(listen_addr)
    logger.info(f"ðŸš€ {settings.SERVICE_NAME} gRPC server listening on port {settings.GRPC_PORT}")

    stop_event = asyncio.Event()

    def handle_shutdown(*_):
        logger.info("ðŸ›‘ Shutdown signal received. Cleaning up...")
        stop_event.set()

    signal.signal(signal.SIGINT, handle_shutdown)
    signal.signal(signal.SIGTERM, handle_shutdown)

    try:
        await server.start()
        await stop_event.wait()
    finally:
        logger.info("ðŸ§¹ Shutting down gRPC server...")
        await server.stop(5)
        if "DATABASE_URL" in os.environ:
            logger.info("ðŸ§¹ Disconnecting Prisma...")
            await disconnect_prisma()
            logger.info("âœ… Prisma disconnected")
        logger.info("âœ… gRPC server shut down cleanly.")

if __name__ == "__main__":
    asyncio.run(serve())
