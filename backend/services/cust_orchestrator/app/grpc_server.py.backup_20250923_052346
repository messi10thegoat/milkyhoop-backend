"""
Customer Service Orchestrator gRPC Server
Provides gRPC interface for customer query processing
"""
import asyncio
import grpc
from concurrent import futures
import logging
import json
from typing import Dict, Any, Optional
from grpc_health.v1 import health_pb2_grpc, health_pb2

# Import orchestrator implementation
try:
    from app.orchestrator import CustomerServiceOrchestrator
    ORCHESTRATOR_AVAILABLE = True
except ImportError as e:
    logging.warning(f"Orchestrator import failed: {e}")
    ORCHESTRATOR_AVAILABLE = False

logger = logging.getLogger(__name__)

class CustomerOrchestratorServicer:
    """gRPC servicer for customer orchestrator"""
    
    def __init__(self):
        if ORCHESTRATOR_AVAILABLE:
            self.orchestrator = CustomerServiceOrchestrator()
        else:
            self.orchestrator = None
            logger.warning("Orchestrator not available - running in health-check only mode")
    
    async def ProcessCustomerQuery(self, request, context):
        """
        Process customer query through complete pipeline
        
        Since we don't have protobuf definitions yet, we'll implement
        a flexible approach that works with the current architecture
        """
        if not self.orchestrator:
            context.set_code(grpc.StatusCode.UNAVAILABLE)
            context.set_details("Orchestrator service not available")
            return self._create_error_response("Service unavailable")
        
        try:
            # Extract request data - flexible approach for different request formats
            query = getattr(request, 'query', getattr(request, 'message', ''))
            tenant_id = getattr(request, 'tenant_id', '')
            session_id = getattr(request, 'session_id', None)
            
            if not query or not tenant_id:
                context.set_code(grpc.StatusCode.INVALID_ARGUMENT)
                context.set_details("Missing required fields: query and tenant_id")
                return self._create_error_response("Invalid request")
            
            # Process through orchestrator
            result = await self.orchestrator.process_customer_query(
                query=query,
                tenant_id=tenant_id,
                session_id=session_id
            )
            
            logger.info(f"Successfully processed query for tenant: {tenant_id}")
            return self._create_success_response(result)
            
        except Exception as e:
            logger.error(f"gRPC call failed: {str(e)}")
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return self._create_error_response(str(e))
    
    def _create_success_response(self, result: Any) -> Dict[str, Any]:
        """Create standardized success response"""
        if isinstance(result, str):
            return {
                "status": "success",
                "message": result,
                "response": result
            }
        elif isinstance(result, dict):
            return {
                "status": "success",
                "message": result.get("message", ""),
                "response": result.get("response", result.get("message", "")),
                **result
            }
        else:
            return {
                "status": "success",
                "message": str(result),
                "response": str(result)
            }
    
    def _create_error_response(self, error_message: str) -> Dict[str, Any]:
        """Create standardized error response"""
        return {
            "status": "error",
            "message": error_message,
            "response": "Maaf, terjadi kesalahan dalam memproses permintaan."
        }

class HealthServicer(health_pb2_grpc.HealthServicer):
    """Health check servicer"""
    
    def Check(self, request, context):
        """Standard health check"""
        return health_pb2.HealthCheckResponse(
            status=health_pb2.HealthCheckResponse.SERVING
        )
    
    def Watch(self, request, context):
        """Streaming health check"""
        while True:
            yield health_pb2.HealthCheckResponse(
                status=health_pb2.HealthCheckResponse.SERVING
            )

class FlexibleOrchestratorServicer:
    """
    Flexible gRPC servicer that can handle different request formats
    until proper protobuf definitions are implemented
    """
    
    def __init__(self):
        self.orchestrator_servicer = CustomerOrchestratorServicer()
    
    async def process_customer_query(self, message: str, tenant_id: str, session_id: Optional[str] = None) -> str:
        """
        Direct method call interface for orchestrator client
        This bridges the gap between gRPC and the Python orchestrator
        """
        try:
            if not self.orchestrator_servicer.orchestrator:
                raise Exception("Orchestrator service not available")
            
            result = await self.orchestrator_servicer.orchestrator.process_customer_query(
                query=message,
                tenant_id=tenant_id,
                session_id=session_id
            )
            
            # Extract response text from result
            if isinstance(result, str):
                return result
            elif isinstance(result, dict):
                return result.get("response", result.get("message", str(result)))
            else:
                return str(result)
                
        except Exception as e:
            logger.error(f"Flexible orchestrator call failed: {str(e)}")
            raise Exception(f"Orchestration failed: {str(e)}")

# Global instance for direct access
flexible_orchestrator = FlexibleOrchestratorServicer()

async def serve():
    """Start the gRPC server"""
    server = grpc.aio.server(futures.ThreadPoolExecutor(max_workers=10))
    
    # Add health check service
    health_servicer = HealthServicer()
    health_pb2_grpc.add_HealthServicer_to_server(health_servicer, server)
    
    # Add orchestrator service if available
    if ORCHESTRATOR_AVAILABLE:
        orchestrator_servicer = CustomerOrchestratorServicer()
        # TODO: Add proper protobuf service when defined
        # For now, orchestrator is accessible via flexible_orchestrator global
        logger.info("Orchestrator service initialized (accessible via flexible interface)")
    else:
        logger.warning("Orchestrator service not available - health check only")
    
    # Configure server address
    listen_addr = '[::]:5013'
    server.add_insecure_port(listen_addr)
    
    logger.info(f"Customer Service Orchestrator gRPC server starting on {listen_addr}")
    logger.info(f"Health check available, Orchestrator: {'✅ Available' if ORCHESTRATOR_AVAILABLE else '❌ Unavailable'}")
    
    # Start server
    await server.start()
    
    try:
        await server.wait_for_termination()
    except KeyboardInterrupt:
        logger.info("Shutting down gRPC server...")
        await server.stop(0)

if __name__ == '__main__':
    # Configure logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s [%(levelname)s] %(name)s: %(message)s'
    )
    
    # Start server
    logger.info("Initializing Customer Service Orchestrator...")
    asyncio.run(serve())