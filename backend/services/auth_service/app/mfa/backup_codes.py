"""
MFA Backup Codes Manager
ISO 27001:2022 - A.8.5 Secure Authentication

One-time recovery codes for account access when authenticator is unavailable
"""

import secrets
import hashlib
import logging
from typing import List, Tuple, Optional
from dataclasses import dataclass

logger = logging.getLogger(__name__)


@dataclass
class BackupCodesResult:
    """Result of backup codes generation"""

    codes: List[str]  # Plain text codes to show user ONCE
    hashes: List[str]  # Hashed codes to store in database


class BackupCodeManager:
    """
    Backup Code Manager for MFA Recovery

    Security considerations:
    - Codes are shown to user only once during generation
    - Only hashed codes are stored in database
    - Each code can only be used once
    - 10 codes generated by default
    """

    CODE_LENGTH = 8  # 8 characters
    CODE_COUNT = 10  # 10 backup codes
    CODE_FORMAT = "XXXX-XXXX"  # Display format

    @classmethod
    def generate_codes(cls, count: int = CODE_COUNT) -> BackupCodesResult:
        """
        Generate backup codes for MFA recovery

        Args:
            count: Number of codes to generate (default 10)

        Returns:
            BackupCodesResult with plain codes and hashes
        """
        codes = []
        hashes = []

        for _ in range(count):
            # Generate random code
            code = secrets.token_hex(cls.CODE_LENGTH // 2).upper()

            # Format as XXXX-XXXX
            formatted_code = f"{code[:4]}-{code[4:]}"
            codes.append(formatted_code)

            # Hash for storage
            code_hash = cls._hash_code(code)
            hashes.append(code_hash)

        logger.info(f"Generated {count} backup codes")

        return BackupCodesResult(codes=codes, hashes=hashes)

    @classmethod
    def verify_code(
        cls, input_code: str, stored_hashes: List[str]
    ) -> Tuple[bool, Optional[int]]:
        """
        Verify a backup code

        Args:
            input_code: Code entered by user
            stored_hashes: List of hashed codes from database

        Returns:
            Tuple of (is_valid, index_of_used_code)
            index is None if invalid, otherwise the index to mark as used
        """
        if not input_code or not stored_hashes:
            return False, None

        # Normalize input (remove dashes, uppercase)
        normalized = input_code.replace("-", "").replace(" ", "").upper()

        if len(normalized) != cls.CODE_LENGTH:
            logger.warning("Invalid backup code format")
            return False, None

        # Hash input and compare
        input_hash = cls._hash_code(normalized)

        for idx, stored_hash in enumerate(stored_hashes):
            if stored_hash and input_hash == stored_hash:
                logger.info(f"Backup code verified (index: {idx})")
                return True, idx

        logger.warning("Backup code verification failed")
        return False, None

    @classmethod
    def _hash_code(cls, code: str) -> str:
        """
        Hash a backup code for storage

        Args:
            code: Plain text code

        Returns:
            SHA256 hash of code
        """
        return hashlib.sha256(code.encode()).hexdigest()

    @classmethod
    def get_remaining_count(cls, stored_hashes: List[str]) -> int:
        """
        Count remaining unused backup codes

        Args:
            stored_hashes: List of hashed codes (None = used)

        Returns:
            Number of unused codes
        """
        return sum(1 for h in stored_hashes if h is not None)

    @classmethod
    def mark_code_used(cls, stored_hashes: List[str], index: int) -> List[str]:
        """
        Mark a backup code as used

        Args:
            stored_hashes: List of hashed codes
            index: Index of code to mark as used

        Returns:
            Updated list with code marked as None
        """
        if 0 <= index < len(stored_hashes):
            stored_hashes[index] = None
            logger.info(f"Backup code at index {index} marked as used")
        return stored_hashes

    @classmethod
    def format_codes_for_display(cls, codes: List[str]) -> str:
        """
        Format codes for display to user

        Args:
            codes: List of backup codes

        Returns:
            Formatted string for display/download
        """
        header = """
=====================================
MILKYHOOP MFA BACKUP CODES
=====================================

IMPORTANT: Save these codes in a secure location.
Each code can only be used ONCE.
These codes will not be shown again.

=====================================
"""
        code_list = "\n".join([f"  {i+1}. {code}" for i, code in enumerate(codes)])

        footer = """
=====================================
Generated: Use if you lose access to
your authenticator app.
=====================================
"""
        return header + code_list + footer
