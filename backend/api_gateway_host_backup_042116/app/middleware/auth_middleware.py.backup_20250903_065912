import grpc
import logging
from typing import Optional, Dict, Any
from fastapi import Request, HTTPException, status
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware

# Import from existing milkyhoop_protos libs
from backend.api_gateway.libs.milkyhoop_protos.auth_service_pb2 import ValidateTokenRequest
from backend.api_gateway.libs.milkyhoop_protos.auth_service_pb2_grpc import AuthServiceStub

logger = logging.getLogger(__name__)

class AuthMiddleware(BaseHTTPMiddleware):
    """Authentication middleware for API Gateway using proper proto libs"""
    
    def __init__(self, app, auth_service_host: str = "auth_service:5004"):
        super().__init__(app)
        self.auth_service_host = auth_service_host
        # Setup mode requires authentication
        self.protected_paths = ["/api/chat/", "/api/setup/", "/chat/"]
        # Customer mode remains public
        self.public_paths = ["/health", "/api/customer/", "/docs", "/openapi.json", "/redoc", "/api/tenant/"]
        
    async def dispatch(self, request: Request, call_next):
        """Main middleware authentication logic"""
        
        # Skip authentication for public paths
        if self._is_public_path(request.url.path):
            return await call_next(request)
            
        # Skip authentication for OPTIONS requests (CORS preflight)
        if request.method == "OPTIONS":
            return await call_next(request)
            
        # Extract and validate token
        try:
            token = self._extract_token(request)
            if not token:
                return JSONResponse(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    content={
                        "error": "Authentication required", 
                        "code": "MISSING_TOKEN",
                        "message": "Please provide valid JWT token in Authorization header"
                    }
                )
                
            # Validate token with auth service
            user_context = await self._validate_token(token)
            if not user_context:
                return JSONResponse(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    content={
                        "error": "Invalid or expired token", 
                        "code": "INVALID_TOKEN",
                        "message": "Token validation failed"
                    }
                )
                
            # Inject user context into request state for tenant isolation
            request.state.user = user_context
            request.state.authenticated = True
            
            logger.info(f"Authenticated user: {user_context.get('user_id')} (tenant: {user_context.get('tenant_id')}) for {request.url.path}")
            
        except Exception as e:
            logger.error(f"Authentication middleware error: {str(e)}")
            return JSONResponse(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                content={
                    "error": "Authentication service error", 
                    "code": "AUTH_SERVICE_ERROR",
                    "message": "Internal authentication system error"
                }
            )
            
        return await call_next(request)
        
    def _is_public_path(self, path: str) -> bool:
        """Check if path is public (no authentication required)"""
        return any(path.startswith(public_path) for public_path in self.public_paths)
        
    def _extract_token(self, request: Request) -> Optional[str]:
        """Extract JWT token from Authorization header"""
        auth_header = request.headers.get("Authorization")
        if not auth_header:
            return None
            
        if not auth_header.startswith("Bearer "):
            return None
            
        return auth_header[7:]  # Remove "Bearer " prefix
        
    async def _validate_token(self, token: str) -> Optional[Dict[str, Any]]:
        """Validate token with auth service via gRPC using proper proto"""
        try:
            # Create gRPC channel to auth service
            channel = grpc.aio.insecure_channel(self.auth_service_host)
            stub = AuthServiceStub(channel)
            
            # Call ValidateToken method using proper proto
            request = ValidateTokenRequest(access_token=token)
            response = await stub.ValidateToken(request)
            
            await channel.close()
            
            if response.success:
                return {
                    "user_id": response.user_id,
                    "tenant_id": response.tenant_id,
                    "role": response.role,
                    "email": response.email,
                    "is_active": response.is_active
                }
            else:
                logger.warning(f"Token validation failed: {response.message}")
                return None
                
        except grpc.RpcError as e:
            logger.error(f"gRPC error during token validation: {e.code()}: {e.details()}")
            return None
        except Exception as e:
            logger.error(f"Unexpected error during token validation: {e}")
            return None
