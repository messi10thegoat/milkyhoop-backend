# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE email = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'email': 'ggciceaie',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'email': 'bbehjachib',
                },
                {
                    # data to create a User record
                    'email': 'cadfabfehe',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 'dgiiaaijj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 'bfaiacjjfc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 'eigcfgbif',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the tenantId field
        users = await User.prisma().find_many(
            take=5,
            order={
                'tenantId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the username field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'username': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the name field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 'bagcfbhiig',
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 'cghideieh',
            },
            data={
                'create': {
                    'id': 'cghideieh',
                    'email': 'cadfabfehe',
                },
                'update': {
                    'email': 'cadfabfehe',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'fullname': 'biabhbdai'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'nickname': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'avatarUrl': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by coverPhotoUrl values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['coverPhotoUrl'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AccountActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Account]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Account.prisma().query_raw(
            'SELECT * FROM Account WHERE id = $1',
            'idghgaicb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Account
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Account.prisma().query_first(
            'SELECT * FROM Account WHERE userId = $1',
            'fjfddhigg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AccountCreateInput,
        include: Optional[types.AccountInclude] = None
    ) -> _PrismaModelT:
        """Create a new Account record.

        Parameters
        ----------
        data
            Account record data
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The created Account record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Account record from just the required fields
        account = await Account.prisma().create(
            data={
                # data to create a Account record
                'userId': 'hjaecfifb',
                'type': 'cbbbjbfcii',
                'provider': 'bbejhfidcb',
                'providerAccountId': 'bgeecijdgg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AccountCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Account records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Account record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Account.prisma().create_many(
            data=[
                {
                    # data to create a Account record
                    'userId': 'bdiicjafbj',
                    'type': 'bgehebiafc',
                    'provider': 'bghffegacj',
                    'providerAccountId': 'bhghchehcc',
                },
                {
                    # data to create a Account record
                    'userId': 'dcgchcbbf',
                    'type': 'bdedcabahc',
                    'provider': 'ghfhiafcb',
                    'providerAccountId': 'heejgedji',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AccountWhereUniqueInput,
        include: Optional[types.AccountInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Account record.

        Parameters
        ----------
        where
            Account filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The deleted Account record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        account = await Account.prisma().delete(
            where={
                'id': 'bjgjgibgbf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AccountWhereUniqueInput,
        include: Optional[types.AccountInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Account record.

        Parameters
        ----------
        where
            Account filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The found Account record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        account = await Account.prisma().find_unique(
            where={
                'id': 'bbbgbhfjge',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AccountWhereUniqueInput,
        include: Optional[types.AccountInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Account record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Account filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The found Account record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        account = await Account.prisma().find_unique_or_raise(
            where={
                'id': 'igbehcbab',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
        include: Optional[types.AccountInclude] = None,
        order: Optional[Union[types.AccountOrderByInput, List[types.AccountOrderByInput]]] = None,
        distinct: Optional[List[types.AccountScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Account records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Account records returned
        skip
            Ignore the first N results
        where
            Account filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Account model
        order
            Order the returned Account records by any field
        distinct
            Filter Account records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Account]
            The list of all Account records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Account records
        accounts = await Account.prisma().find_many(take=10)

        # find the first 5 Account records ordered by the type field
        accounts = await Account.prisma().find_many(
            take=5,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
        include: Optional[types.AccountInclude] = None,
        order: Optional[Union[types.AccountOrderByInput, List[types.AccountOrderByInput]]] = None,
        distinct: Optional[List[types.AccountScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Account record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Account filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Account model
        order
            Order the returned Account records by any field
        distinct
            Filter Account records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Account
            The first Account record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Account record ordered by the provider field
        account = await Account.prisma().find_first(
            skip=1,
            order={
                'provider': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
        include: Optional[types.AccountInclude] = None,
        order: Optional[Union[types.AccountOrderByInput, List[types.AccountOrderByInput]]] = None,
        distinct: Optional[List[types.AccountScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Account record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Account filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Account model
        order
            Order the returned Account records by any field
        distinct
            Filter Account records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Account
            The first Account record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Account record ordered by the providerAccountId field
        account = await Account.prisma().find_first_or_raise(
            skip=1,
            order={
                'providerAccountId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AccountUpdateInput,
        where: types.AccountWhereUniqueInput,
        include: Optional[types.AccountInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Account record.

        Parameters
        ----------
        data
            Account record data specifying what to update
        where
            Account filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The updated Account record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        account = await Account.prisma().update(
            where={
                'id': 'bdadaadhag',
            },
            data={
                # data to update the Account record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AccountWhereUniqueInput,
        data: types.AccountUpsertInput,
        include: Optional[types.AccountInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Account filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The created or updated Account record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        account = await Account.prisma().upsert(
            where={
                'id': 'bgiggdidbf',
            },
            data={
                'create': {
                    'id': 'bgiggdidbf',
                    'userId': 'dcgchcbbf',
                    'type': 'bdedcabahc',
                    'provider': 'ghfhiafcb',
                    'providerAccountId': 'heejgedji',
                },
                'update': {
                    'userId': 'dcgchcbbf',
                    'type': 'bdedcabahc',
                    'provider': 'ghfhiafcb',
                    'providerAccountId': 'heejgedji',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AccountUpdateManyMutationInput,
        where: types.AccountWhereInput,
    ) -> int:
        """Update multiple Account records

        Parameters
        ----------
        data
            Account data to update the selected Account records to
        where
            Filter to select the Account records to update

        Returns
        -------
        int
            The total number of Account records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Account records
        total = await Account.prisma().update_many(
            data={
                'access_token': 'caaaedabfc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Account records present in the database

        Parameters
        ----------
        select
            Select the Account fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Account filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AccountCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Account.prisma().count()

        # results: prisma.types.AccountCountAggregateOutput
        results = await Account.prisma().count(
            select={
                '_all': True,
                'expires_at': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AccountCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
    ) -> types.AccountCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AccountCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
    ) -> Union[int, types.AccountCountAggregateOutput]:
        """Count the number of Account records present in the database

        Parameters
        ----------
        select
            Select the Account fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Account filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AccountCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Account.prisma().count()

        # results: prisma.types.AccountCountAggregateOutput
        results = await Account.prisma().count(
            select={
                '_all': True,
                'id_token': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AccountCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AccountWhereInput] = None
    ) -> int:
        """Delete multiple Account records.

        Parameters
        ----------
        where
            Optional Account filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Account records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Account records
        total = await Account.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AccountScalarFieldKeys'],
        *,
        where: Optional['types.AccountWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AccountAvgAggregateInput'] = None,
        sum: Optional['types.AccountSumAggregateInput'] = None,
        min: Optional['types.AccountMinAggregateInput'] = None,
        max: Optional['types.AccountMaxAggregateInput'] = None,
        having: Optional['types.AccountScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AccountCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AccountScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AccountScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AccountGroupByOutput']:
        """Group Account records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Account fields to group records by
        where
            Account filter to select records
        take
            Limit the maximum number of Account records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AccountGroupByOutput]
            A list of dictionaries representing the Account record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Account records by refresh_token values
        # and count how many records are in each group
        results = await Account.prisma().group_by(
            ['refresh_token'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SessionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Session]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Session.prisma().query_raw(
            'SELECT * FROM Session WHERE id = $1',
            'bigibebcib',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Session
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Session.prisma().query_first(
            'SELECT * FROM Session WHERE sessionToken = $1',
            'bigaiehgcc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SessionCreateInput,
        include: Optional[types.SessionInclude] = None
    ) -> _PrismaModelT:
        """Create a new Session record.

        Parameters
        ----------
        data
            Session record data
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The created Session record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Session record from just the required fields
        session = await Session.prisma().create(
            data={
                # data to create a Session record
                'sessionToken': 'beeifcbebf',
                'userId': 'bgcigfahea',
                'expires': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SessionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Session records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Session record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Session.prisma().create_many(
            data=[
                {
                    # data to create a Session record
                    'sessionToken': 'bcejgaggif',
                    'userId': 'idfjadbcc',
                    'expires': datetime.datetime.utcnow(),
                },
                {
                    # data to create a Session record
                    'sessionToken': 'hgdhbjhhj',
                    'userId': 'ecjjjfbae',
                    'expires': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Session record.

        Parameters
        ----------
        where
            Session filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The deleted Session record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = await Session.prisma().delete(
            where={
                'id': 'bhhfibbigf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Session record.

        Parameters
        ----------
        where
            Session filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The found Session record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = await Session.prisma().find_unique(
            where={
                'id': 'ijdbeffgg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Session record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Session filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The found Session record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = await Session.prisma().find_unique_or_raise(
            where={
                'id': 'jjfeafhfj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
        include: Optional[types.SessionInclude] = None,
        order: Optional[Union[types.SessionOrderByInput, List[types.SessionOrderByInput]]] = None,
        distinct: Optional[List[types.SessionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Session records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Session records returned
        skip
            Ignore the first N results
        where
            Session filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Session model
        order
            Order the returned Session records by any field
        distinct
            Filter Session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Session]
            The list of all Session records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Session records
        sessions = await Session.prisma().find_many(take=10)

        # find the first 5 Session records ordered by the userId field
        sessions = await Session.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
        include: Optional[types.SessionInclude] = None,
        order: Optional[Union[types.SessionOrderByInput, List[types.SessionOrderByInput]]] = None,
        distinct: Optional[List[types.SessionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Session record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Session filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Session model
        order
            Order the returned Session records by any field
        distinct
            Filter Session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Session
            The first Session record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Session record ordered by the expires field
        session = await Session.prisma().find_first(
            skip=1,
            order={
                'expires': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
        include: Optional[types.SessionInclude] = None,
        order: Optional[Union[types.SessionOrderByInput, List[types.SessionOrderByInput]]] = None,
        distinct: Optional[List[types.SessionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Session record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Session filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Session model
        order
            Order the returned Session records by any field
        distinct
            Filter Session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Session
            The first Session record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Session record ordered by the id field
        session = await Session.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SessionUpdateInput,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Session record.

        Parameters
        ----------
        data
            Session record data specifying what to update
        where
            Session filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The updated Session record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        session = await Session.prisma().update(
            where={
                'id': 'cbachdgfce',
            },
            data={
                # data to update the Session record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SessionWhereUniqueInput,
        data: types.SessionUpsertInput,
        include: Optional[types.SessionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Session filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The created or updated Session record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = await Session.prisma().upsert(
            where={
                'id': 'chbfcacbd',
            },
            data={
                'create': {
                    'id': 'chbfcacbd',
                    'sessionToken': 'hgdhbjhhj',
                    'userId': 'ecjjjfbae',
                    'expires': datetime.datetime.utcnow(),
                },
                'update': {
                    'sessionToken': 'hgdhbjhhj',
                    'userId': 'ecjjjfbae',
                    'expires': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SessionUpdateManyMutationInput,
        where: types.SessionWhereInput,
    ) -> int:
        """Update multiple Session records

        Parameters
        ----------
        data
            Session data to update the selected Session records to
        where
            Filter to select the Session records to update

        Returns
        -------
        int
            The total number of Session records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Session records
        total = await Session.prisma().update_many(
            data={
                'sessionToken': 'efggddide'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Session records present in the database

        Parameters
        ----------
        select
            Select the Session fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Session filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Session.prisma().count()

        # results: prisma.types.SessionCountAggregateOutput
        results = await Session.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SessionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
    ) -> types.SessionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SessionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
    ) -> Union[int, types.SessionCountAggregateOutput]:
        """Count the number of Session records present in the database

        Parameters
        ----------
        select
            Select the Session fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Session filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Session.prisma().count()

        # results: prisma.types.SessionCountAggregateOutput
        results = await Session.prisma().count(
            select={
                '_all': True,
                'expires': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SessionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SessionWhereInput] = None
    ) -> int:
        """Delete multiple Session records.

        Parameters
        ----------
        where
            Optional Session filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Session records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Session records
        total = await Session.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SessionScalarFieldKeys'],
        *,
        where: Optional['types.SessionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SessionAvgAggregateInput'] = None,
        sum: Optional['types.SessionSumAggregateInput'] = None,
        min: Optional['types.SessionMinAggregateInput'] = None,
        max: Optional['types.SessionMaxAggregateInput'] = None,
        having: Optional['types.SessionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SessionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SessionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SessionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SessionGroupByOutput']:
        """Group Session records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Session fields to group records by
        where
            Session filter to select records
        take
            Limit the maximum number of Session records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SessionGroupByOutput]
            A list of dictionaries representing the Session record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Session records by id values
        # and count how many records are in each group
        results = await Session.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class RefreshTokenActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.RefreshToken]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await RefreshToken.prisma().query_raw(
            'SELECT * FROM RefreshToken WHERE id = $1',
            'caficfigfb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.RefreshToken
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await RefreshToken.prisma().query_first(
            'SELECT * FROM RefreshToken WHERE userId = $1',
            'bfidgijfjc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.RefreshTokenCreateInput,
        include: Optional[types.RefreshTokenInclude] = None
    ) -> _PrismaModelT:
        """Create a new RefreshToken record.

        Parameters
        ----------
        data
            RefreshToken record data
        include
            Specifies which relations should be loaded on the returned RefreshToken model

        Returns
        -------
        prisma.models.RefreshToken
            The created RefreshToken record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a RefreshToken record from just the required fields
        refreshtoken = await RefreshToken.prisma().create(
            data={
                # data to create a RefreshToken record
                'userId': 'ihieecagf',
                'tenantId': 'bghfciaafe',
                'tokenHash': 'bgchfhgceh',
                'expiresAt': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.RefreshTokenCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple RefreshToken records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of RefreshToken record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await RefreshToken.prisma().create_many(
            data=[
                {
                    # data to create a RefreshToken record
                    'userId': 'cafeiaccbc',
                    'tenantId': 'gaddfhfh',
                    'tokenHash': 'gieegcbeg',
                    'expiresAt': datetime.datetime.utcnow(),
                },
                {
                    # data to create a RefreshToken record
                    'userId': 'bgcffadich',
                    'tenantId': 'fcbichhci',
                    'tokenHash': 'bcggadccgf',
                    'expiresAt': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.RefreshTokenWhereUniqueInput,
        include: Optional[types.RefreshTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single RefreshToken record.

        Parameters
        ----------
        where
            RefreshToken filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned RefreshToken model

        Returns
        -------
        prisma.models.RefreshToken
            The deleted RefreshToken record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        refreshtoken = await RefreshToken.prisma().delete(
            where={
                'id': 'jdcfdcgc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.RefreshTokenWhereUniqueInput,
        include: Optional[types.RefreshTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique RefreshToken record.

        Parameters
        ----------
        where
            RefreshToken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned RefreshToken model

        Returns
        -------
        prisma.models.RefreshToken
            The found RefreshToken record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        refreshtoken = await RefreshToken.prisma().find_unique(
            where={
                'id': 'cafdaehjid',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.RefreshTokenWhereUniqueInput,
        include: Optional[types.RefreshTokenInclude] = None
    ) -> _PrismaModelT:
        """Find a unique RefreshToken record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            RefreshToken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned RefreshToken model

        Returns
        -------
        prisma.models.RefreshToken
            The found RefreshToken record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        refreshtoken = await RefreshToken.prisma().find_unique_or_raise(
            where={
                'id': 'gifdddbia',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RefreshTokenWhereInput] = None,
        cursor: Optional[types.RefreshTokenWhereUniqueInput] = None,
        include: Optional[types.RefreshTokenInclude] = None,
        order: Optional[Union[types.RefreshTokenOrderByInput, List[types.RefreshTokenOrderByInput]]] = None,
        distinct: Optional[List[types.RefreshTokenScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple RefreshToken records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of RefreshToken records returned
        skip
            Ignore the first N results
        where
            RefreshToken filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RefreshToken model
        order
            Order the returned RefreshToken records by any field
        distinct
            Filter RefreshToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.RefreshToken]
            The list of all RefreshToken records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 RefreshToken records
        refreshtokens = await RefreshToken.prisma().find_many(take=10)

        # find the first 5 RefreshToken records ordered by the tenantId field
        refreshtokens = await RefreshToken.prisma().find_many(
            take=5,
            order={
                'tenantId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RefreshTokenWhereInput] = None,
        cursor: Optional[types.RefreshTokenWhereUniqueInput] = None,
        include: Optional[types.RefreshTokenInclude] = None,
        order: Optional[Union[types.RefreshTokenOrderByInput, List[types.RefreshTokenOrderByInput]]] = None,
        distinct: Optional[List[types.RefreshTokenScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single RefreshToken record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            RefreshToken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RefreshToken model
        order
            Order the returned RefreshToken records by any field
        distinct
            Filter RefreshToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.RefreshToken
            The first RefreshToken record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second RefreshToken record ordered by the tokenHash field
        refreshtoken = await RefreshToken.prisma().find_first(
            skip=1,
            order={
                'tokenHash': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RefreshTokenWhereInput] = None,
        cursor: Optional[types.RefreshTokenWhereUniqueInput] = None,
        include: Optional[types.RefreshTokenInclude] = None,
        order: Optional[Union[types.RefreshTokenOrderByInput, List[types.RefreshTokenOrderByInput]]] = None,
        distinct: Optional[List[types.RefreshTokenScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single RefreshToken record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            RefreshToken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RefreshToken model
        order
            Order the returned RefreshToken records by any field
        distinct
            Filter RefreshToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.RefreshToken
            The first RefreshToken record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second RefreshToken record ordered by the expiresAt field
        refreshtoken = await RefreshToken.prisma().find_first_or_raise(
            skip=1,
            order={
                'expiresAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.RefreshTokenUpdateInput,
        where: types.RefreshTokenWhereUniqueInput,
        include: Optional[types.RefreshTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single RefreshToken record.

        Parameters
        ----------
        data
            RefreshToken record data specifying what to update
        where
            RefreshToken filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned RefreshToken model

        Returns
        -------
        prisma.models.RefreshToken
            The updated RefreshToken record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        refreshtoken = await RefreshToken.prisma().update(
            where={
                'id': 'bchehecef',
            },
            data={
                # data to update the RefreshToken record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.RefreshTokenWhereUniqueInput,
        data: types.RefreshTokenUpsertInput,
        include: Optional[types.RefreshTokenInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            RefreshToken filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned RefreshToken model

        Returns
        -------
        prisma.models.RefreshToken
            The created or updated RefreshToken record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        refreshtoken = await RefreshToken.prisma().upsert(
            where={
                'id': 'jeijcbhfe',
            },
            data={
                'create': {
                    'id': 'jeijcbhfe',
                    'userId': 'bgcffadich',
                    'tenantId': 'fcbichhci',
                    'tokenHash': 'bcggadccgf',
                    'expiresAt': datetime.datetime.utcnow(),
                },
                'update': {
                    'userId': 'bgcffadich',
                    'tenantId': 'fcbichhci',
                    'tokenHash': 'bcggadccgf',
                    'expiresAt': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.RefreshTokenUpdateManyMutationInput,
        where: types.RefreshTokenWhereInput,
    ) -> int:
        """Update multiple RefreshToken records

        Parameters
        ----------
        data
            RefreshToken data to update the selected RefreshToken records to
        where
            Filter to select the RefreshToken records to update

        Returns
        -------
        int
            The total number of RefreshToken records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all RefreshToken records
        total = await RefreshToken.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RefreshTokenWhereInput] = None,
        cursor: Optional[types.RefreshTokenWhereUniqueInput] = None,
    ) -> int:
        """Count the number of RefreshToken records present in the database

        Parameters
        ----------
        select
            Select the RefreshToken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            RefreshToken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RefreshTokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await RefreshToken.prisma().count()

        # results: prisma.types.RefreshTokenCountAggregateOutput
        results = await RefreshToken.prisma().count(
            select={
                '_all': True,
                'revokedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.RefreshTokenCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RefreshTokenWhereInput] = None,
        cursor: Optional[types.RefreshTokenWhereUniqueInput] = None,
    ) -> types.RefreshTokenCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.RefreshTokenCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RefreshTokenWhereInput] = None,
        cursor: Optional[types.RefreshTokenWhereUniqueInput] = None,
    ) -> Union[int, types.RefreshTokenCountAggregateOutput]:
        """Count the number of RefreshToken records present in the database

        Parameters
        ----------
        select
            Select the RefreshToken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            RefreshToken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RefreshTokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await RefreshToken.prisma().count()

        # results: prisma.types.RefreshTokenCountAggregateOutput
        results = await RefreshToken.prisma().count(
            select={
                '_all': True,
                'deviceInfo': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.RefreshTokenCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.RefreshTokenWhereInput] = None
    ) -> int:
        """Delete multiple RefreshToken records.

        Parameters
        ----------
        where
            Optional RefreshToken filter to find the records to be deleted

        Returns
        -------
        int
            The total number of RefreshToken records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all RefreshToken records
        total = await RefreshToken.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.RefreshTokenScalarFieldKeys'],
        *,
        where: Optional['types.RefreshTokenWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.RefreshTokenAvgAggregateInput'] = None,
        sum: Optional['types.RefreshTokenSumAggregateInput'] = None,
        min: Optional['types.RefreshTokenMinAggregateInput'] = None,
        max: Optional['types.RefreshTokenMaxAggregateInput'] = None,
        having: Optional['types.RefreshTokenScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.RefreshTokenCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.RefreshTokenScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.RefreshTokenScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.RefreshTokenGroupByOutput']:
        """Group RefreshToken records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar RefreshToken fields to group records by
        where
            RefreshToken filter to select records
        take
            Limit the maximum number of RefreshToken records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.RefreshTokenGroupByOutput]
            A list of dictionaries representing the RefreshToken record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group RefreshToken records by lastUsedAt values
        # and count how many records are in each group
        results = await RefreshToken.prisma().group_by(
            ['lastUsedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserSecurityActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserSecurity]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserSecurity.prisma().query_raw(
            'SELECT * FROM UserSecurity WHERE id = $1',
            'bjgejjabff',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserSecurity
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserSecurity.prisma().query_first(
            'SELECT * FROM UserSecurity WHERE userId = $1',
            'bcciijbibg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserSecurityCreateInput,
        include: Optional[types.UserSecurityInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserSecurity record.

        Parameters
        ----------
        data
            UserSecurity record data
        include
            Specifies which relations should be loaded on the returned UserSecurity model

        Returns
        -------
        prisma.models.UserSecurity
            The created UserSecurity record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserSecurity record from just the required fields
        usersecurity = await UserSecurity.prisma().create(
            data={
                # data to create a UserSecurity record
                'userId': 'cffcachfd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserSecurityCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserSecurity records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserSecurity record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserSecurity.prisma().create_many(
            data=[
                {
                    # data to create a UserSecurity record
                    'userId': 'bccdfhdigc',
                },
                {
                    # data to create a UserSecurity record
                    'userId': 'febcgjbfj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserSecurityWhereUniqueInput,
        include: Optional[types.UserSecurityInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserSecurity record.

        Parameters
        ----------
        where
            UserSecurity filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserSecurity model

        Returns
        -------
        prisma.models.UserSecurity
            The deleted UserSecurity record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usersecurity = await UserSecurity.prisma().delete(
            where={
                'id': 'bageiegghg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserSecurityWhereUniqueInput,
        include: Optional[types.UserSecurityInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserSecurity record.

        Parameters
        ----------
        where
            UserSecurity filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserSecurity model

        Returns
        -------
        prisma.models.UserSecurity
            The found UserSecurity record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usersecurity = await UserSecurity.prisma().find_unique(
            where={
                'id': 'faidicegb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserSecurityWhereUniqueInput,
        include: Optional[types.UserSecurityInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserSecurity record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserSecurity filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserSecurity model

        Returns
        -------
        prisma.models.UserSecurity
            The found UserSecurity record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usersecurity = await UserSecurity.prisma().find_unique_or_raise(
            where={
                'id': 'bacecgfhbe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserSecurityWhereInput] = None,
        cursor: Optional[types.UserSecurityWhereUniqueInput] = None,
        include: Optional[types.UserSecurityInclude] = None,
        order: Optional[Union[types.UserSecurityOrderByInput, List[types.UserSecurityOrderByInput]]] = None,
        distinct: Optional[List[types.UserSecurityScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserSecurity records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserSecurity records returned
        skip
            Ignore the first N results
        where
            UserSecurity filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserSecurity model
        order
            Order the returned UserSecurity records by any field
        distinct
            Filter UserSecurity records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserSecurity]
            The list of all UserSecurity records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserSecurity records
        usersecuritys = await UserSecurity.prisma().find_many(take=10)

        # find the first 5 UserSecurity records ordered by the passwordHash field
        usersecuritys = await UserSecurity.prisma().find_many(
            take=5,
            order={
                'passwordHash': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserSecurityWhereInput] = None,
        cursor: Optional[types.UserSecurityWhereUniqueInput] = None,
        include: Optional[types.UserSecurityInclude] = None,
        order: Optional[Union[types.UserSecurityOrderByInput, List[types.UserSecurityOrderByInput]]] = None,
        distinct: Optional[List[types.UserSecurityScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserSecurity record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserSecurity filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserSecurity model
        order
            Order the returned UserSecurity records by any field
        distinct
            Filter UserSecurity records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserSecurity
            The first UserSecurity record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserSecurity record ordered by the twoFactorEnabled field
        usersecurity = await UserSecurity.prisma().find_first(
            skip=1,
            order={
                'twoFactorEnabled': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserSecurityWhereInput] = None,
        cursor: Optional[types.UserSecurityWhereUniqueInput] = None,
        include: Optional[types.UserSecurityInclude] = None,
        order: Optional[Union[types.UserSecurityOrderByInput, List[types.UserSecurityOrderByInput]]] = None,
        distinct: Optional[List[types.UserSecurityScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserSecurity record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserSecurity filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserSecurity model
        order
            Order the returned UserSecurity records by any field
        distinct
            Filter UserSecurity records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserSecurity
            The first UserSecurity record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserSecurity record ordered by the oauthId field
        usersecurity = await UserSecurity.prisma().find_first_or_raise(
            skip=1,
            order={
                'oauthId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserSecurityUpdateInput,
        where: types.UserSecurityWhereUniqueInput,
        include: Optional[types.UserSecurityInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserSecurity record.

        Parameters
        ----------
        data
            UserSecurity record data specifying what to update
        where
            UserSecurity filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserSecurity model

        Returns
        -------
        prisma.models.UserSecurity
            The updated UserSecurity record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        usersecurity = await UserSecurity.prisma().update(
            where={
                'id': 'ihcahiead',
            },
            data={
                # data to update the UserSecurity record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserSecurityWhereUniqueInput,
        data: types.UserSecurityUpsertInput,
        include: Optional[types.UserSecurityInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserSecurity filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserSecurity model

        Returns
        -------
        prisma.models.UserSecurity
            The created or updated UserSecurity record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usersecurity = await UserSecurity.prisma().upsert(
            where={
                'id': 'biheheiajg',
            },
            data={
                'create': {
                    'id': 'biheheiajg',
                    'userId': 'febcgjbfj',
                },
                'update': {
                    'userId': 'febcgjbfj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserSecurityUpdateManyMutationInput,
        where: types.UserSecurityWhereInput,
    ) -> int:
        """Update multiple UserSecurity records

        Parameters
        ----------
        data
            UserSecurity data to update the selected UserSecurity records to
        where
            Filter to select the UserSecurity records to update

        Returns
        -------
        int
            The total number of UserSecurity records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserSecurity records
        total = await UserSecurity.prisma().update_many(
            data={
                'oauthProvider': 'jbgijghgb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserSecurityWhereInput] = None,
        cursor: Optional[types.UserSecurityWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserSecurity records present in the database

        Parameters
        ----------
        select
            Select the UserSecurity fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserSecurity filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserSecurityCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserSecurity.prisma().count()

        # results: prisma.types.UserSecurityCountAggregateOutput
        results = await UserSecurity.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserSecurityCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserSecurityWhereInput] = None,
        cursor: Optional[types.UserSecurityWhereUniqueInput] = None,
    ) -> types.UserSecurityCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserSecurityCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserSecurityWhereInput] = None,
        cursor: Optional[types.UserSecurityWhereUniqueInput] = None,
    ) -> Union[int, types.UserSecurityCountAggregateOutput]:
        """Count the number of UserSecurity records present in the database

        Parameters
        ----------
        select
            Select the UserSecurity fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserSecurity filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserSecurityCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserSecurity.prisma().count()

        # results: prisma.types.UserSecurityCountAggregateOutput
        results = await UserSecurity.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserSecurityCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserSecurityWhereInput] = None
    ) -> int:
        """Delete multiple UserSecurity records.

        Parameters
        ----------
        where
            Optional UserSecurity filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserSecurity records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserSecurity records
        total = await UserSecurity.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserSecurityScalarFieldKeys'],
        *,
        where: Optional['types.UserSecurityWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserSecurityAvgAggregateInput'] = None,
        sum: Optional['types.UserSecuritySumAggregateInput'] = None,
        min: Optional['types.UserSecurityMinAggregateInput'] = None,
        max: Optional['types.UserSecurityMaxAggregateInput'] = None,
        having: Optional['types.UserSecurityScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserSecurityCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserSecurityScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserSecurityScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserSecurityGroupByOutput']:
        """Group UserSecurity records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserSecurity fields to group records by
        where
            UserSecurity filter to select records
        take
            Limit the maximum number of UserSecurity records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserSecurityGroupByOutput]
            A list of dictionaries representing the UserSecurity record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserSecurity records by passwordHash values
        # and count how many records are in each group
        results = await UserSecurity.prisma().group_by(
            ['passwordHash'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserProfileActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserProfile]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserProfile.prisma().query_raw(
            'SELECT * FROM UserProfile WHERE id = $1',
            'hgjcghfbi',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserProfile
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserProfile.prisma().query_first(
            'SELECT * FROM UserProfile WHERE userId = $1',
            'icadbcehj',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserProfileCreateInput,
        include: Optional[types.UserProfileInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserProfile record.

        Parameters
        ----------
        data
            UserProfile record data
        include
            Specifies which relations should be loaded on the returned UserProfile model

        Returns
        -------
        prisma.models.UserProfile
            The created UserProfile record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserProfile record from just the required fields
        userprofile = await UserProfile.prisma().create(
            data={
                # data to create a UserProfile record
                'userId': 'jchciaee',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserProfileCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserProfile records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserProfile record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserProfile.prisma().create_many(
            data=[
                {
                    # data to create a UserProfile record
                    'userId': 'deeificjd',
                },
                {
                    # data to create a UserProfile record
                    'userId': 'bbcbhebbda',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserProfileWhereUniqueInput,
        include: Optional[types.UserProfileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserProfile record.

        Parameters
        ----------
        where
            UserProfile filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserProfile model

        Returns
        -------
        prisma.models.UserProfile
            The deleted UserProfile record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userprofile = await UserProfile.prisma().delete(
            where={
                'id': 'bejfijgcfb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserProfileWhereUniqueInput,
        include: Optional[types.UserProfileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserProfile record.

        Parameters
        ----------
        where
            UserProfile filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserProfile model

        Returns
        -------
        prisma.models.UserProfile
            The found UserProfile record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userprofile = await UserProfile.prisma().find_unique(
            where={
                'id': 'caifcbgii',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserProfileWhereUniqueInput,
        include: Optional[types.UserProfileInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserProfile record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserProfile filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserProfile model

        Returns
        -------
        prisma.models.UserProfile
            The found UserProfile record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userprofile = await UserProfile.prisma().find_unique_or_raise(
            where={
                'id': 'igaibbfgj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserProfileWhereInput] = None,
        cursor: Optional[types.UserProfileWhereUniqueInput] = None,
        include: Optional[types.UserProfileInclude] = None,
        order: Optional[Union[types.UserProfileOrderByInput, List[types.UserProfileOrderByInput]]] = None,
        distinct: Optional[List[types.UserProfileScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserProfile records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserProfile records returned
        skip
            Ignore the first N results
        where
            UserProfile filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserProfile model
        order
            Order the returned UserProfile records by any field
        distinct
            Filter UserProfile records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserProfile]
            The list of all UserProfile records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserProfile records
        userprofiles = await UserProfile.prisma().find_many(take=10)

        # find the first 5 UserProfile records ordered by the bio field
        userprofiles = await UserProfile.prisma().find_many(
            take=5,
            order={
                'bio': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserProfileWhereInput] = None,
        cursor: Optional[types.UserProfileWhereUniqueInput] = None,
        include: Optional[types.UserProfileInclude] = None,
        order: Optional[Union[types.UserProfileOrderByInput, List[types.UserProfileOrderByInput]]] = None,
        distinct: Optional[List[types.UserProfileScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserProfile record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserProfile filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserProfile model
        order
            Order the returned UserProfile records by any field
        distinct
            Filter UserProfile records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserProfile
            The first UserProfile record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserProfile record ordered by the phoneNumber field
        userprofile = await UserProfile.prisma().find_first(
            skip=1,
            order={
                'phoneNumber': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserProfileWhereInput] = None,
        cursor: Optional[types.UserProfileWhereUniqueInput] = None,
        include: Optional[types.UserProfileInclude] = None,
        order: Optional[Union[types.UserProfileOrderByInput, List[types.UserProfileOrderByInput]]] = None,
        distinct: Optional[List[types.UserProfileScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserProfile record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserProfile filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserProfile model
        order
            Order the returned UserProfile records by any field
        distinct
            Filter UserProfile records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserProfile
            The first UserProfile record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserProfile record ordered by the tagline field
        userprofile = await UserProfile.prisma().find_first_or_raise(
            skip=1,
            order={
                'tagline': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserProfileUpdateInput,
        where: types.UserProfileWhereUniqueInput,
        include: Optional[types.UserProfileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserProfile record.

        Parameters
        ----------
        data
            UserProfile record data specifying what to update
        where
            UserProfile filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserProfile model

        Returns
        -------
        prisma.models.UserProfile
            The updated UserProfile record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        userprofile = await UserProfile.prisma().update(
            where={
                'id': 'bggajdcbbi',
            },
            data={
                # data to update the UserProfile record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserProfileWhereUniqueInput,
        data: types.UserProfileUpsertInput,
        include: Optional[types.UserProfileInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserProfile filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserProfile model

        Returns
        -------
        prisma.models.UserProfile
            The created or updated UserProfile record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userprofile = await UserProfile.prisma().upsert(
            where={
                'id': 'fcfhgbjed',
            },
            data={
                'create': {
                    'id': 'fcfhgbjed',
                    'userId': 'bbcbhebbda',
                },
                'update': {
                    'userId': 'bbcbhebbda',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserProfileUpdateManyMutationInput,
        where: types.UserProfileWhereInput,
    ) -> int:
        """Update multiple UserProfile records

        Parameters
        ----------
        data
            UserProfile data to update the selected UserProfile records to
        where
            Filter to select the UserProfile records to update

        Returns
        -------
        int
            The total number of UserProfile records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserProfile records
        total = await UserProfile.prisma().update_many(
            data={
                'publicUrlSlug': 'hdgcajhjg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserProfileWhereInput] = None,
        cursor: Optional[types.UserProfileWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserProfile records present in the database

        Parameters
        ----------
        select
            Select the UserProfile fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserProfile filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserProfileCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserProfile.prisma().count()

        # results: prisma.types.UserProfileCountAggregateOutput
        results = await UserProfile.prisma().count(
            select={
                '_all': True,
                'digitalSignature': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserProfileCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserProfileWhereInput] = None,
        cursor: Optional[types.UserProfileWhereUniqueInput] = None,
    ) -> types.UserProfileCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserProfileCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserProfileWhereInput] = None,
        cursor: Optional[types.UserProfileWhereUniqueInput] = None,
    ) -> Union[int, types.UserProfileCountAggregateOutput]:
        """Count the number of UserProfile records present in the database

        Parameters
        ----------
        select
            Select the UserProfile fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserProfile filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserProfileCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserProfile.prisma().count()

        # results: prisma.types.UserProfileCountAggregateOutput
        results = await UserProfile.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserProfileCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserProfileWhereInput] = None
    ) -> int:
        """Delete multiple UserProfile records.

        Parameters
        ----------
        where
            Optional UserProfile filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserProfile records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserProfile records
        total = await UserProfile.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserProfileScalarFieldKeys'],
        *,
        where: Optional['types.UserProfileWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserProfileAvgAggregateInput'] = None,
        sum: Optional['types.UserProfileSumAggregateInput'] = None,
        min: Optional['types.UserProfileMinAggregateInput'] = None,
        max: Optional['types.UserProfileMaxAggregateInput'] = None,
        having: Optional['types.UserProfileScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserProfileCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserProfileScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserProfileScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserProfileGroupByOutput']:
        """Group UserProfile records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserProfile fields to group records by
        where
            UserProfile filter to select records
        take
            Limit the maximum number of UserProfile records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserProfileGroupByOutput]
            A list of dictionaries representing the UserProfile record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserProfile records by userId values
        # and count how many records are in each group
        results = await UserProfile.prisma().group_by(
            ['userId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class VerificationTokenActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.VerificationToken]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await VerificationToken.prisma().query_raw(
            'SELECT * FROM VerificationToken WHERE identifier = $1',
            'ejdjahicb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.VerificationToken
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await VerificationToken.prisma().query_first(
            'SELECT * FROM VerificationToken WHERE token = $1',
            'gdjgigfgc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.VerificationTokenCreateInput,
        include: Optional[types.VerificationTokenInclude] = None
    ) -> _PrismaModelT:
        """Create a new VerificationToken record.

        Parameters
        ----------
        data
            VerificationToken record data
        include
            Specifies which relations should be loaded on the returned VerificationToken model

        Returns
        -------
        prisma.models.VerificationToken
            The created VerificationToken record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a VerificationToken record from just the required fields
        verificationtoken = await VerificationToken.prisma().create(
            data={
                # data to create a VerificationToken record
                'identifier': 'gfeaahdeh',
                'token': 'bjafcgbffc',
                'expires': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.VerificationTokenCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple VerificationToken records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of VerificationToken record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await VerificationToken.prisma().create_many(
            data=[
                {
                    # data to create a VerificationToken record
                    'identifier': 'hihegjif',
                    'token': 'bdjidcidac',
                    'expires': datetime.datetime.utcnow(),
                },
                {
                    # data to create a VerificationToken record
                    'identifier': 'ifgaaagff',
                    'token': 'befcddgjce',
                    'expires': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.VerificationTokenWhereUniqueInput,
        include: Optional[types.VerificationTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single VerificationToken record.

        Parameters
        ----------
        where
            VerificationToken filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned VerificationToken model

        Returns
        -------
        prisma.models.VerificationToken
            The deleted VerificationToken record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        verificationtoken = await VerificationToken.prisma().delete(
            where={
                'token': 'bfhdbjjgfd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.VerificationTokenWhereUniqueInput,
        include: Optional[types.VerificationTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique VerificationToken record.

        Parameters
        ----------
        where
            VerificationToken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned VerificationToken model

        Returns
        -------
        prisma.models.VerificationToken
            The found VerificationToken record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        verificationtoken = await VerificationToken.prisma().find_unique(
            where={
                'token': 'cabdjadaji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.VerificationTokenWhereUniqueInput,
        include: Optional[types.VerificationTokenInclude] = None
    ) -> _PrismaModelT:
        """Find a unique VerificationToken record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            VerificationToken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned VerificationToken model

        Returns
        -------
        prisma.models.VerificationToken
            The found VerificationToken record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        verificationtoken = await VerificationToken.prisma().find_unique_or_raise(
            where={
                'token': 'faajgfadf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VerificationTokenWhereInput] = None,
        cursor: Optional[types.VerificationTokenWhereUniqueInput] = None,
        include: Optional[types.VerificationTokenInclude] = None,
        order: Optional[Union[types.VerificationTokenOrderByInput, List[types.VerificationTokenOrderByInput]]] = None,
        distinct: Optional[List[types.VerificationTokenScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple VerificationToken records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of VerificationToken records returned
        skip
            Ignore the first N results
        where
            VerificationToken filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned VerificationToken model
        order
            Order the returned VerificationToken records by any field
        distinct
            Filter VerificationToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.VerificationToken]
            The list of all VerificationToken records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 VerificationToken records
        verificationtokens = await VerificationToken.prisma().find_many(take=10)

        # find the first 5 VerificationToken records ordered by the expires field
        verificationtokens = await VerificationToken.prisma().find_many(
            take=5,
            order={
                'expires': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.VerificationTokenWhereInput] = None,
        cursor: Optional[types.VerificationTokenWhereUniqueInput] = None,
        include: Optional[types.VerificationTokenInclude] = None,
        order: Optional[Union[types.VerificationTokenOrderByInput, List[types.VerificationTokenOrderByInput]]] = None,
        distinct: Optional[List[types.VerificationTokenScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single VerificationToken record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            VerificationToken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned VerificationToken model
        order
            Order the returned VerificationToken records by any field
        distinct
            Filter VerificationToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.VerificationToken
            The first VerificationToken record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second VerificationToken record ordered by the identifier field
        verificationtoken = await VerificationToken.prisma().find_first(
            skip=1,
            order={
                'identifier': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.VerificationTokenWhereInput] = None,
        cursor: Optional[types.VerificationTokenWhereUniqueInput] = None,
        include: Optional[types.VerificationTokenInclude] = None,
        order: Optional[Union[types.VerificationTokenOrderByInput, List[types.VerificationTokenOrderByInput]]] = None,
        distinct: Optional[List[types.VerificationTokenScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single VerificationToken record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            VerificationToken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned VerificationToken model
        order
            Order the returned VerificationToken records by any field
        distinct
            Filter VerificationToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.VerificationToken
            The first VerificationToken record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second VerificationToken record ordered by the token field
        verificationtoken = await VerificationToken.prisma().find_first_or_raise(
            skip=1,
            order={
                'token': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.VerificationTokenUpdateInput,
        where: types.VerificationTokenWhereUniqueInput,
        include: Optional[types.VerificationTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single VerificationToken record.

        Parameters
        ----------
        data
            VerificationToken record data specifying what to update
        where
            VerificationToken filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned VerificationToken model

        Returns
        -------
        prisma.models.VerificationToken
            The updated VerificationToken record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        verificationtoken = await VerificationToken.prisma().update(
            where={
                'token': 'biaagcedjc',
            },
            data={
                # data to update the VerificationToken record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.VerificationTokenWhereUniqueInput,
        data: types.VerificationTokenUpsertInput,
        include: Optional[types.VerificationTokenInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            VerificationToken filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned VerificationToken model

        Returns
        -------
        prisma.models.VerificationToken
            The created or updated VerificationToken record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        verificationtoken = await VerificationToken.prisma().upsert(
            where={
                'token': 'cahhaghecf',
            },
            data={
                'create': {
                    'token': 'cahhaghecf',
                    'identifier': 'ifgaaagff',
                    'expires': datetime.datetime.utcnow(),
                },
                'update': {
                    'identifier': 'ifgaaagff',
                    'expires': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.VerificationTokenUpdateManyMutationInput,
        where: types.VerificationTokenWhereInput,
    ) -> int:
        """Update multiple VerificationToken records

        Parameters
        ----------
        data
            VerificationToken data to update the selected VerificationToken records to
        where
            Filter to select the VerificationToken records to update

        Returns
        -------
        int
            The total number of VerificationToken records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all VerificationToken records
        total = await VerificationToken.prisma().update_many(
            data={
                'expires': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VerificationTokenWhereInput] = None,
        cursor: Optional[types.VerificationTokenWhereUniqueInput] = None,
    ) -> int:
        """Count the number of VerificationToken records present in the database

        Parameters
        ----------
        select
            Select the VerificationToken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            VerificationToken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.VerificationTokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await VerificationToken.prisma().count()

        # results: prisma.types.VerificationTokenCountAggregateOutput
        results = await VerificationToken.prisma().count(
            select={
                '_all': True,
                'identifier': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.VerificationTokenCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VerificationTokenWhereInput] = None,
        cursor: Optional[types.VerificationTokenWhereUniqueInput] = None,
    ) -> types.VerificationTokenCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.VerificationTokenCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VerificationTokenWhereInput] = None,
        cursor: Optional[types.VerificationTokenWhereUniqueInput] = None,
    ) -> Union[int, types.VerificationTokenCountAggregateOutput]:
        """Count the number of VerificationToken records present in the database

        Parameters
        ----------
        select
            Select the VerificationToken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            VerificationToken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.VerificationTokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await VerificationToken.prisma().count()

        # results: prisma.types.VerificationTokenCountAggregateOutput
        results = await VerificationToken.prisma().count(
            select={
                '_all': True,
                'token': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.VerificationTokenCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.VerificationTokenWhereInput] = None
    ) -> int:
        """Delete multiple VerificationToken records.

        Parameters
        ----------
        where
            Optional VerificationToken filter to find the records to be deleted

        Returns
        -------
        int
            The total number of VerificationToken records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all VerificationToken records
        total = await VerificationToken.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.VerificationTokenScalarFieldKeys'],
        *,
        where: Optional['types.VerificationTokenWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.VerificationTokenAvgAggregateInput'] = None,
        sum: Optional['types.VerificationTokenSumAggregateInput'] = None,
        min: Optional['types.VerificationTokenMinAggregateInput'] = None,
        max: Optional['types.VerificationTokenMaxAggregateInput'] = None,
        having: Optional['types.VerificationTokenScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.VerificationTokenCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.VerificationTokenScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.VerificationTokenScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.VerificationTokenGroupByOutput']:
        """Group VerificationToken records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar VerificationToken fields to group records by
        where
            VerificationToken filter to select records
        take
            Limit the maximum number of VerificationToken records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.VerificationTokenGroupByOutput]
            A list of dictionaries representing the VerificationToken record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group VerificationToken records by expires values
        # and count how many records are in each group
        results = await VerificationToken.prisma().group_by(
            ['expires'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ChatMessageActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ChatMessage]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ChatMessage.prisma().query_raw(
            'SELECT * FROM ChatMessage WHERE id = $1',
            'bghcbbcidi',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ChatMessage
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ChatMessage.prisma().query_first(
            'SELECT * FROM ChatMessage WHERE userId = $1',
            'jcgghhgdj',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ChatMessageCreateInput,
        include: Optional[types.ChatMessageInclude] = None
    ) -> _PrismaModelT:
        """Create a new ChatMessage record.

        Parameters
        ----------
        data
            ChatMessage record data
        include
            Specifies which relations should be loaded on the returned ChatMessage model

        Returns
        -------
        prisma.models.ChatMessage
            The created ChatMessage record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ChatMessage record from just the required fields
        chatmessage = await ChatMessage.prisma().create(
            data={
                # data to create a ChatMessage record
                'userId': 'beehgcebbg',
                'tenantId': 'bhdiaidiaf',
                'message': 'deajegcfi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ChatMessageCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ChatMessage records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ChatMessage record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ChatMessage.prisma().create_many(
            data=[
                {
                    # data to create a ChatMessage record
                    'userId': 'gabahhhjf',
                    'tenantId': 'cjagadcjg',
                    'message': 'bifficggej',
                },
                {
                    # data to create a ChatMessage record
                    'userId': 'bgbbaajbic',
                    'tenantId': 'eegghdhjb',
                    'message': 'daafgidjg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ChatMessageWhereUniqueInput,
        include: Optional[types.ChatMessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ChatMessage record.

        Parameters
        ----------
        where
            ChatMessage filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ChatMessage model

        Returns
        -------
        prisma.models.ChatMessage
            The deleted ChatMessage record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chatmessage = await ChatMessage.prisma().delete(
            where={
                'id': 'gdcgcgagj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ChatMessageWhereUniqueInput,
        include: Optional[types.ChatMessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ChatMessage record.

        Parameters
        ----------
        where
            ChatMessage filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ChatMessage model

        Returns
        -------
        prisma.models.ChatMessage
            The found ChatMessage record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chatmessage = await ChatMessage.prisma().find_unique(
            where={
                'id': 'bhceabbgja',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ChatMessageWhereUniqueInput,
        include: Optional[types.ChatMessageInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ChatMessage record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ChatMessage filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ChatMessage model

        Returns
        -------
        prisma.models.ChatMessage
            The found ChatMessage record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chatmessage = await ChatMessage.prisma().find_unique_or_raise(
            where={
                'id': 'ehabfhegh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChatMessageWhereInput] = None,
        cursor: Optional[types.ChatMessageWhereUniqueInput] = None,
        include: Optional[types.ChatMessageInclude] = None,
        order: Optional[Union[types.ChatMessageOrderByInput, List[types.ChatMessageOrderByInput]]] = None,
        distinct: Optional[List[types.ChatMessageScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ChatMessage records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ChatMessage records returned
        skip
            Ignore the first N results
        where
            ChatMessage filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ChatMessage model
        order
            Order the returned ChatMessage records by any field
        distinct
            Filter ChatMessage records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ChatMessage]
            The list of all ChatMessage records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ChatMessage records
        chatmessages = await ChatMessage.prisma().find_many(take=10)

        # find the first 5 ChatMessage records ordered by the tenantId field
        chatmessages = await ChatMessage.prisma().find_many(
            take=5,
            order={
                'tenantId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ChatMessageWhereInput] = None,
        cursor: Optional[types.ChatMessageWhereUniqueInput] = None,
        include: Optional[types.ChatMessageInclude] = None,
        order: Optional[Union[types.ChatMessageOrderByInput, List[types.ChatMessageOrderByInput]]] = None,
        distinct: Optional[List[types.ChatMessageScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ChatMessage record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ChatMessage filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ChatMessage model
        order
            Order the returned ChatMessage records by any field
        distinct
            Filter ChatMessage records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ChatMessage
            The first ChatMessage record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ChatMessage record ordered by the message field
        chatmessage = await ChatMessage.prisma().find_first(
            skip=1,
            order={
                'message': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ChatMessageWhereInput] = None,
        cursor: Optional[types.ChatMessageWhereUniqueInput] = None,
        include: Optional[types.ChatMessageInclude] = None,
        order: Optional[Union[types.ChatMessageOrderByInput, List[types.ChatMessageOrderByInput]]] = None,
        distinct: Optional[List[types.ChatMessageScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ChatMessage record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ChatMessage filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ChatMessage model
        order
            Order the returned ChatMessage records by any field
        distinct
            Filter ChatMessage records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ChatMessage
            The first ChatMessage record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ChatMessage record ordered by the response field
        chatmessage = await ChatMessage.prisma().find_first_or_raise(
            skip=1,
            order={
                'response': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ChatMessageUpdateInput,
        where: types.ChatMessageWhereUniqueInput,
        include: Optional[types.ChatMessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ChatMessage record.

        Parameters
        ----------
        data
            ChatMessage record data specifying what to update
        where
            ChatMessage filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ChatMessage model

        Returns
        -------
        prisma.models.ChatMessage
            The updated ChatMessage record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        chatmessage = await ChatMessage.prisma().update(
            where={
                'id': 'bcajcajjbc',
            },
            data={
                # data to update the ChatMessage record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ChatMessageWhereUniqueInput,
        data: types.ChatMessageUpsertInput,
        include: Optional[types.ChatMessageInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ChatMessage filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ChatMessage model

        Returns
        -------
        prisma.models.ChatMessage
            The created or updated ChatMessage record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chatmessage = await ChatMessage.prisma().upsert(
            where={
                'id': 'bfdgheeegf',
            },
            data={
                'create': {
                    'id': 'bfdgheeegf',
                    'userId': 'bgbbaajbic',
                    'tenantId': 'eegghdhjb',
                    'message': 'daafgidjg',
                },
                'update': {
                    'userId': 'bgbbaajbic',
                    'tenantId': 'eegghdhjb',
                    'message': 'daafgidjg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ChatMessageUpdateManyMutationInput,
        where: types.ChatMessageWhereInput,
    ) -> int:
        """Update multiple ChatMessage records

        Parameters
        ----------
        data
            ChatMessage data to update the selected ChatMessage records to
        where
            Filter to select the ChatMessage records to update

        Returns
        -------
        int
            The total number of ChatMessage records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ChatMessage records
        total = await ChatMessage.prisma().update_many(
            data={
                'metadata': Json({'ececbijji': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChatMessageWhereInput] = None,
        cursor: Optional[types.ChatMessageWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ChatMessage records present in the database

        Parameters
        ----------
        select
            Select the ChatMessage fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ChatMessage filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ChatMessageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ChatMessage.prisma().count()

        # results: prisma.types.ChatMessageCountAggregateOutput
        results = await ChatMessage.prisma().count(
            select={
                '_all': True,
                'intent': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ChatMessageCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChatMessageWhereInput] = None,
        cursor: Optional[types.ChatMessageWhereUniqueInput] = None,
    ) -> types.ChatMessageCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ChatMessageCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChatMessageWhereInput] = None,
        cursor: Optional[types.ChatMessageWhereUniqueInput] = None,
    ) -> Union[int, types.ChatMessageCountAggregateOutput]:
        """Count the number of ChatMessage records present in the database

        Parameters
        ----------
        select
            Select the ChatMessage fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ChatMessage filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ChatMessageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ChatMessage.prisma().count()

        # results: prisma.types.ChatMessageCountAggregateOutput
        results = await ChatMessage.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ChatMessageCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ChatMessageWhereInput] = None
    ) -> int:
        """Delete multiple ChatMessage records.

        Parameters
        ----------
        where
            Optional ChatMessage filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ChatMessage records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ChatMessage records
        total = await ChatMessage.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ChatMessageScalarFieldKeys'],
        *,
        where: Optional['types.ChatMessageWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ChatMessageAvgAggregateInput'] = None,
        sum: Optional['types.ChatMessageSumAggregateInput'] = None,
        min: Optional['types.ChatMessageMinAggregateInput'] = None,
        max: Optional['types.ChatMessageMaxAggregateInput'] = None,
        having: Optional['types.ChatMessageScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ChatMessageCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ChatMessageScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ChatMessageScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ChatMessageGroupByOutput']:
        """Group ChatMessage records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ChatMessage fields to group records by
        where
            ChatMessage filter to select records
        take
            Limit the maximum number of ChatMessage records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ChatMessageGroupByOutput]
            A list of dictionaries representing the ChatMessage record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ChatMessage records by id values
        # and count how many records are in each group
        results = await ChatMessage.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserBusinessActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserBusiness]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserBusiness.prisma().query_raw(
            'SELECT * FROM UserBusiness WHERE businessId = $1',
            'cbcfgdcdhf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserBusiness
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserBusiness.prisma().query_first(
            'SELECT * FROM UserBusiness WHERE userId = $1',
            'fdgjfbhia',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserBusinessCreateInput,
        include: Optional[types.UserBusinessInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserBusiness record.

        Parameters
        ----------
        data
            UserBusiness record data
        include
            Specifies which relations should be loaded on the returned UserBusiness model

        Returns
        -------
        prisma.models.UserBusiness
            The created UserBusiness record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserBusiness record from just the required fields
        userbusiness = await UserBusiness.prisma().create(
            data={
                # data to create a UserBusiness record
                'userId': 'jcehcdchh',
                'businessName': 'bgcbjdhjcc',
                'businessCategory': 'bieiidcabj',
                'businessLicense': 'bjcbfcieaa',
                'taxId': 'cbaaechiej',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserBusinessCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserBusiness records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserBusiness record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserBusiness.prisma().create_many(
            data=[
                {
                    # data to create a UserBusiness record
                    'userId': 'iejbeaaeg',
                    'businessName': 'jcibfcbhf',
                    'businessCategory': 'chdadcaga',
                    'businessLicense': 'jicieifbh',
                    'taxId': 'fbahdheji',
                },
                {
                    # data to create a UserBusiness record
                    'userId': 'cbbheiicgh',
                    'businessName': 'beabjeejdg',
                    'businessCategory': 'bcjhgahffd',
                    'businessLicense': 'fbjeiiffa',
                    'taxId': 'jhgidcgbf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserBusinessWhereUniqueInput,
        include: Optional[types.UserBusinessInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserBusiness record.

        Parameters
        ----------
        where
            UserBusiness filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserBusiness model

        Returns
        -------
        prisma.models.UserBusiness
            The deleted UserBusiness record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userbusiness = await UserBusiness.prisma().delete(
            where={
                'businessId': 'bgjgecfejc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserBusinessWhereUniqueInput,
        include: Optional[types.UserBusinessInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserBusiness record.

        Parameters
        ----------
        where
            UserBusiness filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserBusiness model

        Returns
        -------
        prisma.models.UserBusiness
            The found UserBusiness record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userbusiness = await UserBusiness.prisma().find_unique(
            where={
                'businessId': 'bgjcgchib',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserBusinessWhereUniqueInput,
        include: Optional[types.UserBusinessInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserBusiness record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserBusiness filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserBusiness model

        Returns
        -------
        prisma.models.UserBusiness
            The found UserBusiness record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userbusiness = await UserBusiness.prisma().find_unique_or_raise(
            where={
                'businessId': 'bacdaibgfa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserBusinessWhereInput] = None,
        cursor: Optional[types.UserBusinessWhereUniqueInput] = None,
        include: Optional[types.UserBusinessInclude] = None,
        order: Optional[Union[types.UserBusinessOrderByInput, List[types.UserBusinessOrderByInput]]] = None,
        distinct: Optional[List[types.UserBusinessScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserBusiness records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserBusiness records returned
        skip
            Ignore the first N results
        where
            UserBusiness filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserBusiness model
        order
            Order the returned UserBusiness records by any field
        distinct
            Filter UserBusiness records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserBusiness]
            The list of all UserBusiness records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserBusiness records
        userbusiness = await UserBusiness.prisma().find_many(take=10)

        # find the first 5 UserBusiness records ordered by the businessName field
        userbusiness = await UserBusiness.prisma().find_many(
            take=5,
            order={
                'businessName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserBusinessWhereInput] = None,
        cursor: Optional[types.UserBusinessWhereUniqueInput] = None,
        include: Optional[types.UserBusinessInclude] = None,
        order: Optional[Union[types.UserBusinessOrderByInput, List[types.UserBusinessOrderByInput]]] = None,
        distinct: Optional[List[types.UserBusinessScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserBusiness record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserBusiness filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserBusiness model
        order
            Order the returned UserBusiness records by any field
        distinct
            Filter UserBusiness records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserBusiness
            The first UserBusiness record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserBusiness record ordered by the businessCategory field
        userbusiness = await UserBusiness.prisma().find_first(
            skip=1,
            order={
                'businessCategory': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserBusinessWhereInput] = None,
        cursor: Optional[types.UserBusinessWhereUniqueInput] = None,
        include: Optional[types.UserBusinessInclude] = None,
        order: Optional[Union[types.UserBusinessOrderByInput, List[types.UserBusinessOrderByInput]]] = None,
        distinct: Optional[List[types.UserBusinessScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserBusiness record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserBusiness filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserBusiness model
        order
            Order the returned UserBusiness records by any field
        distinct
            Filter UserBusiness records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserBusiness
            The first UserBusiness record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserBusiness record ordered by the businessLicense field
        userbusiness = await UserBusiness.prisma().find_first_or_raise(
            skip=1,
            order={
                'businessLicense': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserBusinessUpdateInput,
        where: types.UserBusinessWhereUniqueInput,
        include: Optional[types.UserBusinessInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserBusiness record.

        Parameters
        ----------
        data
            UserBusiness record data specifying what to update
        where
            UserBusiness filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserBusiness model

        Returns
        -------
        prisma.models.UserBusiness
            The updated UserBusiness record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        userbusiness = await UserBusiness.prisma().update(
            where={
                'businessId': 'dchgibach',
            },
            data={
                # data to update the UserBusiness record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserBusinessWhereUniqueInput,
        data: types.UserBusinessUpsertInput,
        include: Optional[types.UserBusinessInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserBusiness filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserBusiness model

        Returns
        -------
        prisma.models.UserBusiness
            The created or updated UserBusiness record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userbusiness = await UserBusiness.prisma().upsert(
            where={
                'businessId': 'fchheijjc',
            },
            data={
                'create': {
                    'businessId': 'fchheijjc',
                    'userId': 'cbbheiicgh',
                    'businessName': 'beabjeejdg',
                    'businessCategory': 'bcjhgahffd',
                    'businessLicense': 'fbjeiiffa',
                    'taxId': 'jhgidcgbf',
                },
                'update': {
                    'userId': 'cbbheiicgh',
                    'businessName': 'beabjeejdg',
                    'businessCategory': 'bcjhgahffd',
                    'businessLicense': 'fbjeiiffa',
                    'taxId': 'jhgidcgbf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserBusinessUpdateManyMutationInput,
        where: types.UserBusinessWhereInput,
    ) -> int:
        """Update multiple UserBusiness records

        Parameters
        ----------
        data
            UserBusiness data to update the selected UserBusiness records to
        where
            Filter to select the UserBusiness records to update

        Returns
        -------
        int
            The total number of UserBusiness records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserBusiness records
        total = await UserBusiness.prisma().update_many(
            data={
                'taxId': 'cacjdfhejh'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserBusinessWhereInput] = None,
        cursor: Optional[types.UserBusinessWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserBusiness records present in the database

        Parameters
        ----------
        select
            Select the UserBusiness fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserBusiness filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserBusinessCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserBusiness.prisma().count()

        # results: prisma.types.UserBusinessCountAggregateOutput
        results = await UserBusiness.prisma().count(
            select={
                '_all': True,
                'businessWebsite': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserBusinessCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserBusinessWhereInput] = None,
        cursor: Optional[types.UserBusinessWhereUniqueInput] = None,
    ) -> types.UserBusinessCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserBusinessCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserBusinessWhereInput] = None,
        cursor: Optional[types.UserBusinessWhereUniqueInput] = None,
    ) -> Union[int, types.UserBusinessCountAggregateOutput]:
        """Count the number of UserBusiness records present in the database

        Parameters
        ----------
        select
            Select the UserBusiness fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserBusiness filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserBusinessCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserBusiness.prisma().count()

        # results: prisma.types.UserBusinessCountAggregateOutput
        results = await UserBusiness.prisma().count(
            select={
                '_all': True,
                'businessId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserBusinessCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserBusinessWhereInput] = None
    ) -> int:
        """Delete multiple UserBusiness records.

        Parameters
        ----------
        where
            Optional UserBusiness filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserBusiness records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserBusiness records
        total = await UserBusiness.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserBusinessScalarFieldKeys'],
        *,
        where: Optional['types.UserBusinessWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserBusinessAvgAggregateInput'] = None,
        sum: Optional['types.UserBusinessSumAggregateInput'] = None,
        min: Optional['types.UserBusinessMinAggregateInput'] = None,
        max: Optional['types.UserBusinessMaxAggregateInput'] = None,
        having: Optional['types.UserBusinessScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserBusinessCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserBusinessScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserBusinessScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserBusinessGroupByOutput']:
        """Group UserBusiness records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserBusiness fields to group records by
        where
            UserBusiness filter to select records
        take
            Limit the maximum number of UserBusiness records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserBusinessGroupByOutput]
            A list of dictionaries representing the UserBusiness record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserBusiness records by userId values
        # and count how many records are in each group
        results = await UserBusiness.prisma().group_by(
            ['userId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserLocationsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserLocations]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserLocations.prisma().query_raw(
            'SELECT * FROM UserLocations WHERE locationId = $1',
            'bdbifjhbbi',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserLocations
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserLocations.prisma().query_first(
            'SELECT * FROM UserLocations WHERE userId = $1',
            'cbccbbcdfb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserLocationsCreateInput,
        include: Optional[types.UserLocationsInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserLocations record.

        Parameters
        ----------
        data
            UserLocations record data
        include
            Specifies which relations should be loaded on the returned UserLocations model

        Returns
        -------
        prisma.models.UserLocations
            The created UserLocations record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserLocations record from just the required fields
        userlocations = await UserLocations.prisma().create(
            data={
                # data to create a UserLocations record
                'userId': 'bacejedaca',
                'latitude': 1717307509.159812,
                'longitude': 817623163.103055,
                'addressDetail': 'bbdbfcfihd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserLocationsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserLocations records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserLocations record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserLocations.prisma().create_many(
            data=[
                {
                    # data to create a UserLocations record
                    'userId': 'cbagggbji',
                    'latitude': 1276057943.74556,
                    'longitude': 307876141.167404,
                    'addressDetail': 'bfcgifeged',
                },
                {
                    # data to create a UserLocations record
                    'userId': 'jfiahhbae',
                    'latitude': 1513050921.20467,
                    'longitude': 2067651663.118391,
                    'addressDetail': 'bfijhaejdd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserLocationsWhereUniqueInput,
        include: Optional[types.UserLocationsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserLocations record.

        Parameters
        ----------
        where
            UserLocations filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserLocations model

        Returns
        -------
        prisma.models.UserLocations
            The deleted UserLocations record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userlocations = await UserLocations.prisma().delete(
            where={
                'locationId': 'bcedehfiji',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserLocationsWhereUniqueInput,
        include: Optional[types.UserLocationsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserLocations record.

        Parameters
        ----------
        where
            UserLocations filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserLocations model

        Returns
        -------
        prisma.models.UserLocations
            The found UserLocations record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userlocations = await UserLocations.prisma().find_unique(
            where={
                'locationId': 'bdgjicijhb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserLocationsWhereUniqueInput,
        include: Optional[types.UserLocationsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserLocations record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserLocations filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserLocations model

        Returns
        -------
        prisma.models.UserLocations
            The found UserLocations record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userlocations = await UserLocations.prisma().find_unique_or_raise(
            where={
                'locationId': 'bghifjdeia',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserLocationsWhereInput] = None,
        cursor: Optional[types.UserLocationsWhereUniqueInput] = None,
        include: Optional[types.UserLocationsInclude] = None,
        order: Optional[Union[types.UserLocationsOrderByInput, List[types.UserLocationsOrderByInput]]] = None,
        distinct: Optional[List[types.UserLocationsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserLocations records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserLocations records returned
        skip
            Ignore the first N results
        where
            UserLocations filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserLocations model
        order
            Order the returned UserLocations records by any field
        distinct
            Filter UserLocations records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserLocations]
            The list of all UserLocations records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserLocations records
        userlocations = await UserLocations.prisma().find_many(take=10)

        # find the first 5 UserLocations records ordered by the latitude field
        userlocations = await UserLocations.prisma().find_many(
            take=5,
            order={
                'latitude': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserLocationsWhereInput] = None,
        cursor: Optional[types.UserLocationsWhereUniqueInput] = None,
        include: Optional[types.UserLocationsInclude] = None,
        order: Optional[Union[types.UserLocationsOrderByInput, List[types.UserLocationsOrderByInput]]] = None,
        distinct: Optional[List[types.UserLocationsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserLocations record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserLocations filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserLocations model
        order
            Order the returned UserLocations records by any field
        distinct
            Filter UserLocations records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserLocations
            The first UserLocations record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserLocations record ordered by the longitude field
        userlocations = await UserLocations.prisma().find_first(
            skip=1,
            order={
                'longitude': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserLocationsWhereInput] = None,
        cursor: Optional[types.UserLocationsWhereUniqueInput] = None,
        include: Optional[types.UserLocationsInclude] = None,
        order: Optional[Union[types.UserLocationsOrderByInput, List[types.UserLocationsOrderByInput]]] = None,
        distinct: Optional[List[types.UserLocationsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserLocations record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserLocations filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserLocations model
        order
            Order the returned UserLocations records by any field
        distinct
            Filter UserLocations records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserLocations
            The first UserLocations record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserLocations record ordered by the addressDetail field
        userlocations = await UserLocations.prisma().find_first_or_raise(
            skip=1,
            order={
                'addressDetail': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserLocationsUpdateInput,
        where: types.UserLocationsWhereUniqueInput,
        include: Optional[types.UserLocationsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserLocations record.

        Parameters
        ----------
        data
            UserLocations record data specifying what to update
        where
            UserLocations filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserLocations model

        Returns
        -------
        prisma.models.UserLocations
            The updated UserLocations record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        userlocations = await UserLocations.prisma().update(
            where={
                'locationId': 'eadfcbbcb',
            },
            data={
                # data to update the UserLocations record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserLocationsWhereUniqueInput,
        data: types.UserLocationsUpsertInput,
        include: Optional[types.UserLocationsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserLocations filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserLocations model

        Returns
        -------
        prisma.models.UserLocations
            The created or updated UserLocations record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userlocations = await UserLocations.prisma().upsert(
            where={
                'locationId': 'geihgahba',
            },
            data={
                'create': {
                    'locationId': 'geihgahba',
                    'userId': 'jfiahhbae',
                    'latitude': 1513050921.20467,
                    'longitude': 2067651663.118391,
                    'addressDetail': 'bfijhaejdd',
                },
                'update': {
                    'userId': 'jfiahhbae',
                    'latitude': 1513050921.20467,
                    'longitude': 2067651663.118391,
                    'addressDetail': 'bfijhaejdd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserLocationsUpdateManyMutationInput,
        where: types.UserLocationsWhereInput,
    ) -> int:
        """Update multiple UserLocations records

        Parameters
        ----------
        data
            UserLocations data to update the selected UserLocations records to
        where
            Filter to select the UserLocations records to update

        Returns
        -------
        int
            The total number of UserLocations records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserLocations records
        total = await UserLocations.prisma().update_many(
            data={
                'isPrimary': False
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserLocationsWhereInput] = None,
        cursor: Optional[types.UserLocationsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserLocations records present in the database

        Parameters
        ----------
        select
            Select the UserLocations fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserLocations filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserLocationsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserLocations.prisma().count()

        # results: prisma.types.UserLocationsCountAggregateOutput
        results = await UserLocations.prisma().count(
            select={
                '_all': True,
                'locationId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserLocationsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserLocationsWhereInput] = None,
        cursor: Optional[types.UserLocationsWhereUniqueInput] = None,
    ) -> types.UserLocationsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserLocationsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserLocationsWhereInput] = None,
        cursor: Optional[types.UserLocationsWhereUniqueInput] = None,
    ) -> Union[int, types.UserLocationsCountAggregateOutput]:
        """Count the number of UserLocations records present in the database

        Parameters
        ----------
        select
            Select the UserLocations fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserLocations filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserLocationsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserLocations.prisma().count()

        # results: prisma.types.UserLocationsCountAggregateOutput
        results = await UserLocations.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserLocationsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserLocationsWhereInput] = None
    ) -> int:
        """Delete multiple UserLocations records.

        Parameters
        ----------
        where
            Optional UserLocations filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserLocations records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserLocations records
        total = await UserLocations.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserLocationsScalarFieldKeys'],
        *,
        where: Optional['types.UserLocationsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserLocationsAvgAggregateInput'] = None,
        sum: Optional['types.UserLocationsSumAggregateInput'] = None,
        min: Optional['types.UserLocationsMinAggregateInput'] = None,
        max: Optional['types.UserLocationsMaxAggregateInput'] = None,
        having: Optional['types.UserLocationsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserLocationsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserLocationsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserLocationsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserLocationsGroupByOutput']:
        """Group UserLocations records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserLocations fields to group records by
        where
            UserLocations filter to select records
        take
            Limit the maximum number of UserLocations records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserLocationsGroupByOutput]
            A list of dictionaries representing the UserLocations record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserLocations records by latitude values
        # and count how many records are in each group
        results = await UserLocations.prisma().group_by(
            ['latitude'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserFinanceActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserFinance]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserFinance.prisma().query_raw(
            'SELECT * FROM UserFinance WHERE financeId = $1',
            'begiijahea',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserFinance
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserFinance.prisma().query_first(
            'SELECT * FROM UserFinance WHERE userId = $1',
            'gcjadjaaf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserFinanceCreateInput,
        include: Optional[types.UserFinanceInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserFinance record.

        Parameters
        ----------
        data
            UserFinance record data
        include
            Specifies which relations should be loaded on the returned UserFinance model

        Returns
        -------
        prisma.models.UserFinance
            The created UserFinance record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserFinance record from just the required fields
        userfinance = await UserFinance.prisma().create(
            data={
                # data to create a UserFinance record
                'userId': 'bcbebgiaic',
                'currency': 'ijigbdcbj',
                'paymentMethods': Json({'gfidhicai': True}),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserFinanceCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserFinance records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserFinance record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserFinance.prisma().create_many(
            data=[
                {
                    # data to create a UserFinance record
                    'userId': 'jfegcaafh',
                    'currency': 'bcbeiajjfa',
                    'paymentMethods': Json({'baehicaajf': True}),
                },
                {
                    # data to create a UserFinance record
                    'userId': 'bdachdeiga',
                    'currency': 'ijdafccef',
                    'paymentMethods': Json({'ciaaiddag': True}),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserFinanceWhereUniqueInput,
        include: Optional[types.UserFinanceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserFinance record.

        Parameters
        ----------
        where
            UserFinance filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserFinance model

        Returns
        -------
        prisma.models.UserFinance
            The deleted UserFinance record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userfinance = await UserFinance.prisma().delete(
            where={
                'financeId': 'fejggijff',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserFinanceWhereUniqueInput,
        include: Optional[types.UserFinanceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserFinance record.

        Parameters
        ----------
        where
            UserFinance filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserFinance model

        Returns
        -------
        prisma.models.UserFinance
            The found UserFinance record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userfinance = await UserFinance.prisma().find_unique(
            where={
                'financeId': 'hghjaaai',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserFinanceWhereUniqueInput,
        include: Optional[types.UserFinanceInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserFinance record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserFinance filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserFinance model

        Returns
        -------
        prisma.models.UserFinance
            The found UserFinance record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userfinance = await UserFinance.prisma().find_unique_or_raise(
            where={
                'financeId': 'cajicjjdef',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserFinanceWhereInput] = None,
        cursor: Optional[types.UserFinanceWhereUniqueInput] = None,
        include: Optional[types.UserFinanceInclude] = None,
        order: Optional[Union[types.UserFinanceOrderByInput, List[types.UserFinanceOrderByInput]]] = None,
        distinct: Optional[List[types.UserFinanceScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserFinance records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserFinance records returned
        skip
            Ignore the first N results
        where
            UserFinance filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserFinance model
        order
            Order the returned UserFinance records by any field
        distinct
            Filter UserFinance records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserFinance]
            The list of all UserFinance records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserFinance records
        userfinances = await UserFinance.prisma().find_many(take=10)

        # find the first 5 UserFinance records ordered by the balance field
        userfinances = await UserFinance.prisma().find_many(
            take=5,
            order={
                'balance': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserFinanceWhereInput] = None,
        cursor: Optional[types.UserFinanceWhereUniqueInput] = None,
        include: Optional[types.UserFinanceInclude] = None,
        order: Optional[Union[types.UserFinanceOrderByInput, List[types.UserFinanceOrderByInput]]] = None,
        distinct: Optional[List[types.UserFinanceScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserFinance record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserFinance filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserFinance model
        order
            Order the returned UserFinance records by any field
        distinct
            Filter UserFinance records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserFinance
            The first UserFinance record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserFinance record ordered by the currency field
        userfinance = await UserFinance.prisma().find_first(
            skip=1,
            order={
                'currency': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserFinanceWhereInput] = None,
        cursor: Optional[types.UserFinanceWhereUniqueInput] = None,
        include: Optional[types.UserFinanceInclude] = None,
        order: Optional[Union[types.UserFinanceOrderByInput, List[types.UserFinanceOrderByInput]]] = None,
        distinct: Optional[List[types.UserFinanceScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserFinance record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserFinance filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserFinance model
        order
            Order the returned UserFinance records by any field
        distinct
            Filter UserFinance records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserFinance
            The first UserFinance record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserFinance record ordered by the paymentMethods field
        userfinance = await UserFinance.prisma().find_first_or_raise(
            skip=1,
            order={
                'paymentMethods': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserFinanceUpdateInput,
        where: types.UserFinanceWhereUniqueInput,
        include: Optional[types.UserFinanceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserFinance record.

        Parameters
        ----------
        data
            UserFinance record data specifying what to update
        where
            UserFinance filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserFinance model

        Returns
        -------
        prisma.models.UserFinance
            The updated UserFinance record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        userfinance = await UserFinance.prisma().update(
            where={
                'financeId': 'cefjaadec',
            },
            data={
                # data to update the UserFinance record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserFinanceWhereUniqueInput,
        data: types.UserFinanceUpsertInput,
        include: Optional[types.UserFinanceInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserFinance filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserFinance model

        Returns
        -------
        prisma.models.UserFinance
            The created or updated UserFinance record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userfinance = await UserFinance.prisma().upsert(
            where={
                'financeId': 'ibbigdigd',
            },
            data={
                'create': {
                    'financeId': 'ibbigdigd',
                    'userId': 'bdachdeiga',
                    'currency': 'ijdafccef',
                    'paymentMethods': Json({'ciaaiddag': True}),
                },
                'update': {
                    'userId': 'bdachdeiga',
                    'currency': 'ijdafccef',
                    'paymentMethods': Json({'ciaaiddag': True}),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserFinanceUpdateManyMutationInput,
        where: types.UserFinanceWhereInput,
    ) -> int:
        """Update multiple UserFinance records

        Parameters
        ----------
        data
            UserFinance data to update the selected UserFinance records to
        where
            Filter to select the UserFinance records to update

        Returns
        -------
        int
            The total number of UserFinance records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserFinance records
        total = await UserFinance.prisma().update_many(
            data={
                'loyaltyPoints': 1388801188
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserFinanceWhereInput] = None,
        cursor: Optional[types.UserFinanceWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserFinance records present in the database

        Parameters
        ----------
        select
            Select the UserFinance fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserFinance filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserFinanceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserFinance.prisma().count()

        # results: prisma.types.UserFinanceCountAggregateOutput
        results = await UserFinance.prisma().count(
            select={
                '_all': True,
                'financeId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserFinanceCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserFinanceWhereInput] = None,
        cursor: Optional[types.UserFinanceWhereUniqueInput] = None,
    ) -> types.UserFinanceCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserFinanceCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserFinanceWhereInput] = None,
        cursor: Optional[types.UserFinanceWhereUniqueInput] = None,
    ) -> Union[int, types.UserFinanceCountAggregateOutput]:
        """Count the number of UserFinance records present in the database

        Parameters
        ----------
        select
            Select the UserFinance fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserFinance filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserFinanceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserFinance.prisma().count()

        # results: prisma.types.UserFinanceCountAggregateOutput
        results = await UserFinance.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserFinanceCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserFinanceWhereInput] = None
    ) -> int:
        """Delete multiple UserFinance records.

        Parameters
        ----------
        where
            Optional UserFinance filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserFinance records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserFinance records
        total = await UserFinance.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserFinanceScalarFieldKeys'],
        *,
        where: Optional['types.UserFinanceWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserFinanceAvgAggregateInput'] = None,
        sum: Optional['types.UserFinanceSumAggregateInput'] = None,
        min: Optional['types.UserFinanceMinAggregateInput'] = None,
        max: Optional['types.UserFinanceMaxAggregateInput'] = None,
        having: Optional['types.UserFinanceScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserFinanceCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserFinanceScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserFinanceScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserFinanceGroupByOutput']:
        """Group UserFinance records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserFinance fields to group records by
        where
            UserFinance filter to select records
        take
            Limit the maximum number of UserFinance records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserFinanceGroupByOutput]
            A list of dictionaries representing the UserFinance record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserFinance records by balance values
        # and count how many records are in each group
        results = await UserFinance.prisma().group_by(
            ['balance'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserSubscriptionsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserSubscriptions]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserSubscriptions.prisma().query_raw(
            'SELECT * FROM UserSubscriptions WHERE subscriptionId = $1',
            'hfcfhhadh',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserSubscriptions
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserSubscriptions.prisma().query_first(
            'SELECT * FROM UserSubscriptions WHERE userId = $1',
            'bbihggdcji',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserSubscriptionsCreateInput,
        include: Optional[types.UserSubscriptionsInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserSubscriptions record.

        Parameters
        ----------
        data
            UserSubscriptions record data
        include
            Specifies which relations should be loaded on the returned UserSubscriptions model

        Returns
        -------
        prisma.models.UserSubscriptions
            The created UserSubscriptions record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserSubscriptions record from just the required fields
        usersubscriptions = await UserSubscriptions.prisma().create(
            data={
                # data to create a UserSubscriptions record
                'userId': 'hgjgibdgd',
                'planId': 'bcbecjfice',
                'tokenLimit': 1021417993,
                'tokenResetAt': datetime.datetime.utcnow(),
                'subscriptionStart': datetime.datetime.utcnow(),
                'subscriptionEnd': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserSubscriptionsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserSubscriptions records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserSubscriptions record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserSubscriptions.prisma().create_many(
            data=[
                {
                    # data to create a UserSubscriptions record
                    'userId': 'dfbfaddhe',
                    'planId': 'bdcbbieibf',
                    'tokenLimit': 369732668,
                    'tokenResetAt': datetime.datetime.utcnow(),
                    'subscriptionStart': datetime.datetime.utcnow(),
                    'subscriptionEnd': datetime.datetime.utcnow(),
                },
                {
                    # data to create a UserSubscriptions record
                    'userId': 'bbjbcdfabd',
                    'planId': 'gchfgbcec',
                    'tokenLimit': 1872952907,
                    'tokenResetAt': datetime.datetime.utcnow(),
                    'subscriptionStart': datetime.datetime.utcnow(),
                    'subscriptionEnd': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserSubscriptionsWhereUniqueInput,
        include: Optional[types.UserSubscriptionsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserSubscriptions record.

        Parameters
        ----------
        where
            UserSubscriptions filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserSubscriptions model

        Returns
        -------
        prisma.models.UserSubscriptions
            The deleted UserSubscriptions record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usersubscriptions = await UserSubscriptions.prisma().delete(
            where={
                'subscriptionId': 'bhjdcicaii',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserSubscriptionsWhereUniqueInput,
        include: Optional[types.UserSubscriptionsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserSubscriptions record.

        Parameters
        ----------
        where
            UserSubscriptions filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserSubscriptions model

        Returns
        -------
        prisma.models.UserSubscriptions
            The found UserSubscriptions record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usersubscriptions = await UserSubscriptions.prisma().find_unique(
            where={
                'subscriptionId': 'bibedjhcej',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserSubscriptionsWhereUniqueInput,
        include: Optional[types.UserSubscriptionsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserSubscriptions record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserSubscriptions filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserSubscriptions model

        Returns
        -------
        prisma.models.UserSubscriptions
            The found UserSubscriptions record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usersubscriptions = await UserSubscriptions.prisma().find_unique_or_raise(
            where={
                'subscriptionId': 'bjcdajabfa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserSubscriptionsWhereInput] = None,
        cursor: Optional[types.UserSubscriptionsWhereUniqueInput] = None,
        include: Optional[types.UserSubscriptionsInclude] = None,
        order: Optional[Union[types.UserSubscriptionsOrderByInput, List[types.UserSubscriptionsOrderByInput]]] = None,
        distinct: Optional[List[types.UserSubscriptionsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserSubscriptions records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserSubscriptions records returned
        skip
            Ignore the first N results
        where
            UserSubscriptions filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserSubscriptions model
        order
            Order the returned UserSubscriptions records by any field
        distinct
            Filter UserSubscriptions records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserSubscriptions]
            The list of all UserSubscriptions records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserSubscriptions records
        usersubscriptions = await UserSubscriptions.prisma().find_many(take=10)

        # find the first 5 UserSubscriptions records ordered by the planId field
        usersubscriptions = await UserSubscriptions.prisma().find_many(
            take=5,
            order={
                'planId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserSubscriptionsWhereInput] = None,
        cursor: Optional[types.UserSubscriptionsWhereUniqueInput] = None,
        include: Optional[types.UserSubscriptionsInclude] = None,
        order: Optional[Union[types.UserSubscriptionsOrderByInput, List[types.UserSubscriptionsOrderByInput]]] = None,
        distinct: Optional[List[types.UserSubscriptionsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserSubscriptions record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserSubscriptions filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserSubscriptions model
        order
            Order the returned UserSubscriptions records by any field
        distinct
            Filter UserSubscriptions records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserSubscriptions
            The first UserSubscriptions record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserSubscriptions record ordered by the tokenUsage field
        usersubscriptions = await UserSubscriptions.prisma().find_first(
            skip=1,
            order={
                'tokenUsage': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserSubscriptionsWhereInput] = None,
        cursor: Optional[types.UserSubscriptionsWhereUniqueInput] = None,
        include: Optional[types.UserSubscriptionsInclude] = None,
        order: Optional[Union[types.UserSubscriptionsOrderByInput, List[types.UserSubscriptionsOrderByInput]]] = None,
        distinct: Optional[List[types.UserSubscriptionsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserSubscriptions record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserSubscriptions filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserSubscriptions model
        order
            Order the returned UserSubscriptions records by any field
        distinct
            Filter UserSubscriptions records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserSubscriptions
            The first UserSubscriptions record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserSubscriptions record ordered by the tokenLimit field
        usersubscriptions = await UserSubscriptions.prisma().find_first_or_raise(
            skip=1,
            order={
                'tokenLimit': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserSubscriptionsUpdateInput,
        where: types.UserSubscriptionsWhereUniqueInput,
        include: Optional[types.UserSubscriptionsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserSubscriptions record.

        Parameters
        ----------
        data
            UserSubscriptions record data specifying what to update
        where
            UserSubscriptions filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserSubscriptions model

        Returns
        -------
        prisma.models.UserSubscriptions
            The updated UserSubscriptions record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        usersubscriptions = await UserSubscriptions.prisma().update(
            where={
                'subscriptionId': 'bchhceeeff',
            },
            data={
                # data to update the UserSubscriptions record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserSubscriptionsWhereUniqueInput,
        data: types.UserSubscriptionsUpsertInput,
        include: Optional[types.UserSubscriptionsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserSubscriptions filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserSubscriptions model

        Returns
        -------
        prisma.models.UserSubscriptions
            The created or updated UserSubscriptions record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usersubscriptions = await UserSubscriptions.prisma().upsert(
            where={
                'subscriptionId': 'bbgaifhdaa',
            },
            data={
                'create': {
                    'subscriptionId': 'bbgaifhdaa',
                    'userId': 'bbjbcdfabd',
                    'planId': 'gchfgbcec',
                    'tokenLimit': 1872952907,
                    'tokenResetAt': datetime.datetime.utcnow(),
                    'subscriptionStart': datetime.datetime.utcnow(),
                    'subscriptionEnd': datetime.datetime.utcnow(),
                },
                'update': {
                    'userId': 'bbjbcdfabd',
                    'planId': 'gchfgbcec',
                    'tokenLimit': 1872952907,
                    'tokenResetAt': datetime.datetime.utcnow(),
                    'subscriptionStart': datetime.datetime.utcnow(),
                    'subscriptionEnd': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserSubscriptionsUpdateManyMutationInput,
        where: types.UserSubscriptionsWhereInput,
    ) -> int:
        """Update multiple UserSubscriptions records

        Parameters
        ----------
        data
            UserSubscriptions data to update the selected UserSubscriptions records to
        where
            Filter to select the UserSubscriptions records to update

        Returns
        -------
        int
            The total number of UserSubscriptions records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserSubscriptions records
        total = await UserSubscriptions.prisma().update_many(
            data={
                'tokenResetAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserSubscriptionsWhereInput] = None,
        cursor: Optional[types.UserSubscriptionsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserSubscriptions records present in the database

        Parameters
        ----------
        select
            Select the UserSubscriptions fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserSubscriptions filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserSubscriptionsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserSubscriptions.prisma().count()

        # results: prisma.types.UserSubscriptionsCountAggregateOutput
        results = await UserSubscriptions.prisma().count(
            select={
                '_all': True,
                'subscriptionStart': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserSubscriptionsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserSubscriptionsWhereInput] = None,
        cursor: Optional[types.UserSubscriptionsWhereUniqueInput] = None,
    ) -> types.UserSubscriptionsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserSubscriptionsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserSubscriptionsWhereInput] = None,
        cursor: Optional[types.UserSubscriptionsWhereUniqueInput] = None,
    ) -> Union[int, types.UserSubscriptionsCountAggregateOutput]:
        """Count the number of UserSubscriptions records present in the database

        Parameters
        ----------
        select
            Select the UserSubscriptions fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserSubscriptions filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserSubscriptionsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserSubscriptions.prisma().count()

        # results: prisma.types.UserSubscriptionsCountAggregateOutput
        results = await UserSubscriptions.prisma().count(
            select={
                '_all': True,
                'subscriptionEnd': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserSubscriptionsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserSubscriptionsWhereInput] = None
    ) -> int:
        """Delete multiple UserSubscriptions records.

        Parameters
        ----------
        where
            Optional UserSubscriptions filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserSubscriptions records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserSubscriptions records
        total = await UserSubscriptions.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserSubscriptionsScalarFieldKeys'],
        *,
        where: Optional['types.UserSubscriptionsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserSubscriptionsAvgAggregateInput'] = None,
        sum: Optional['types.UserSubscriptionsSumAggregateInput'] = None,
        min: Optional['types.UserSubscriptionsMinAggregateInput'] = None,
        max: Optional['types.UserSubscriptionsMaxAggregateInput'] = None,
        having: Optional['types.UserSubscriptionsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserSubscriptionsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserSubscriptionsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserSubscriptionsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserSubscriptionsGroupByOutput']:
        """Group UserSubscriptions records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserSubscriptions fields to group records by
        where
            UserSubscriptions filter to select records
        take
            Limit the maximum number of UserSubscriptions records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserSubscriptionsGroupByOutput]
            A list of dictionaries representing the UserSubscriptions record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserSubscriptions records by subscriptionId values
        # and count how many records are in each group
        results = await UserSubscriptions.prisma().group_by(
            ['subscriptionId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PlansActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Plans]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Plans.prisma().query_raw(
            'SELECT * FROM Plans WHERE planId = $1',
            'dgbcdaegb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Plans
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Plans.prisma().query_first(
            'SELECT * FROM Plans WHERE planName = $1',
            'beagfbbjig',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PlansCreateInput,
        include: Optional[types.PlansInclude] = None
    ) -> _PrismaModelT:
        """Create a new Plans record.

        Parameters
        ----------
        data
            Plans record data
        include
            Specifies which relations should be loaded on the returned Plans model

        Returns
        -------
        prisma.models.Plans
            The created Plans record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Plans record from just the required fields
        plans = await Plans.prisma().create(
            data={
                # data to create a Plans record
                'planName': 'beicihhijb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PlansCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Plans records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Plans record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Plans.prisma().create_many(
            data=[
                {
                    # data to create a Plans record
                    'planName': 'fgggcdcjg',
                },
                {
                    # data to create a Plans record
                    'planName': 'ccjbbjigf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PlansWhereUniqueInput,
        include: Optional[types.PlansInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Plans record.

        Parameters
        ----------
        where
            Plans filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Plans model

        Returns
        -------
        prisma.models.Plans
            The deleted Plans record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        plans = await Plans.prisma().delete(
            where={
                'planId': 'bhfaabbaha',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PlansWhereUniqueInput,
        include: Optional[types.PlansInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Plans record.

        Parameters
        ----------
        where
            Plans filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Plans model

        Returns
        -------
        prisma.models.Plans
            The found Plans record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        plans = await Plans.prisma().find_unique(
            where={
                'planId': 'ebajedhhf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PlansWhereUniqueInput,
        include: Optional[types.PlansInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Plans record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Plans filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Plans model

        Returns
        -------
        prisma.models.Plans
            The found Plans record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        plans = await Plans.prisma().find_unique_or_raise(
            where={
                'planId': 'jajacedge',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlansWhereInput] = None,
        cursor: Optional[types.PlansWhereUniqueInput] = None,
        include: Optional[types.PlansInclude] = None,
        order: Optional[Union[types.PlansOrderByInput, List[types.PlansOrderByInput]]] = None,
        distinct: Optional[List[types.PlansScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Plans records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Plans records returned
        skip
            Ignore the first N results
        where
            Plans filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Plans model
        order
            Order the returned Plans records by any field
        distinct
            Filter Plans records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Plans]
            The list of all Plans records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Plans records
        plans = await Plans.prisma().find_many(take=10)

        # find the first 5 Plans records ordered by the planId field
        plans = await Plans.prisma().find_many(
            take=5,
            order={
                'planId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PlansWhereInput] = None,
        cursor: Optional[types.PlansWhereUniqueInput] = None,
        include: Optional[types.PlansInclude] = None,
        order: Optional[Union[types.PlansOrderByInput, List[types.PlansOrderByInput]]] = None,
        distinct: Optional[List[types.PlansScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Plans record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Plans filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Plans model
        order
            Order the returned Plans records by any field
        distinct
            Filter Plans records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Plans
            The first Plans record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Plans record ordered by the planName field
        plans = await Plans.prisma().find_first(
            skip=1,
            order={
                'planName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PlansWhereInput] = None,
        cursor: Optional[types.PlansWhereUniqueInput] = None,
        include: Optional[types.PlansInclude] = None,
        order: Optional[Union[types.PlansOrderByInput, List[types.PlansOrderByInput]]] = None,
        distinct: Optional[List[types.PlansScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Plans record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Plans filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Plans model
        order
            Order the returned Plans records by any field
        distinct
            Filter Plans records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Plans
            The first Plans record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Plans record ordered by the planId field
        plans = await Plans.prisma().find_first_or_raise(
            skip=1,
            order={
                'planId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PlansUpdateInput,
        where: types.PlansWhereUniqueInput,
        include: Optional[types.PlansInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Plans record.

        Parameters
        ----------
        data
            Plans record data specifying what to update
        where
            Plans filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Plans model

        Returns
        -------
        prisma.models.Plans
            The updated Plans record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        plans = await Plans.prisma().update(
            where={
                'planId': 'hffgbabgf',
            },
            data={
                # data to update the Plans record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PlansWhereUniqueInput,
        data: types.PlansUpsertInput,
        include: Optional[types.PlansInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Plans filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Plans model

        Returns
        -------
        prisma.models.Plans
            The created or updated Plans record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        plans = await Plans.prisma().upsert(
            where={
                'planId': 'biacbiieja',
            },
            data={
                'create': {
                    'planId': 'biacbiieja',
                    'planName': 'ccjbbjigf',
                },
                'update': {
                    'planName': 'ccjbbjigf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PlansUpdateManyMutationInput,
        where: types.PlansWhereInput,
    ) -> int:
        """Update multiple Plans records

        Parameters
        ----------
        data
            Plans data to update the selected Plans records to
        where
            Filter to select the Plans records to update

        Returns
        -------
        int
            The total number of Plans records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Plans records
        total = await Plans.prisma().update_many(
            data={
                'planName': 'cjejbgbff'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlansWhereInput] = None,
        cursor: Optional[types.PlansWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Plans records present in the database

        Parameters
        ----------
        select
            Select the Plans fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Plans filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PlansCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Plans.prisma().count()

        # results: prisma.types.PlansCountAggregateOutput
        results = await Plans.prisma().count(
            select={
                '_all': True,
                'planId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PlansCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlansWhereInput] = None,
        cursor: Optional[types.PlansWhereUniqueInput] = None,
    ) -> types.PlansCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PlansCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlansWhereInput] = None,
        cursor: Optional[types.PlansWhereUniqueInput] = None,
    ) -> Union[int, types.PlansCountAggregateOutput]:
        """Count the number of Plans records present in the database

        Parameters
        ----------
        select
            Select the Plans fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Plans filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PlansCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Plans.prisma().count()

        # results: prisma.types.PlansCountAggregateOutput
        results = await Plans.prisma().count(
            select={
                '_all': True,
                'planName': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PlansCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PlansWhereInput] = None
    ) -> int:
        """Delete multiple Plans records.

        Parameters
        ----------
        where
            Optional Plans filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Plans records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Plans records
        total = await Plans.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PlansScalarFieldKeys'],
        *,
        where: Optional['types.PlansWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PlansAvgAggregateInput'] = None,
        sum: Optional['types.PlansSumAggregateInput'] = None,
        min: Optional['types.PlansMinAggregateInput'] = None,
        max: Optional['types.PlansMaxAggregateInput'] = None,
        having: Optional['types.PlansScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PlansCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PlansScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.PlansScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.PlansGroupByOutput']:
        """Group Plans records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Plans fields to group records by
        where
            Plans filter to select records
        take
            Limit the maximum number of Plans records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PlansGroupByOutput]
            A list of dictionaries representing the Plans record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Plans records by planId values
        # and count how many records are in each group
        results = await Plans.prisma().group_by(
            ['planId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserAISettingsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserAISettings]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserAISettings.prisma().query_raw(
            'SELECT * FROM UserAISettings WHERE aiSettingsId = $1',
            'fgeahddae',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserAISettings
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserAISettings.prisma().query_first(
            'SELECT * FROM UserAISettings WHERE userId = $1',
            'diageigcf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserAISettingsCreateInput,
        include: Optional[types.UserAISettingsInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserAISettings record.

        Parameters
        ----------
        data
            UserAISettings record data
        include
            Specifies which relations should be loaded on the returned UserAISettings model

        Returns
        -------
        prisma.models.UserAISettings
            The created UserAISettings record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserAISettings record from just the required fields
        useraisettings = await UserAISettings.prisma().create(
            data={
                # data to create a UserAISettings record
                'userId': 'badagbgeha',
                'botSlug': 'ibgebbjch',
                'aiPersonalityProfile': Json({'baieajjiee': True}),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserAISettingsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserAISettings records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserAISettings record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserAISettings.prisma().create_many(
            data=[
                {
                    # data to create a UserAISettings record
                    'userId': 'bahjhaccfd',
                    'botSlug': 'hffhfabhi',
                    'aiPersonalityProfile': Json({'bbcigiadhb': True}),
                },
                {
                    # data to create a UserAISettings record
                    'userId': 'cfjagbbae',
                    'botSlug': 'bbbfhdidef',
                    'aiPersonalityProfile': Json({'bdadhibhec': True}),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserAISettingsWhereUniqueInput,
        include: Optional[types.UserAISettingsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserAISettings record.

        Parameters
        ----------
        where
            UserAISettings filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserAISettings model

        Returns
        -------
        prisma.models.UserAISettings
            The deleted UserAISettings record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        useraisettings = await UserAISettings.prisma().delete(
            where={
                'aiSettingsId': 'bfhdjaiejf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserAISettingsWhereUniqueInput,
        include: Optional[types.UserAISettingsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserAISettings record.

        Parameters
        ----------
        where
            UserAISettings filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserAISettings model

        Returns
        -------
        prisma.models.UserAISettings
            The found UserAISettings record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        useraisettings = await UserAISettings.prisma().find_unique(
            where={
                'aiSettingsId': 'bbjfijjadg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserAISettingsWhereUniqueInput,
        include: Optional[types.UserAISettingsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserAISettings record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserAISettings filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserAISettings model

        Returns
        -------
        prisma.models.UserAISettings
            The found UserAISettings record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        useraisettings = await UserAISettings.prisma().find_unique_or_raise(
            where={
                'aiSettingsId': 'hdjacbehh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserAISettingsWhereInput] = None,
        cursor: Optional[types.UserAISettingsWhereUniqueInput] = None,
        include: Optional[types.UserAISettingsInclude] = None,
        order: Optional[Union[types.UserAISettingsOrderByInput, List[types.UserAISettingsOrderByInput]]] = None,
        distinct: Optional[List[types.UserAISettingsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserAISettings records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserAISettings records returned
        skip
            Ignore the first N results
        where
            UserAISettings filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserAISettings model
        order
            Order the returned UserAISettings records by any field
        distinct
            Filter UserAISettings records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserAISettings]
            The list of all UserAISettings records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserAISettings records
        useraisettings = await UserAISettings.prisma().find_many(take=10)

        # find the first 5 UserAISettings records ordered by the botSlug field
        useraisettings = await UserAISettings.prisma().find_many(
            take=5,
            order={
                'botSlug': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserAISettingsWhereInput] = None,
        cursor: Optional[types.UserAISettingsWhereUniqueInput] = None,
        include: Optional[types.UserAISettingsInclude] = None,
        order: Optional[Union[types.UserAISettingsOrderByInput, List[types.UserAISettingsOrderByInput]]] = None,
        distinct: Optional[List[types.UserAISettingsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserAISettings record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserAISettings filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserAISettings model
        order
            Order the returned UserAISettings records by any field
        distinct
            Filter UserAISettings records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserAISettings
            The first UserAISettings record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserAISettings record ordered by the ragEnabled field
        useraisettings = await UserAISettings.prisma().find_first(
            skip=1,
            order={
                'ragEnabled': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserAISettingsWhereInput] = None,
        cursor: Optional[types.UserAISettingsWhereUniqueInput] = None,
        include: Optional[types.UserAISettingsInclude] = None,
        order: Optional[Union[types.UserAISettingsOrderByInput, List[types.UserAISettingsOrderByInput]]] = None,
        distinct: Optional[List[types.UserAISettingsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserAISettings record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserAISettings filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserAISettings model
        order
            Order the returned UserAISettings records by any field
        distinct
            Filter UserAISettings records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserAISettings
            The first UserAISettings record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserAISettings record ordered by the aiPersonalityProfile field
        useraisettings = await UserAISettings.prisma().find_first_or_raise(
            skip=1,
            order={
                'aiPersonalityProfile': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserAISettingsUpdateInput,
        where: types.UserAISettingsWhereUniqueInput,
        include: Optional[types.UserAISettingsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserAISettings record.

        Parameters
        ----------
        data
            UserAISettings record data specifying what to update
        where
            UserAISettings filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserAISettings model

        Returns
        -------
        prisma.models.UserAISettings
            The updated UserAISettings record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        useraisettings = await UserAISettings.prisma().update(
            where={
                'aiSettingsId': 'bhcccbeaba',
            },
            data={
                # data to update the UserAISettings record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserAISettingsWhereUniqueInput,
        data: types.UserAISettingsUpsertInput,
        include: Optional[types.UserAISettingsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserAISettings filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserAISettings model

        Returns
        -------
        prisma.models.UserAISettings
            The created or updated UserAISettings record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        useraisettings = await UserAISettings.prisma().upsert(
            where={
                'aiSettingsId': 'bcgjbdgjdj',
            },
            data={
                'create': {
                    'aiSettingsId': 'bcgjbdgjdj',
                    'userId': 'cfjagbbae',
                    'botSlug': 'bbbfhdidef',
                    'aiPersonalityProfile': Json({'bdadhibhec': True}),
                },
                'update': {
                    'userId': 'cfjagbbae',
                    'botSlug': 'bbbfhdidef',
                    'aiPersonalityProfile': Json({'bdadhibhec': True}),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserAISettingsUpdateManyMutationInput,
        where: types.UserAISettingsWhereInput,
    ) -> int:
        """Update multiple UserAISettings records

        Parameters
        ----------
        data
            UserAISettings data to update the selected UserAISettings records to
        where
            Filter to select the UserAISettings records to update

        Returns
        -------
        int
            The total number of UserAISettings records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserAISettings records
        total = await UserAISettings.prisma().update_many(
            data={
                'aiSettingsId': 'fhdbhifae'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserAISettingsWhereInput] = None,
        cursor: Optional[types.UserAISettingsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserAISettings records present in the database

        Parameters
        ----------
        select
            Select the UserAISettings fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserAISettings filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserAISettingsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserAISettings.prisma().count()

        # results: prisma.types.UserAISettingsCountAggregateOutput
        results = await UserAISettings.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserAISettingsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserAISettingsWhereInput] = None,
        cursor: Optional[types.UserAISettingsWhereUniqueInput] = None,
    ) -> types.UserAISettingsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserAISettingsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserAISettingsWhereInput] = None,
        cursor: Optional[types.UserAISettingsWhereUniqueInput] = None,
    ) -> Union[int, types.UserAISettingsCountAggregateOutput]:
        """Count the number of UserAISettings records present in the database

        Parameters
        ----------
        select
            Select the UserAISettings fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserAISettings filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserAISettingsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserAISettings.prisma().count()

        # results: prisma.types.UserAISettingsCountAggregateOutput
        results = await UserAISettings.prisma().count(
            select={
                '_all': True,
                'botSlug': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserAISettingsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserAISettingsWhereInput] = None
    ) -> int:
        """Delete multiple UserAISettings records.

        Parameters
        ----------
        where
            Optional UserAISettings filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserAISettings records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserAISettings records
        total = await UserAISettings.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserAISettingsScalarFieldKeys'],
        *,
        where: Optional['types.UserAISettingsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAISettingsAvgAggregateInput'] = None,
        sum: Optional['types.UserAISettingsSumAggregateInput'] = None,
        min: Optional['types.UserAISettingsMinAggregateInput'] = None,
        max: Optional['types.UserAISettingsMaxAggregateInput'] = None,
        having: Optional['types.UserAISettingsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserAISettingsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserAISettingsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserAISettingsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserAISettingsGroupByOutput']:
        """Group UserAISettings records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserAISettings fields to group records by
        where
            UserAISettings filter to select records
        take
            Limit the maximum number of UserAISettings records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserAISettingsGroupByOutput]
            A list of dictionaries representing the UserAISettings record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserAISettings records by ragEnabled values
        # and count how many records are in each group
        results = await UserAISettings.prisma().group_by(
            ['ragEnabled'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserMediaActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserMedia]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserMedia.prisma().query_raw(
            'SELECT * FROM UserMedia WHERE mediaId = $1',
            'beeacgfcej',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserMedia
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserMedia.prisma().query_first(
            'SELECT * FROM UserMedia WHERE userId = $1',
            'bbifhdiicc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserMediaCreateInput,
        include: Optional[types.UserMediaInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserMedia record.

        Parameters
        ----------
        data
            UserMedia record data
        include
            Specifies which relations should be loaded on the returned UserMedia model

        Returns
        -------
        prisma.models.UserMedia
            The created UserMedia record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserMedia record from just the required fields
        usermedia = await UserMedia.prisma().create(
            data={
                # data to create a UserMedia record
                'userId': 'bgjeccejad',
                'mediaType': enums.MediaType.IMAGE,
                'mediaUrl': 'bjagdgabbg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserMediaCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserMedia records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserMedia record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserMedia.prisma().create_many(
            data=[
                {
                    # data to create a UserMedia record
                    'userId': 'bjbbcffdij',
                    'mediaType': enums.MediaType.IMAGE,
                    'mediaUrl': 'begcgchdi',
                },
                {
                    # data to create a UserMedia record
                    'userId': 'bhbjceagbb',
                    'mediaType': enums.MediaType.IMAGE,
                    'mediaUrl': 'bjeifffjdg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserMediaWhereUniqueInput,
        include: Optional[types.UserMediaInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserMedia record.

        Parameters
        ----------
        where
            UserMedia filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserMedia model

        Returns
        -------
        prisma.models.UserMedia
            The deleted UserMedia record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usermedia = await UserMedia.prisma().delete(
            where={
                'mediaId': 'bdidcfdfjd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserMediaWhereUniqueInput,
        include: Optional[types.UserMediaInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserMedia record.

        Parameters
        ----------
        where
            UserMedia filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserMedia model

        Returns
        -------
        prisma.models.UserMedia
            The found UserMedia record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usermedia = await UserMedia.prisma().find_unique(
            where={
                'mediaId': 'dfeggejja',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserMediaWhereUniqueInput,
        include: Optional[types.UserMediaInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserMedia record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserMedia filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserMedia model

        Returns
        -------
        prisma.models.UserMedia
            The found UserMedia record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usermedia = await UserMedia.prisma().find_unique_or_raise(
            where={
                'mediaId': 'gehbgghbj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserMediaWhereInput] = None,
        cursor: Optional[types.UserMediaWhereUniqueInput] = None,
        include: Optional[types.UserMediaInclude] = None,
        order: Optional[Union[types.UserMediaOrderByInput, List[types.UserMediaOrderByInput]]] = None,
        distinct: Optional[List[types.UserMediaScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserMedia records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserMedia records returned
        skip
            Ignore the first N results
        where
            UserMedia filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserMedia model
        order
            Order the returned UserMedia records by any field
        distinct
            Filter UserMedia records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserMedia]
            The list of all UserMedia records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserMedia records
        usermedias = await UserMedia.prisma().find_many(take=10)

        # find the first 5 UserMedia records ordered by the mediaType field
        usermedias = await UserMedia.prisma().find_many(
            take=5,
            order={
                'mediaType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserMediaWhereInput] = None,
        cursor: Optional[types.UserMediaWhereUniqueInput] = None,
        include: Optional[types.UserMediaInclude] = None,
        order: Optional[Union[types.UserMediaOrderByInput, List[types.UserMediaOrderByInput]]] = None,
        distinct: Optional[List[types.UserMediaScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserMedia record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserMedia filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserMedia model
        order
            Order the returned UserMedia records by any field
        distinct
            Filter UserMedia records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserMedia
            The first UserMedia record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserMedia record ordered by the mediaUrl field
        usermedia = await UserMedia.prisma().find_first(
            skip=1,
            order={
                'mediaUrl': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserMediaWhereInput] = None,
        cursor: Optional[types.UserMediaWhereUniqueInput] = None,
        include: Optional[types.UserMediaInclude] = None,
        order: Optional[Union[types.UserMediaOrderByInput, List[types.UserMediaOrderByInput]]] = None,
        distinct: Optional[List[types.UserMediaScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserMedia record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserMedia filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserMedia model
        order
            Order the returned UserMedia records by any field
        distinct
            Filter UserMedia records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserMedia
            The first UserMedia record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserMedia record ordered by the uploadDate field
        usermedia = await UserMedia.prisma().find_first_or_raise(
            skip=1,
            order={
                'uploadDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserMediaUpdateInput,
        where: types.UserMediaWhereUniqueInput,
        include: Optional[types.UserMediaInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserMedia record.

        Parameters
        ----------
        data
            UserMedia record data specifying what to update
        where
            UserMedia filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserMedia model

        Returns
        -------
        prisma.models.UserMedia
            The updated UserMedia record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        usermedia = await UserMedia.prisma().update(
            where={
                'mediaId': 'dfhaijeie',
            },
            data={
                # data to update the UserMedia record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserMediaWhereUniqueInput,
        data: types.UserMediaUpsertInput,
        include: Optional[types.UserMediaInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserMedia filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserMedia model

        Returns
        -------
        prisma.models.UserMedia
            The created or updated UserMedia record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usermedia = await UserMedia.prisma().upsert(
            where={
                'mediaId': 'gbcdjgicb',
            },
            data={
                'create': {
                    'mediaId': 'gbcdjgicb',
                    'userId': 'bhbjceagbb',
                    'mediaType': enums.MediaType.IMAGE,
                    'mediaUrl': 'bjeifffjdg',
                },
                'update': {
                    'userId': 'bhbjceagbb',
                    'mediaType': enums.MediaType.IMAGE,
                    'mediaUrl': 'bjeifffjdg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserMediaUpdateManyMutationInput,
        where: types.UserMediaWhereInput,
    ) -> int:
        """Update multiple UserMedia records

        Parameters
        ----------
        data
            UserMedia data to update the selected UserMedia records to
        where
            Filter to select the UserMedia records to update

        Returns
        -------
        int
            The total number of UserMedia records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserMedia records
        total = await UserMedia.prisma().update_many(
            data={
                'mediaId': 'biaibdagac'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserMediaWhereInput] = None,
        cursor: Optional[types.UserMediaWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserMedia records present in the database

        Parameters
        ----------
        select
            Select the UserMedia fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserMedia filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserMediaCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserMedia.prisma().count()

        # results: prisma.types.UserMediaCountAggregateOutput
        results = await UserMedia.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserMediaCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserMediaWhereInput] = None,
        cursor: Optional[types.UserMediaWhereUniqueInput] = None,
    ) -> types.UserMediaCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserMediaCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserMediaWhereInput] = None,
        cursor: Optional[types.UserMediaWhereUniqueInput] = None,
    ) -> Union[int, types.UserMediaCountAggregateOutput]:
        """Count the number of UserMedia records present in the database

        Parameters
        ----------
        select
            Select the UserMedia fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserMedia filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserMediaCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserMedia.prisma().count()

        # results: prisma.types.UserMediaCountAggregateOutput
        results = await UserMedia.prisma().count(
            select={
                '_all': True,
                'mediaType': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserMediaCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserMediaWhereInput] = None
    ) -> int:
        """Delete multiple UserMedia records.

        Parameters
        ----------
        where
            Optional UserMedia filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserMedia records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserMedia records
        total = await UserMedia.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserMediaScalarFieldKeys'],
        *,
        where: Optional['types.UserMediaWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserMediaAvgAggregateInput'] = None,
        sum: Optional['types.UserMediaSumAggregateInput'] = None,
        min: Optional['types.UserMediaMinAggregateInput'] = None,
        max: Optional['types.UserMediaMaxAggregateInput'] = None,
        having: Optional['types.UserMediaScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserMediaCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserMediaScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserMediaScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserMediaGroupByOutput']:
        """Group UserMedia records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserMedia fields to group records by
        where
            UserMedia filter to select records
        take
            Limit the maximum number of UserMedia records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserMediaGroupByOutput]
            A list of dictionaries representing the UserMedia record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserMedia records by mediaUrl values
        # and count how many records are in each group
        results = await UserMedia.prisma().group_by(
            ['mediaUrl'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TenantActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Tenant]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Tenant.prisma().query_raw(
            'SELECT * FROM Tenant WHERE id = $1',
            'bbfbheibcd',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Tenant
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Tenant.prisma().query_first(
            'SELECT * FROM Tenant WHERE alias = $1',
            'hiagajie',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TenantCreateInput,
        include: Optional[types.TenantInclude] = None
    ) -> _PrismaModelT:
        """Create a new Tenant record.

        Parameters
        ----------
        data
            Tenant record data
        include
            Specifies which relations should be loaded on the returned Tenant model

        Returns
        -------
        prisma.models.Tenant
            The created Tenant record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Tenant record from just the required fields
        tenant = await Tenant.prisma().create(
            data={
                # data to create a Tenant record
                'alias': 'eeejidbif',
                'display_name': 'efgbahec',
                'menu_items': Json({'hgjaiebfb': True}),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TenantCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Tenant records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Tenant record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Tenant.prisma().create_many(
            data=[
                {
                    # data to create a Tenant record
                    'alias': 'bddefjjabc',
                    'display_name': 'bbbghgbadh',
                    'menu_items': Json({'bbhcgagaic': True}),
                },
                {
                    # data to create a Tenant record
                    'alias': 'ddaabegbb',
                    'display_name': 'bhgibfgbbc',
                    'menu_items': Json({'hbgcihef': True}),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TenantWhereUniqueInput,
        include: Optional[types.TenantInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Tenant record.

        Parameters
        ----------
        where
            Tenant filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Tenant model

        Returns
        -------
        prisma.models.Tenant
            The deleted Tenant record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tenant = await Tenant.prisma().delete(
            where={
                'id': 'ffhgghde',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TenantWhereUniqueInput,
        include: Optional[types.TenantInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Tenant record.

        Parameters
        ----------
        where
            Tenant filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Tenant model

        Returns
        -------
        prisma.models.Tenant
            The found Tenant record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tenant = await Tenant.prisma().find_unique(
            where={
                'id': 'ibcadcejf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TenantWhereUniqueInput,
        include: Optional[types.TenantInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Tenant record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Tenant filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Tenant model

        Returns
        -------
        prisma.models.Tenant
            The found Tenant record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tenant = await Tenant.prisma().find_unique_or_raise(
            where={
                'id': 'bdcdfgccdg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TenantWhereInput] = None,
        cursor: Optional[types.TenantWhereUniqueInput] = None,
        include: Optional[types.TenantInclude] = None,
        order: Optional[Union[types.TenantOrderByInput, List[types.TenantOrderByInput]]] = None,
        distinct: Optional[List[types.TenantScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Tenant records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Tenant records returned
        skip
            Ignore the first N results
        where
            Tenant filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tenant model
        order
            Order the returned Tenant records by any field
        distinct
            Filter Tenant records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Tenant]
            The list of all Tenant records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Tenant records
        tenants = await Tenant.prisma().find_many(take=10)

        # find the first 5 Tenant records ordered by the display_name field
        tenants = await Tenant.prisma().find_many(
            take=5,
            order={
                'display_name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TenantWhereInput] = None,
        cursor: Optional[types.TenantWhereUniqueInput] = None,
        include: Optional[types.TenantInclude] = None,
        order: Optional[Union[types.TenantOrderByInput, List[types.TenantOrderByInput]]] = None,
        distinct: Optional[List[types.TenantScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Tenant record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Tenant filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tenant model
        order
            Order the returned Tenant records by any field
        distinct
            Filter Tenant records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Tenant
            The first Tenant record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Tenant record ordered by the menu_items field
        tenant = await Tenant.prisma().find_first(
            skip=1,
            order={
                'menu_items': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TenantWhereInput] = None,
        cursor: Optional[types.TenantWhereUniqueInput] = None,
        include: Optional[types.TenantInclude] = None,
        order: Optional[Union[types.TenantOrderByInput, List[types.TenantOrderByInput]]] = None,
        distinct: Optional[List[types.TenantScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Tenant record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Tenant filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tenant model
        order
            Order the returned Tenant records by any field
        distinct
            Filter Tenant records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Tenant
            The first Tenant record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Tenant record ordered by the address field
        tenant = await Tenant.prisma().find_first_or_raise(
            skip=1,
            order={
                'address': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TenantUpdateInput,
        where: types.TenantWhereUniqueInput,
        include: Optional[types.TenantInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Tenant record.

        Parameters
        ----------
        data
            Tenant record data specifying what to update
        where
            Tenant filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Tenant model

        Returns
        -------
        prisma.models.Tenant
            The updated Tenant record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        tenant = await Tenant.prisma().update(
            where={
                'id': 'edhjgdfh',
            },
            data={
                # data to update the Tenant record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TenantWhereUniqueInput,
        data: types.TenantUpsertInput,
        include: Optional[types.TenantInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Tenant filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Tenant model

        Returns
        -------
        prisma.models.Tenant
            The created or updated Tenant record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tenant = await Tenant.prisma().upsert(
            where={
                'id': 'bdeffdadda',
            },
            data={
                'create': {
                    'id': 'bdeffdadda',
                    'alias': 'ddaabegbb',
                    'display_name': 'bhgibfgbbc',
                    'menu_items': Json({'hbgcihef': True}),
                },
                'update': {
                    'alias': 'ddaabegbb',
                    'display_name': 'bhgibfgbbc',
                    'menu_items': Json({'hbgcihef': True}),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TenantUpdateManyMutationInput,
        where: types.TenantWhereInput,
    ) -> int:
        """Update multiple Tenant records

        Parameters
        ----------
        data
            Tenant data to update the selected Tenant records to
        where
            Filter to select the Tenant records to update

        Returns
        -------
        int
            The total number of Tenant records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Tenant records
        total = await Tenant.prisma().update_many(
            data={
                'status': 'bjgfdihchf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TenantWhereInput] = None,
        cursor: Optional[types.TenantWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Tenant records present in the database

        Parameters
        ----------
        select
            Select the Tenant fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Tenant filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TenantCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Tenant.prisma().count()

        # results: prisma.types.TenantCountAggregateOutput
        results = await Tenant.prisma().count(
            select={
                '_all': True,
                'created_at': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TenantCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TenantWhereInput] = None,
        cursor: Optional[types.TenantWhereUniqueInput] = None,
    ) -> types.TenantCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TenantCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TenantWhereInput] = None,
        cursor: Optional[types.TenantWhereUniqueInput] = None,
    ) -> Union[int, types.TenantCountAggregateOutput]:
        """Count the number of Tenant records present in the database

        Parameters
        ----------
        select
            Select the Tenant fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Tenant filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TenantCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Tenant.prisma().count()

        # results: prisma.types.TenantCountAggregateOutput
        results = await Tenant.prisma().count(
            select={
                '_all': True,
                'updated_at': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TenantCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TenantWhereInput] = None
    ) -> int:
        """Delete multiple Tenant records.

        Parameters
        ----------
        where
            Optional Tenant filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Tenant records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Tenant records
        total = await Tenant.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TenantScalarFieldKeys'],
        *,
        where: Optional['types.TenantWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TenantAvgAggregateInput'] = None,
        sum: Optional['types.TenantSumAggregateInput'] = None,
        min: Optional['types.TenantMinAggregateInput'] = None,
        max: Optional['types.TenantMaxAggregateInput'] = None,
        having: Optional['types.TenantScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TenantCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TenantScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TenantScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TenantGroupByOutput']:
        """Group Tenant records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Tenant fields to group records by
        where
            Tenant filter to select records
        take
            Limit the maximum number of Tenant records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TenantGroupByOutput]
            A list of dictionaries representing the Tenant record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Tenant records by id values
        # and count how many records are in each group
        results = await Tenant.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class OrderActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Order]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Order.prisma().query_raw(
            'SELECT * FROM Order WHERE id = $1',
            'iaeihdeei',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Order
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Order.prisma().query_first(
            'SELECT * FROM Order WHERE customer_name = $1',
            'bfggejgfbd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.OrderCreateInput,
        include: Optional[types.OrderInclude] = None
    ) -> _PrismaModelT:
        """Create a new Order record.

        Parameters
        ----------
        data
            Order record data
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The created Order record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Order record from just the required fields
        order = await Order.prisma().create(
            data={
                # data to create a Order record
                'customer_name': 'ifaaaedja',
                'items': 'cbajdjjabf',
                'total_price': 1282664340.24123,
                'status': 'ehfigdgac',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.OrderCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Order records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Order record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Order.prisma().create_many(
            data=[
                {
                    # data to create a Order record
                    'customer_name': 'bhbgccijjf',
                    'items': 'bigjhdgbjc',
                    'total_price': 1585341753.2927,
                    'status': 'bfiibjcehj',
                },
                {
                    # data to create a Order record
                    'customer_name': 'ijieafghg',
                    'items': 'hhhegahcf',
                    'total_price': 437894538.39334,
                    'status': 'bgdicjhie',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.OrderWhereUniqueInput,
        include: Optional[types.OrderInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Order record.

        Parameters
        ----------
        where
            Order filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The deleted Order record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        order = await Order.prisma().delete(
            where={
                'id': 'ceibfcgij',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.OrderWhereUniqueInput,
        include: Optional[types.OrderInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Order record.

        Parameters
        ----------
        where
            Order filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The found Order record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        order = await Order.prisma().find_unique(
            where={
                'id': 'debhbfada',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.OrderWhereUniqueInput,
        include: Optional[types.OrderInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Order record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Order filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The found Order record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        order = await Order.prisma().find_unique_or_raise(
            where={
                'id': 'bgjchggecd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
        include: Optional[types.OrderInclude] = None,
        order: Optional[Union[types.OrderOrderByInput, List[types.OrderOrderByInput]]] = None,
        distinct: Optional[List[types.OrderScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Order records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Order records returned
        skip
            Ignore the first N results
        where
            Order filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Order model
        order
            Order the returned Order records by any field
        distinct
            Filter Order records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Order]
            The list of all Order records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Order records
        orders = await Order.prisma().find_many(take=10)

        # find the first 5 Order records ordered by the items field
        orders = await Order.prisma().find_many(
            take=5,
            order={
                'items': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
        include: Optional[types.OrderInclude] = None,
        order: Optional[Union[types.OrderOrderByInput, List[types.OrderOrderByInput]]] = None,
        distinct: Optional[List[types.OrderScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Order record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Order filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Order model
        order
            Order the returned Order records by any field
        distinct
            Filter Order records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Order
            The first Order record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Order record ordered by the total_price field
        order = await Order.prisma().find_first(
            skip=1,
            order={
                'total_price': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
        include: Optional[types.OrderInclude] = None,
        order: Optional[Union[types.OrderOrderByInput, List[types.OrderOrderByInput]]] = None,
        distinct: Optional[List[types.OrderScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Order record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Order filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Order model
        order
            Order the returned Order records by any field
        distinct
            Filter Order records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Order
            The first Order record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Order record ordered by the status field
        order = await Order.prisma().find_first_or_raise(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.OrderUpdateInput,
        where: types.OrderWhereUniqueInput,
        include: Optional[types.OrderInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Order record.

        Parameters
        ----------
        data
            Order record data specifying what to update
        where
            Order filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The updated Order record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        order = await Order.prisma().update(
            where={
                'id': 'igggcfjg',
            },
            data={
                # data to update the Order record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.OrderWhereUniqueInput,
        data: types.OrderUpsertInput,
        include: Optional[types.OrderInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Order filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The created or updated Order record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        order = await Order.prisma().upsert(
            where={
                'id': 'bgjhijffjh',
            },
            data={
                'create': {
                    'id': 'bgjhijffjh',
                    'customer_name': 'ijieafghg',
                    'items': 'hhhegahcf',
                    'total_price': 437894538.39334,
                    'status': 'bgdicjhie',
                },
                'update': {
                    'customer_name': 'ijieafghg',
                    'items': 'hhhegahcf',
                    'total_price': 437894538.39334,
                    'status': 'bgdicjhie',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.OrderUpdateManyMutationInput,
        where: types.OrderWhereInput,
    ) -> int:
        """Update multiple Order records

        Parameters
        ----------
        data
            Order data to update the selected Order records to
        where
            Filter to select the Order records to update

        Returns
        -------
        int
            The total number of Order records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Order records
        total = await Order.prisma().update_many(
            data={
                'created_at': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Order records present in the database

        Parameters
        ----------
        select
            Select the Order fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Order filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OrderCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Order.prisma().count()

        # results: prisma.types.OrderCountAggregateOutput
        results = await Order.prisma().count(
            select={
                '_all': True,
                'updated_at': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.OrderCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
    ) -> types.OrderCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.OrderCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
    ) -> Union[int, types.OrderCountAggregateOutput]:
        """Count the number of Order records present in the database

        Parameters
        ----------
        select
            Select the Order fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Order filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OrderCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Order.prisma().count()

        # results: prisma.types.OrderCountAggregateOutput
        results = await Order.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.OrderCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.OrderWhereInput] = None
    ) -> int:
        """Delete multiple Order records.

        Parameters
        ----------
        where
            Optional Order filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Order records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Order records
        total = await Order.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.OrderScalarFieldKeys'],
        *,
        where: Optional['types.OrderWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.OrderAvgAggregateInput'] = None,
        sum: Optional['types.OrderSumAggregateInput'] = None,
        min: Optional['types.OrderMinAggregateInput'] = None,
        max: Optional['types.OrderMaxAggregateInput'] = None,
        having: Optional['types.OrderScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.OrderCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.OrderScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.OrderScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.OrderGroupByOutput']:
        """Group Order records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Order fields to group records by
        where
            Order filter to select records
        take
            Limit the maximum number of Order records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.OrderGroupByOutput]
            A list of dictionaries representing the Order record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Order records by customer_name values
        # and count how many records are in each group
        results = await Order.prisma().group_by(
            ['customer_name'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class MemoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Memory]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Memory.prisma().query_raw(
            'SELECT * FROM Memory WHERE id = $1',
            1286370274,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Memory
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Memory.prisma().query_first(
            'SELECT * FROM Memory WHERE title = $1',
            'igefhgdhb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.MemoryCreateInput,
        include: Optional[types.MemoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new Memory record.

        Parameters
        ----------
        data
            Memory record data
        include
            Specifies which relations should be loaded on the returned Memory model

        Returns
        -------
        prisma.models.Memory
            The created Memory record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Memory record from just the required fields
        memory = await Memory.prisma().create(
            data={
                # data to create a Memory record
                'title': 'ejbiifbae',
                'content': 'djcfgedjd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.MemoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Memory records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Memory record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Memory.prisma().create_many(
            data=[
                {
                    # data to create a Memory record
                    'title': 'bdbjcdegag',
                    'content': 'hbchfebch',
                },
                {
                    # data to create a Memory record
                    'title': 'bcjjffegfc',
                    'content': 'cahaeaicjd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.MemoryWhereUniqueInput,
        include: Optional[types.MemoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Memory record.

        Parameters
        ----------
        where
            Memory filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Memory model

        Returns
        -------
        prisma.models.Memory
            The deleted Memory record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        memory = await Memory.prisma().delete(
            where={
                'id': 811900218,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.MemoryWhereUniqueInput,
        include: Optional[types.MemoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Memory record.

        Parameters
        ----------
        where
            Memory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Memory model

        Returns
        -------
        prisma.models.Memory
            The found Memory record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        memory = await Memory.prisma().find_unique(
            where={
                'id': 396021227,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.MemoryWhereUniqueInput,
        include: Optional[types.MemoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Memory record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Memory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Memory model

        Returns
        -------
        prisma.models.Memory
            The found Memory record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        memory = await Memory.prisma().find_unique_or_raise(
            where={
                'id': 644446024,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MemoryWhereInput] = None,
        cursor: Optional[types.MemoryWhereUniqueInput] = None,
        include: Optional[types.MemoryInclude] = None,
        order: Optional[Union[types.MemoryOrderByInput, List[types.MemoryOrderByInput]]] = None,
        distinct: Optional[List[types.MemoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Memory records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Memory records returned
        skip
            Ignore the first N results
        where
            Memory filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Memory model
        order
            Order the returned Memory records by any field
        distinct
            Filter Memory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Memory]
            The list of all Memory records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Memory records
        memorys = await Memory.prisma().find_many(take=10)

        # find the first 5 Memory records ordered by the content field
        memorys = await Memory.prisma().find_many(
            take=5,
            order={
                'content': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MemoryWhereInput] = None,
        cursor: Optional[types.MemoryWhereUniqueInput] = None,
        include: Optional[types.MemoryInclude] = None,
        order: Optional[Union[types.MemoryOrderByInput, List[types.MemoryOrderByInput]]] = None,
        distinct: Optional[List[types.MemoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Memory record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Memory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Memory model
        order
            Order the returned Memory records by any field
        distinct
            Filter Memory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Memory
            The first Memory record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Memory record ordered by the createdAt field
        memory = await Memory.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MemoryWhereInput] = None,
        cursor: Optional[types.MemoryWhereUniqueInput] = None,
        include: Optional[types.MemoryInclude] = None,
        order: Optional[Union[types.MemoryOrderByInput, List[types.MemoryOrderByInput]]] = None,
        distinct: Optional[List[types.MemoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Memory record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Memory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Memory model
        order
            Order the returned Memory records by any field
        distinct
            Filter Memory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Memory
            The first Memory record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Memory record ordered by the updatedAt field
        memory = await Memory.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.MemoryUpdateInput,
        where: types.MemoryWhereUniqueInput,
        include: Optional[types.MemoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Memory record.

        Parameters
        ----------
        data
            Memory record data specifying what to update
        where
            Memory filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Memory model

        Returns
        -------
        prisma.models.Memory
            The updated Memory record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        memory = await Memory.prisma().update(
            where={
                'id': 116386273,
            },
            data={
                # data to update the Memory record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.MemoryWhereUniqueInput,
        data: types.MemoryUpsertInput,
        include: Optional[types.MemoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Memory filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Memory model

        Returns
        -------
        prisma.models.Memory
            The created or updated Memory record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        memory = await Memory.prisma().upsert(
            where={
                'id': 309285638,
            },
            data={
                'create': {
                    'id': 309285638,
                    'title': 'bcjjffegfc',
                    'content': 'cahaeaicjd',
                },
                'update': {
                    'title': 'bcjjffegfc',
                    'content': 'cahaeaicjd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.MemoryUpdateManyMutationInput,
        where: types.MemoryWhereInput,
    ) -> int:
        """Update multiple Memory records

        Parameters
        ----------
        data
            Memory data to update the selected Memory records to
        where
            Filter to select the Memory records to update

        Returns
        -------
        int
            The total number of Memory records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Memory records
        total = await Memory.prisma().update_many(
            data={
                'id': 22437319
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MemoryWhereInput] = None,
        cursor: Optional[types.MemoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Memory records present in the database

        Parameters
        ----------
        select
            Select the Memory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Memory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MemoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Memory.prisma().count()

        # results: prisma.types.MemoryCountAggregateOutput
        results = await Memory.prisma().count(
            select={
                '_all': True,
                'title': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.MemoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MemoryWhereInput] = None,
        cursor: Optional[types.MemoryWhereUniqueInput] = None,
    ) -> types.MemoryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.MemoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MemoryWhereInput] = None,
        cursor: Optional[types.MemoryWhereUniqueInput] = None,
    ) -> Union[int, types.MemoryCountAggregateOutput]:
        """Count the number of Memory records present in the database

        Parameters
        ----------
        select
            Select the Memory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Memory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MemoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Memory.prisma().count()

        # results: prisma.types.MemoryCountAggregateOutput
        results = await Memory.prisma().count(
            select={
                '_all': True,
                'content': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.MemoryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.MemoryWhereInput] = None
    ) -> int:
        """Delete multiple Memory records.

        Parameters
        ----------
        where
            Optional Memory filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Memory records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Memory records
        total = await Memory.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.MemoryScalarFieldKeys'],
        *,
        where: Optional['types.MemoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.MemoryAvgAggregateInput'] = None,
        sum: Optional['types.MemorySumAggregateInput'] = None,
        min: Optional['types.MemoryMinAggregateInput'] = None,
        max: Optional['types.MemoryMaxAggregateInput'] = None,
        having: Optional['types.MemoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.MemoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.MemoryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.MemoryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.MemoryGroupByOutput']:
        """Group Memory records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Memory fields to group records by
        where
            Memory filter to select records
        take
            Limit the maximum number of Memory records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.MemoryGroupByOutput]
            A list of dictionaries representing the Memory record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Memory records by createdAt values
        # and count how many records are in each group
        results = await Memory.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class RagDocumentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.RagDocument]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await RagDocument.prisma().query_raw(
            'SELECT * FROM RagDocument WHERE id = $1',
            1900199924,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.RagDocument
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await RagDocument.prisma().query_first(
            'SELECT * FROM RagDocument WHERE tenantId = $1',
            'cafhdcdcjd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.RagDocumentCreateInput,
        include: Optional[types.RagDocumentInclude] = None
    ) -> _PrismaModelT:
        """Create a new RagDocument record.

        Parameters
        ----------
        data
            RagDocument record data
        include
            Specifies which relations should be loaded on the returned RagDocument model

        Returns
        -------
        prisma.models.RagDocument
            The created RagDocument record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a RagDocument record from just the required fields
        ragdocument = await RagDocument.prisma().create(
            data={
                # data to create a RagDocument record
                'tenantId': 'bdeebbhbdi',
                'title': 'cafcbdchah',
                'content': 'bdffbehbae',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.RagDocumentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple RagDocument records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of RagDocument record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await RagDocument.prisma().create_many(
            data=[
                {
                    # data to create a RagDocument record
                    'tenantId': 'ieahjgeb',
                    'title': 'hfeeddceg',
                    'content': 'dbecgbbid',
                },
                {
                    # data to create a RagDocument record
                    'tenantId': 'cchghigae',
                    'title': 'ecdjjjhab',
                    'content': 'biachfede',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.RagDocumentWhereUniqueInput,
        include: Optional[types.RagDocumentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single RagDocument record.

        Parameters
        ----------
        where
            RagDocument filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned RagDocument model

        Returns
        -------
        prisma.models.RagDocument
            The deleted RagDocument record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        ragdocument = await RagDocument.prisma().delete(
            where={
                'id': 57608155,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.RagDocumentWhereUniqueInput,
        include: Optional[types.RagDocumentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique RagDocument record.

        Parameters
        ----------
        where
            RagDocument filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned RagDocument model

        Returns
        -------
        prisma.models.RagDocument
            The found RagDocument record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        ragdocument = await RagDocument.prisma().find_unique(
            where={
                'id': 2030912120,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.RagDocumentWhereUniqueInput,
        include: Optional[types.RagDocumentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique RagDocument record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            RagDocument filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned RagDocument model

        Returns
        -------
        prisma.models.RagDocument
            The found RagDocument record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        ragdocument = await RagDocument.prisma().find_unique_or_raise(
            where={
                'id': 1974865233,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RagDocumentWhereInput] = None,
        cursor: Optional[types.RagDocumentWhereUniqueInput] = None,
        include: Optional[types.RagDocumentInclude] = None,
        order: Optional[Union[types.RagDocumentOrderByInput, List[types.RagDocumentOrderByInput]]] = None,
        distinct: Optional[List[types.RagDocumentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple RagDocument records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of RagDocument records returned
        skip
            Ignore the first N results
        where
            RagDocument filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RagDocument model
        order
            Order the returned RagDocument records by any field
        distinct
            Filter RagDocument records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.RagDocument]
            The list of all RagDocument records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 RagDocument records
        ragdocuments = await RagDocument.prisma().find_many(take=10)

        # find the first 5 RagDocument records ordered by the title field
        ragdocuments = await RagDocument.prisma().find_many(
            take=5,
            order={
                'title': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RagDocumentWhereInput] = None,
        cursor: Optional[types.RagDocumentWhereUniqueInput] = None,
        include: Optional[types.RagDocumentInclude] = None,
        order: Optional[Union[types.RagDocumentOrderByInput, List[types.RagDocumentOrderByInput]]] = None,
        distinct: Optional[List[types.RagDocumentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single RagDocument record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            RagDocument filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RagDocument model
        order
            Order the returned RagDocument records by any field
        distinct
            Filter RagDocument records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.RagDocument
            The first RagDocument record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second RagDocument record ordered by the content field
        ragdocument = await RagDocument.prisma().find_first(
            skip=1,
            order={
                'content': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RagDocumentWhereInput] = None,
        cursor: Optional[types.RagDocumentWhereUniqueInput] = None,
        include: Optional[types.RagDocumentInclude] = None,
        order: Optional[Union[types.RagDocumentOrderByInput, List[types.RagDocumentOrderByInput]]] = None,
        distinct: Optional[List[types.RagDocumentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single RagDocument record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            RagDocument filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RagDocument model
        order
            Order the returned RagDocument records by any field
        distinct
            Filter RagDocument records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.RagDocument
            The first RagDocument record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second RagDocument record ordered by the source field
        ragdocument = await RagDocument.prisma().find_first_or_raise(
            skip=1,
            order={
                'source': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.RagDocumentUpdateInput,
        where: types.RagDocumentWhereUniqueInput,
        include: Optional[types.RagDocumentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single RagDocument record.

        Parameters
        ----------
        data
            RagDocument record data specifying what to update
        where
            RagDocument filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned RagDocument model

        Returns
        -------
        prisma.models.RagDocument
            The updated RagDocument record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        ragdocument = await RagDocument.prisma().update(
            where={
                'id': 1949862326,
            },
            data={
                # data to update the RagDocument record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.RagDocumentWhereUniqueInput,
        data: types.RagDocumentUpsertInput,
        include: Optional[types.RagDocumentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            RagDocument filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned RagDocument model

        Returns
        -------
        prisma.models.RagDocument
            The created or updated RagDocument record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        ragdocument = await RagDocument.prisma().upsert(
            where={
                'id': 1858881207,
            },
            data={
                'create': {
                    'id': 1858881207,
                    'tenantId': 'cchghigae',
                    'title': 'ecdjjjhab',
                    'content': 'biachfede',
                },
                'update': {
                    'tenantId': 'cchghigae',
                    'title': 'ecdjjjhab',
                    'content': 'biachfede',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.RagDocumentUpdateManyMutationInput,
        where: types.RagDocumentWhereInput,
    ) -> int:
        """Update multiple RagDocument records

        Parameters
        ----------
        data
            RagDocument data to update the selected RagDocument records to
        where
            Filter to select the RagDocument records to update

        Returns
        -------
        int
            The total number of RagDocument records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all RagDocument records
        total = await RagDocument.prisma().update_many(
            data={
                'tags': 'dbjibjdaa'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RagDocumentWhereInput] = None,
        cursor: Optional[types.RagDocumentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of RagDocument records present in the database

        Parameters
        ----------
        select
            Select the RagDocument fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            RagDocument filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RagDocumentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await RagDocument.prisma().count()

        # results: prisma.types.RagDocumentCountAggregateOutput
        results = await RagDocument.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.RagDocumentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RagDocumentWhereInput] = None,
        cursor: Optional[types.RagDocumentWhereUniqueInput] = None,
    ) -> types.RagDocumentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.RagDocumentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RagDocumentWhereInput] = None,
        cursor: Optional[types.RagDocumentWhereUniqueInput] = None,
    ) -> Union[int, types.RagDocumentCountAggregateOutput]:
        """Count the number of RagDocument records present in the database

        Parameters
        ----------
        select
            Select the RagDocument fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            RagDocument filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RagDocumentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await RagDocument.prisma().count()

        # results: prisma.types.RagDocumentCountAggregateOutput
        results = await RagDocument.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.RagDocumentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.RagDocumentWhereInput] = None
    ) -> int:
        """Delete multiple RagDocument records.

        Parameters
        ----------
        where
            Optional RagDocument filter to find the records to be deleted

        Returns
        -------
        int
            The total number of RagDocument records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all RagDocument records
        total = await RagDocument.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.RagDocumentScalarFieldKeys'],
        *,
        where: Optional['types.RagDocumentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.RagDocumentAvgAggregateInput'] = None,
        sum: Optional['types.RagDocumentSumAggregateInput'] = None,
        min: Optional['types.RagDocumentMinAggregateInput'] = None,
        max: Optional['types.RagDocumentMaxAggregateInput'] = None,
        having: Optional['types.RagDocumentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.RagDocumentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.RagDocumentScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.RagDocumentScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.RagDocumentGroupByOutput']:
        """Group RagDocument records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar RagDocument fields to group records by
        where
            RagDocument filter to select records
        take
            Limit the maximum number of RagDocument records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.RagDocumentGroupByOutput]
            A list of dictionaries representing the RagDocument record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group RagDocument records by embeddings values
        # and count how many records are in each group
        results = await RagDocument.prisma().group_by(
            ['embeddings'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AuditLogActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AuditLog]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AuditLog.prisma().query_raw(
            'SELECT * FROM AuditLog WHERE id = $1',
            'dgijbdiaf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AuditLog
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AuditLog.prisma().query_first(
            'SELECT * FROM AuditLog WHERE userId = $1',
            'begfaigba',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AuditLogCreateInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> _PrismaModelT:
        """Create a new AuditLog record.

        Parameters
        ----------
        data
            AuditLog record data
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The created AuditLog record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AuditLog record from just the required fields
        auditlog = await AuditLog.prisma().create(
            data={
                # data to create a AuditLog record
                'eventType': 'bdjiafcgjb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AuditLogCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AuditLog records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AuditLog record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AuditLog.prisma().create_many(
            data=[
                {
                    # data to create a AuditLog record
                    'eventType': 'bficecgcfg',
                },
                {
                    # data to create a AuditLog record
                    'eventType': 'cbjjeedcj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AuditLogWhereUniqueInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AuditLog record.

        Parameters
        ----------
        where
            AuditLog filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The deleted AuditLog record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().delete(
            where={
                'id': 'dedgbbhja',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AuditLogWhereUniqueInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AuditLog record.

        Parameters
        ----------
        where
            AuditLog filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The found AuditLog record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().find_unique(
            where={
                'id': 'cabiahchj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AuditLogWhereUniqueInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AuditLog record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AuditLog filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The found AuditLog record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().find_unique_or_raise(
            where={
                'id': 'cgbeccfce',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
        include: Optional[types.AuditLogInclude] = None,
        order: Optional[Union[types.AuditLogOrderByInput, List[types.AuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.AuditLogScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AuditLog records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AuditLog records returned
        skip
            Ignore the first N results
        where
            AuditLog filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AuditLog model
        order
            Order the returned AuditLog records by any field
        distinct
            Filter AuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AuditLog]
            The list of all AuditLog records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AuditLog records
        auditlogs = await AuditLog.prisma().find_many(take=10)

        # find the first 5 AuditLog records ordered by the eventType field
        auditlogs = await AuditLog.prisma().find_many(
            take=5,
            order={
                'eventType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
        include: Optional[types.AuditLogInclude] = None,
        order: Optional[Union[types.AuditLogOrderByInput, List[types.AuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.AuditLogScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AuditLog record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AuditLog filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AuditLog model
        order
            Order the returned AuditLog records by any field
        distinct
            Filter AuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AuditLog
            The first AuditLog record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AuditLog record ordered by the ipAddress field
        auditlog = await AuditLog.prisma().find_first(
            skip=1,
            order={
                'ipAddress': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
        include: Optional[types.AuditLogInclude] = None,
        order: Optional[Union[types.AuditLogOrderByInput, List[types.AuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.AuditLogScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AuditLog record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AuditLog filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AuditLog model
        order
            Order the returned AuditLog records by any field
        distinct
            Filter AuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AuditLog
            The first AuditLog record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AuditLog record ordered by the userAgent field
        auditlog = await AuditLog.prisma().find_first_or_raise(
            skip=1,
            order={
                'userAgent': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AuditLogUpdateInput,
        where: types.AuditLogWhereUniqueInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AuditLog record.

        Parameters
        ----------
        data
            AuditLog record data specifying what to update
        where
            AuditLog filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The updated AuditLog record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().update(
            where={
                'id': 'fcjcagef',
            },
            data={
                # data to update the AuditLog record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AuditLogWhereUniqueInput,
        data: types.AuditLogUpsertInput,
        include: Optional[types.AuditLogInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AuditLog filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The created or updated AuditLog record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().upsert(
            where={
                'id': 'bgdhaeacic',
            },
            data={
                'create': {
                    'id': 'bgdhaeacic',
                    'eventType': 'cbjjeedcj',
                },
                'update': {
                    'eventType': 'cbjjeedcj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AuditLogUpdateManyMutationInput,
        where: types.AuditLogWhereInput,
    ) -> int:
        """Update multiple AuditLog records

        Parameters
        ----------
        data
            AuditLog data to update the selected AuditLog records to
        where
            Filter to select the AuditLog records to update

        Returns
        -------
        int
            The total number of AuditLog records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AuditLog records
        total = await AuditLog.prisma().update_many(
            data={
                'metadata': Json({'caffafcheh': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AuditLog records present in the database

        Parameters
        ----------
        select
            Select the AuditLog fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AuditLog filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AuditLogCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AuditLog.prisma().count()

        # results: prisma.types.AuditLogCountAggregateOutput
        results = await AuditLog.prisma().count(
            select={
                '_all': True,
                'success': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AuditLogCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
    ) -> types.AuditLogCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AuditLogCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
    ) -> Union[int, types.AuditLogCountAggregateOutput]:
        """Count the number of AuditLog records present in the database

        Parameters
        ----------
        select
            Select the AuditLog fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AuditLog filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AuditLogCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AuditLog.prisma().count()

        # results: prisma.types.AuditLogCountAggregateOutput
        results = await AuditLog.prisma().count(
            select={
                '_all': True,
                'errorMessage': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AuditLogCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AuditLogWhereInput] = None
    ) -> int:
        """Delete multiple AuditLog records.

        Parameters
        ----------
        where
            Optional AuditLog filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AuditLog records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AuditLog records
        total = await AuditLog.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AuditLogScalarFieldKeys'],
        *,
        where: Optional['types.AuditLogWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AuditLogAvgAggregateInput'] = None,
        sum: Optional['types.AuditLogSumAggregateInput'] = None,
        min: Optional['types.AuditLogMinAggregateInput'] = None,
        max: Optional['types.AuditLogMaxAggregateInput'] = None,
        having: Optional['types.AuditLogScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AuditLogCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AuditLogScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AuditLogScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AuditLogGroupByOutput']:
        """Group AuditLog records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AuditLog fields to group records by
        where
            AuditLog filter to select records
        take
            Limit the maximum number of AuditLog records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AuditLogGroupByOutput]
            A list of dictionaries representing the AuditLog record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AuditLog records by createdAt values
        # and count how many records are in each group
        results = await AuditLog.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TransaksiHarianActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.TransaksiHarian]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await TransaksiHarian.prisma().query_raw(
            'SELECT * FROM TransaksiHarian WHERE id = $1',
            'fjjbegge',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.TransaksiHarian
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await TransaksiHarian.prisma().query_first(
            'SELECT * FROM TransaksiHarian WHERE tenantId = $1',
            'bdiifhbieb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TransaksiHarianCreateInput,
        include: Optional[types.TransaksiHarianInclude] = None
    ) -> _PrismaModelT:
        """Create a new TransaksiHarian record.

        Parameters
        ----------
        data
            TransaksiHarian record data
        include
            Specifies which relations should be loaded on the returned TransaksiHarian model

        Returns
        -------
        prisma.models.TransaksiHarian
            The created TransaksiHarian record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a TransaksiHarian record from just the required fields
        transaksiharian = await TransaksiHarian.prisma().create(
            data={
                # data to create a TransaksiHarian record
                'tenantId': 'cdcaejhgg',
                'createdBy': 'jbijgfbfj',
                'actorRole': 'ggfbeddia',
                'timestamp': 479391708,
                'jenisTransaksi': 'bjabbfceji',
                'payload': Json({'bgchfbjibb': True}),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TransaksiHarianCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple TransaksiHarian records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of TransaksiHarian record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await TransaksiHarian.prisma().create_many(
            data=[
                {
                    # data to create a TransaksiHarian record
                    'tenantId': 'bajecchdjc',
                    'createdBy': 'dfgacajif',
                    'actorRole': 'bgdiddfadi',
                    'timestamp': 22698813300,
                    'jenisTransaksi': 'bahchhihdc',
                    'payload': Json({'bihjdcibib': True}),
                },
                {
                    # data to create a TransaksiHarian record
                    'tenantId': 'bfhhjbbdha',
                    'createdBy': 'faehcjfdb',
                    'actorRole': 'bbaiefbee',
                    'timestamp': 15603229260,
                    'jenisTransaksi': 'biibaighec',
                    'payload': Json({'baicdfeidj': True}),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TransaksiHarianWhereUniqueInput,
        include: Optional[types.TransaksiHarianInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single TransaksiHarian record.

        Parameters
        ----------
        where
            TransaksiHarian filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned TransaksiHarian model

        Returns
        -------
        prisma.models.TransaksiHarian
            The deleted TransaksiHarian record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transaksiharian = await TransaksiHarian.prisma().delete(
            where={
                'id': 'befgiciadg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TransaksiHarianWhereUniqueInput,
        include: Optional[types.TransaksiHarianInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique TransaksiHarian record.

        Parameters
        ----------
        where
            TransaksiHarian filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TransaksiHarian model

        Returns
        -------
        prisma.models.TransaksiHarian
            The found TransaksiHarian record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transaksiharian = await TransaksiHarian.prisma().find_unique(
            where={
                'id': 'cbcehahedh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TransaksiHarianWhereUniqueInput,
        include: Optional[types.TransaksiHarianInclude] = None
    ) -> _PrismaModelT:
        """Find a unique TransaksiHarian record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            TransaksiHarian filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TransaksiHarian model

        Returns
        -------
        prisma.models.TransaksiHarian
            The found TransaksiHarian record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transaksiharian = await TransaksiHarian.prisma().find_unique_or_raise(
            where={
                'id': 'bcjihiaide',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransaksiHarianWhereInput] = None,
        cursor: Optional[types.TransaksiHarianWhereUniqueInput] = None,
        include: Optional[types.TransaksiHarianInclude] = None,
        order: Optional[Union[types.TransaksiHarianOrderByInput, List[types.TransaksiHarianOrderByInput]]] = None,
        distinct: Optional[List[types.TransaksiHarianScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple TransaksiHarian records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of TransaksiHarian records returned
        skip
            Ignore the first N results
        where
            TransaksiHarian filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TransaksiHarian model
        order
            Order the returned TransaksiHarian records by any field
        distinct
            Filter TransaksiHarian records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.TransaksiHarian]
            The list of all TransaksiHarian records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 TransaksiHarian records
        transaksiharians = await TransaksiHarian.prisma().find_many(take=10)

        # find the first 5 TransaksiHarian records ordered by the createdBy field
        transaksiharians = await TransaksiHarian.prisma().find_many(
            take=5,
            order={
                'createdBy': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TransaksiHarianWhereInput] = None,
        cursor: Optional[types.TransaksiHarianWhereUniqueInput] = None,
        include: Optional[types.TransaksiHarianInclude] = None,
        order: Optional[Union[types.TransaksiHarianOrderByInput, List[types.TransaksiHarianOrderByInput]]] = None,
        distinct: Optional[List[types.TransaksiHarianScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single TransaksiHarian record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TransaksiHarian filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TransaksiHarian model
        order
            Order the returned TransaksiHarian records by any field
        distinct
            Filter TransaksiHarian records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TransaksiHarian
            The first TransaksiHarian record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TransaksiHarian record ordered by the actorRole field
        transaksiharian = await TransaksiHarian.prisma().find_first(
            skip=1,
            order={
                'actorRole': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TransaksiHarianWhereInput] = None,
        cursor: Optional[types.TransaksiHarianWhereUniqueInput] = None,
        include: Optional[types.TransaksiHarianInclude] = None,
        order: Optional[Union[types.TransaksiHarianOrderByInput, List[types.TransaksiHarianOrderByInput]]] = None,
        distinct: Optional[List[types.TransaksiHarianScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single TransaksiHarian record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TransaksiHarian filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TransaksiHarian model
        order
            Order the returned TransaksiHarian records by any field
        distinct
            Filter TransaksiHarian records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TransaksiHarian
            The first TransaksiHarian record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TransaksiHarian record ordered by the timestamp field
        transaksiharian = await TransaksiHarian.prisma().find_first_or_raise(
            skip=1,
            order={
                'timestamp': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TransaksiHarianUpdateInput,
        where: types.TransaksiHarianWhereUniqueInput,
        include: Optional[types.TransaksiHarianInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single TransaksiHarian record.

        Parameters
        ----------
        data
            TransaksiHarian record data specifying what to update
        where
            TransaksiHarian filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned TransaksiHarian model

        Returns
        -------
        prisma.models.TransaksiHarian
            The updated TransaksiHarian record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        transaksiharian = await TransaksiHarian.prisma().update(
            where={
                'id': 'bagfijcgfj',
            },
            data={
                # data to update the TransaksiHarian record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TransaksiHarianWhereUniqueInput,
        data: types.TransaksiHarianUpsertInput,
        include: Optional[types.TransaksiHarianInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            TransaksiHarian filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned TransaksiHarian model

        Returns
        -------
        prisma.models.TransaksiHarian
            The created or updated TransaksiHarian record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transaksiharian = await TransaksiHarian.prisma().upsert(
            where={
                'id': 'bcggehiidc',
            },
            data={
                'create': {
                    'id': 'bcggehiidc',
                    'tenantId': 'bfhhjbbdha',
                    'createdBy': 'faehcjfdb',
                    'actorRole': 'bbaiefbee',
                    'timestamp': 15603229260,
                    'jenisTransaksi': 'biibaighec',
                    'payload': Json({'baicdfeidj': True}),
                },
                'update': {
                    'tenantId': 'bfhhjbbdha',
                    'createdBy': 'faehcjfdb',
                    'actorRole': 'bbaiefbee',
                    'timestamp': 15603229260,
                    'jenisTransaksi': 'biibaighec',
                    'payload': Json({'baicdfeidj': True}),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TransaksiHarianUpdateManyMutationInput,
        where: types.TransaksiHarianWhereInput,
    ) -> int:
        """Update multiple TransaksiHarian records

        Parameters
        ----------
        data
            TransaksiHarian data to update the selected TransaksiHarian records to
        where
            Filter to select the TransaksiHarian records to update

        Returns
        -------
        int
            The total number of TransaksiHarian records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all TransaksiHarian records
        total = await TransaksiHarian.prisma().update_many(
            data={
                'jenisTransaksi': 'bjcdacgacf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransaksiHarianWhereInput] = None,
        cursor: Optional[types.TransaksiHarianWhereUniqueInput] = None,
    ) -> int:
        """Count the number of TransaksiHarian records present in the database

        Parameters
        ----------
        select
            Select the TransaksiHarian fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TransaksiHarian filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TransaksiHarianCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TransaksiHarian.prisma().count()

        # results: prisma.types.TransaksiHarianCountAggregateOutput
        results = await TransaksiHarian.prisma().count(
            select={
                '_all': True,
                'payload': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TransaksiHarianCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransaksiHarianWhereInput] = None,
        cursor: Optional[types.TransaksiHarianWhereUniqueInput] = None,
    ) -> types.TransaksiHarianCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TransaksiHarianCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransaksiHarianWhereInput] = None,
        cursor: Optional[types.TransaksiHarianWhereUniqueInput] = None,
    ) -> Union[int, types.TransaksiHarianCountAggregateOutput]:
        """Count the number of TransaksiHarian records present in the database

        Parameters
        ----------
        select
            Select the TransaksiHarian fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TransaksiHarian filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TransaksiHarianCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TransaksiHarian.prisma().count()

        # results: prisma.types.TransaksiHarianCountAggregateOutput
        results = await TransaksiHarian.prisma().count(
            select={
                '_all': True,
                'rawText': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TransaksiHarianCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TransaksiHarianWhereInput] = None
    ) -> int:
        """Delete multiple TransaksiHarian records.

        Parameters
        ----------
        where
            Optional TransaksiHarian filter to find the records to be deleted

        Returns
        -------
        int
            The total number of TransaksiHarian records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all TransaksiHarian records
        total = await TransaksiHarian.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TransaksiHarianScalarFieldKeys'],
        *,
        where: Optional['types.TransaksiHarianWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TransaksiHarianAvgAggregateInput'] = None,
        sum: Optional['types.TransaksiHarianSumAggregateInput'] = None,
        min: Optional['types.TransaksiHarianMinAggregateInput'] = None,
        max: Optional['types.TransaksiHarianMaxAggregateInput'] = None,
        having: Optional['types.TransaksiHarianScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TransaksiHarianCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TransaksiHarianScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TransaksiHarianScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TransaksiHarianGroupByOutput']:
        """Group TransaksiHarian records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar TransaksiHarian fields to group records by
        where
            TransaksiHarian filter to select records
        take
            Limit the maximum number of TransaksiHarian records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TransaksiHarianGroupByOutput]
            A list of dictionaries representing the TransaksiHarian record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group TransaksiHarian records by rawNlu values
        # and count how many records are in each group
        results = await TransaksiHarian.prisma().group_by(
            ['rawNlu'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ItemTransaksiActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ItemTransaksi]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ItemTransaksi.prisma().query_raw(
            'SELECT * FROM ItemTransaksi WHERE id = $1',
            'jfieeahi',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ItemTransaksi
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ItemTransaksi.prisma().query_first(
            'SELECT * FROM ItemTransaksi WHERE transaksiId = $1',
            'bijfjbddfj',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ItemTransaksiCreateInput,
        include: Optional[types.ItemTransaksiInclude] = None
    ) -> _PrismaModelT:
        """Create a new ItemTransaksi record.

        Parameters
        ----------
        data
            ItemTransaksi record data
        include
            Specifies which relations should be loaded on the returned ItemTransaksi model

        Returns
        -------
        prisma.models.ItemTransaksi
            The created ItemTransaksi record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ItemTransaksi record from just the required fields
        itemtransaksi = await ItemTransaksi.prisma().create(
            data={
                # data to create a ItemTransaksi record
                'transaksiId': 'cdcdjdcee',
                'namaProduk': 'bbbgjdbgcb',
                'jumlah': 1243026426.2135,
                'satuan': 'idbcdhbci',
                'hargaSatuan': 12295764876,
                'subtotal': 4972184904,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ItemTransaksiCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ItemTransaksi records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ItemTransaksi record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ItemTransaksi.prisma().create_many(
            data=[
                {
                    # data to create a ItemTransaksi record
                    'transaksiId': 'bajagjdfbb',
                    'namaProduk': 'bggedbjggi',
                    'jumlah': 761058525.149842,
                    'satuan': 'bjgacaeagh',
                    'hargaSatuan': 17290457472,
                    'subtotal': 18187720236,
                },
                {
                    # data to create a ItemTransaksi record
                    'transaksiId': 'jbgheibja',
                    'namaProduk': 'eejajbid',
                    'jumlah': 457323084.203494,
                    'satuan': 'bahjhjjhcc',
                    'hargaSatuan': 5006056260,
                    'subtotal': 16614282912,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ItemTransaksiWhereUniqueInput,
        include: Optional[types.ItemTransaksiInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ItemTransaksi record.

        Parameters
        ----------
        where
            ItemTransaksi filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ItemTransaksi model

        Returns
        -------
        prisma.models.ItemTransaksi
            The deleted ItemTransaksi record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        itemtransaksi = await ItemTransaksi.prisma().delete(
            where={
                'id': 'cheifeghd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ItemTransaksiWhereUniqueInput,
        include: Optional[types.ItemTransaksiInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ItemTransaksi record.

        Parameters
        ----------
        where
            ItemTransaksi filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ItemTransaksi model

        Returns
        -------
        prisma.models.ItemTransaksi
            The found ItemTransaksi record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        itemtransaksi = await ItemTransaksi.prisma().find_unique(
            where={
                'id': 'fgijheefe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ItemTransaksiWhereUniqueInput,
        include: Optional[types.ItemTransaksiInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ItemTransaksi record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ItemTransaksi filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ItemTransaksi model

        Returns
        -------
        prisma.models.ItemTransaksi
            The found ItemTransaksi record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        itemtransaksi = await ItemTransaksi.prisma().find_unique_or_raise(
            where={
                'id': 'hcbgbhfch',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ItemTransaksiWhereInput] = None,
        cursor: Optional[types.ItemTransaksiWhereUniqueInput] = None,
        include: Optional[types.ItemTransaksiInclude] = None,
        order: Optional[Union[types.ItemTransaksiOrderByInput, List[types.ItemTransaksiOrderByInput]]] = None,
        distinct: Optional[List[types.ItemTransaksiScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ItemTransaksi records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ItemTransaksi records returned
        skip
            Ignore the first N results
        where
            ItemTransaksi filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ItemTransaksi model
        order
            Order the returned ItemTransaksi records by any field
        distinct
            Filter ItemTransaksi records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ItemTransaksi]
            The list of all ItemTransaksi records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ItemTransaksi records
        itemtransaksis = await ItemTransaksi.prisma().find_many(take=10)

        # find the first 5 ItemTransaksi records ordered by the namaProduk field
        itemtransaksis = await ItemTransaksi.prisma().find_many(
            take=5,
            order={
                'namaProduk': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ItemTransaksiWhereInput] = None,
        cursor: Optional[types.ItemTransaksiWhereUniqueInput] = None,
        include: Optional[types.ItemTransaksiInclude] = None,
        order: Optional[Union[types.ItemTransaksiOrderByInput, List[types.ItemTransaksiOrderByInput]]] = None,
        distinct: Optional[List[types.ItemTransaksiScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ItemTransaksi record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ItemTransaksi filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ItemTransaksi model
        order
            Order the returned ItemTransaksi records by any field
        distinct
            Filter ItemTransaksi records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ItemTransaksi
            The first ItemTransaksi record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ItemTransaksi record ordered by the kategoriPath field
        itemtransaksi = await ItemTransaksi.prisma().find_first(
            skip=1,
            order={
                'kategoriPath': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ItemTransaksiWhereInput] = None,
        cursor: Optional[types.ItemTransaksiWhereUniqueInput] = None,
        include: Optional[types.ItemTransaksiInclude] = None,
        order: Optional[Union[types.ItemTransaksiOrderByInput, List[types.ItemTransaksiOrderByInput]]] = None,
        distinct: Optional[List[types.ItemTransaksiScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ItemTransaksi record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ItemTransaksi filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ItemTransaksi model
        order
            Order the returned ItemTransaksi records by any field
        distinct
            Filter ItemTransaksi records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ItemTransaksi
            The first ItemTransaksi record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ItemTransaksi record ordered by the level1 field
        itemtransaksi = await ItemTransaksi.prisma().find_first_or_raise(
            skip=1,
            order={
                'level1': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ItemTransaksiUpdateInput,
        where: types.ItemTransaksiWhereUniqueInput,
        include: Optional[types.ItemTransaksiInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ItemTransaksi record.

        Parameters
        ----------
        data
            ItemTransaksi record data specifying what to update
        where
            ItemTransaksi filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ItemTransaksi model

        Returns
        -------
        prisma.models.ItemTransaksi
            The updated ItemTransaksi record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        itemtransaksi = await ItemTransaksi.prisma().update(
            where={
                'id': 'bfbbbgbfhc',
            },
            data={
                # data to update the ItemTransaksi record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ItemTransaksiWhereUniqueInput,
        data: types.ItemTransaksiUpsertInput,
        include: Optional[types.ItemTransaksiInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ItemTransaksi filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ItemTransaksi model

        Returns
        -------
        prisma.models.ItemTransaksi
            The created or updated ItemTransaksi record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        itemtransaksi = await ItemTransaksi.prisma().upsert(
            where={
                'id': 'ibijjdeb',
            },
            data={
                'create': {
                    'id': 'ibijjdeb',
                    'transaksiId': 'jbgheibja',
                    'namaProduk': 'eejajbid',
                    'jumlah': 457323084.203494,
                    'satuan': 'bahjhjjhcc',
                    'hargaSatuan': 5006056260,
                    'subtotal': 16614282912,
                },
                'update': {
                    'transaksiId': 'jbgheibja',
                    'namaProduk': 'eejajbid',
                    'jumlah': 457323084.203494,
                    'satuan': 'bahjhjjhcc',
                    'hargaSatuan': 5006056260,
                    'subtotal': 16614282912,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ItemTransaksiUpdateManyMutationInput,
        where: types.ItemTransaksiWhereInput,
    ) -> int:
        """Update multiple ItemTransaksi records

        Parameters
        ----------
        data
            ItemTransaksi data to update the selected ItemTransaksi records to
        where
            Filter to select the ItemTransaksi records to update

        Returns
        -------
        int
            The total number of ItemTransaksi records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ItemTransaksi records
        total = await ItemTransaksi.prisma().update_many(
            data={
                'level2': 'caehiccddi'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ItemTransaksiWhereInput] = None,
        cursor: Optional[types.ItemTransaksiWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ItemTransaksi records present in the database

        Parameters
        ----------
        select
            Select the ItemTransaksi fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ItemTransaksi filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ItemTransaksiCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ItemTransaksi.prisma().count()

        # results: prisma.types.ItemTransaksiCountAggregateOutput
        results = await ItemTransaksi.prisma().count(
            select={
                '_all': True,
                'level3': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ItemTransaksiCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ItemTransaksiWhereInput] = None,
        cursor: Optional[types.ItemTransaksiWhereUniqueInput] = None,
    ) -> types.ItemTransaksiCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ItemTransaksiCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ItemTransaksiWhereInput] = None,
        cursor: Optional[types.ItemTransaksiWhereUniqueInput] = None,
    ) -> Union[int, types.ItemTransaksiCountAggregateOutput]:
        """Count the number of ItemTransaksi records present in the database

        Parameters
        ----------
        select
            Select the ItemTransaksi fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ItemTransaksi filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ItemTransaksiCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ItemTransaksi.prisma().count()

        # results: prisma.types.ItemTransaksiCountAggregateOutput
        results = await ItemTransaksi.prisma().count(
            select={
                '_all': True,
                'level4': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ItemTransaksiCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ItemTransaksiWhereInput] = None
    ) -> int:
        """Delete multiple ItemTransaksi records.

        Parameters
        ----------
        where
            Optional ItemTransaksi filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ItemTransaksi records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ItemTransaksi records
        total = await ItemTransaksi.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ItemTransaksiScalarFieldKeys'],
        *,
        where: Optional['types.ItemTransaksiWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ItemTransaksiAvgAggregateInput'] = None,
        sum: Optional['types.ItemTransaksiSumAggregateInput'] = None,
        min: Optional['types.ItemTransaksiMinAggregateInput'] = None,
        max: Optional['types.ItemTransaksiMaxAggregateInput'] = None,
        having: Optional['types.ItemTransaksiScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ItemTransaksiCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ItemTransaksiScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ItemTransaksiScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ItemTransaksiGroupByOutput']:
        """Group ItemTransaksi records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ItemTransaksi fields to group records by
        where
            ItemTransaksi filter to select records
        take
            Limit the maximum number of ItemTransaksi records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ItemTransaksiGroupByOutput]
            A list of dictionaries representing the ItemTransaksi record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ItemTransaksi records by jumlah values
        # and count how many records are in each group
        results = await ItemTransaksi.prisma().group_by(
            ['jumlah'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class HppBreakdownActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.HppBreakdown]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await HppBreakdown.prisma().query_raw(
            'SELECT * FROM HppBreakdown WHERE id = $1',
            'bgcahjbafj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.HppBreakdown
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await HppBreakdown.prisma().query_first(
            'SELECT * FROM HppBreakdown WHERE transaksiId = $1',
            'bihhgeihca',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.HppBreakdownCreateInput,
        include: Optional[types.HppBreakdownInclude] = None
    ) -> _PrismaModelT:
        """Create a new HppBreakdown record.

        Parameters
        ----------
        data
            HppBreakdown record data
        include
            Specifies which relations should be loaded on the returned HppBreakdown model

        Returns
        -------
        prisma.models.HppBreakdown
            The created HppBreakdown record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a HppBreakdown record from just the required fields
        hppbreakdown = await HppBreakdown.prisma().create(
            data={
                # data to create a HppBreakdown record
                'transaksiId': 'bdgbfahbef',
                'totalHpp': 6275740584,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.HppBreakdownCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple HppBreakdown records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of HppBreakdown record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await HppBreakdown.prisma().create_many(
            data=[
                {
                    # data to create a HppBreakdown record
                    'transaksiId': 'bdgfdgdaff',
                    'totalHpp': 21916896720,
                },
                {
                    # data to create a HppBreakdown record
                    'transaksiId': 'fajhhafab',
                    'totalHpp': 18578741304,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.HppBreakdownWhereUniqueInput,
        include: Optional[types.HppBreakdownInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single HppBreakdown record.

        Parameters
        ----------
        where
            HppBreakdown filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned HppBreakdown model

        Returns
        -------
        prisma.models.HppBreakdown
            The deleted HppBreakdown record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        hppbreakdown = await HppBreakdown.prisma().delete(
            where={
                'id': 'hciegiihf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.HppBreakdownWhereUniqueInput,
        include: Optional[types.HppBreakdownInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique HppBreakdown record.

        Parameters
        ----------
        where
            HppBreakdown filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned HppBreakdown model

        Returns
        -------
        prisma.models.HppBreakdown
            The found HppBreakdown record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        hppbreakdown = await HppBreakdown.prisma().find_unique(
            where={
                'id': 'bahifjfga',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.HppBreakdownWhereUniqueInput,
        include: Optional[types.HppBreakdownInclude] = None
    ) -> _PrismaModelT:
        """Find a unique HppBreakdown record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            HppBreakdown filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned HppBreakdown model

        Returns
        -------
        prisma.models.HppBreakdown
            The found HppBreakdown record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        hppbreakdown = await HppBreakdown.prisma().find_unique_or_raise(
            where={
                'id': 'baebfehjaf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.HppBreakdownWhereInput] = None,
        cursor: Optional[types.HppBreakdownWhereUniqueInput] = None,
        include: Optional[types.HppBreakdownInclude] = None,
        order: Optional[Union[types.HppBreakdownOrderByInput, List[types.HppBreakdownOrderByInput]]] = None,
        distinct: Optional[List[types.HppBreakdownScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple HppBreakdown records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of HppBreakdown records returned
        skip
            Ignore the first N results
        where
            HppBreakdown filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned HppBreakdown model
        order
            Order the returned HppBreakdown records by any field
        distinct
            Filter HppBreakdown records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.HppBreakdown]
            The list of all HppBreakdown records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 HppBreakdown records
        hppbreakdowns = await HppBreakdown.prisma().find_many(take=10)

        # find the first 5 HppBreakdown records ordered by the biayaBahanBaku field
        hppbreakdowns = await HppBreakdown.prisma().find_many(
            take=5,
            order={
                'biayaBahanBaku': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.HppBreakdownWhereInput] = None,
        cursor: Optional[types.HppBreakdownWhereUniqueInput] = None,
        include: Optional[types.HppBreakdownInclude] = None,
        order: Optional[Union[types.HppBreakdownOrderByInput, List[types.HppBreakdownOrderByInput]]] = None,
        distinct: Optional[List[types.HppBreakdownScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single HppBreakdown record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            HppBreakdown filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned HppBreakdown model
        order
            Order the returned HppBreakdown records by any field
        distinct
            Filter HppBreakdown records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.HppBreakdown
            The first HppBreakdown record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second HppBreakdown record ordered by the biayaTenagaKerja field
        hppbreakdown = await HppBreakdown.prisma().find_first(
            skip=1,
            order={
                'biayaTenagaKerja': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.HppBreakdownWhereInput] = None,
        cursor: Optional[types.HppBreakdownWhereUniqueInput] = None,
        include: Optional[types.HppBreakdownInclude] = None,
        order: Optional[Union[types.HppBreakdownOrderByInput, List[types.HppBreakdownOrderByInput]]] = None,
        distinct: Optional[List[types.HppBreakdownScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single HppBreakdown record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            HppBreakdown filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned HppBreakdown model
        order
            Order the returned HppBreakdown records by any field
        distinct
            Filter HppBreakdown records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.HppBreakdown
            The first HppBreakdown record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second HppBreakdown record ordered by the biayaLainnya field
        hppbreakdown = await HppBreakdown.prisma().find_first_or_raise(
            skip=1,
            order={
                'biayaLainnya': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.HppBreakdownUpdateInput,
        where: types.HppBreakdownWhereUniqueInput,
        include: Optional[types.HppBreakdownInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single HppBreakdown record.

        Parameters
        ----------
        data
            HppBreakdown record data specifying what to update
        where
            HppBreakdown filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned HppBreakdown model

        Returns
        -------
        prisma.models.HppBreakdown
            The updated HppBreakdown record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        hppbreakdown = await HppBreakdown.prisma().update(
            where={
                'id': 'bjchdacjfa',
            },
            data={
                # data to update the HppBreakdown record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.HppBreakdownWhereUniqueInput,
        data: types.HppBreakdownUpsertInput,
        include: Optional[types.HppBreakdownInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            HppBreakdown filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned HppBreakdown model

        Returns
        -------
        prisma.models.HppBreakdown
            The created or updated HppBreakdown record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        hppbreakdown = await HppBreakdown.prisma().upsert(
            where={
                'id': 'fcadcaihb',
            },
            data={
                'create': {
                    'id': 'fcadcaihb',
                    'transaksiId': 'fajhhafab',
                    'totalHpp': 18578741304,
                },
                'update': {
                    'transaksiId': 'fajhhafab',
                    'totalHpp': 18578741304,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.HppBreakdownUpdateManyMutationInput,
        where: types.HppBreakdownWhereInput,
    ) -> int:
        """Update multiple HppBreakdown records

        Parameters
        ----------
        data
            HppBreakdown data to update the selected HppBreakdown records to
        where
            Filter to select the HppBreakdown records to update

        Returns
        -------
        int
            The total number of HppBreakdown records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all HppBreakdown records
        total = await HppBreakdown.prisma().update_many(
            data={
                'totalHpp': 13593799920
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.HppBreakdownWhereInput] = None,
        cursor: Optional[types.HppBreakdownWhereUniqueInput] = None,
    ) -> int:
        """Count the number of HppBreakdown records present in the database

        Parameters
        ----------
        select
            Select the HppBreakdown fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            HppBreakdown filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.HppBreakdownCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await HppBreakdown.prisma().count()

        # results: prisma.types.HppBreakdownCountAggregateOutput
        results = await HppBreakdown.prisma().count(
            select={
                '_all': True,
                'detailJson': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.HppBreakdownCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.HppBreakdownWhereInput] = None,
        cursor: Optional[types.HppBreakdownWhereUniqueInput] = None,
    ) -> types.HppBreakdownCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.HppBreakdownCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.HppBreakdownWhereInput] = None,
        cursor: Optional[types.HppBreakdownWhereUniqueInput] = None,
    ) -> Union[int, types.HppBreakdownCountAggregateOutput]:
        """Count the number of HppBreakdown records present in the database

        Parameters
        ----------
        select
            Select the HppBreakdown fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            HppBreakdown filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.HppBreakdownCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await HppBreakdown.prisma().count()

        # results: prisma.types.HppBreakdownCountAggregateOutput
        results = await HppBreakdown.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.HppBreakdownCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.HppBreakdownWhereInput] = None
    ) -> int:
        """Delete multiple HppBreakdown records.

        Parameters
        ----------
        where
            Optional HppBreakdown filter to find the records to be deleted

        Returns
        -------
        int
            The total number of HppBreakdown records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all HppBreakdown records
        total = await HppBreakdown.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.HppBreakdownScalarFieldKeys'],
        *,
        where: Optional['types.HppBreakdownWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.HppBreakdownAvgAggregateInput'] = None,
        sum: Optional['types.HppBreakdownSumAggregateInput'] = None,
        min: Optional['types.HppBreakdownMinAggregateInput'] = None,
        max: Optional['types.HppBreakdownMaxAggregateInput'] = None,
        having: Optional['types.HppBreakdownScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.HppBreakdownCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.HppBreakdownScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.HppBreakdownScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.HppBreakdownGroupByOutput']:
        """Group HppBreakdown records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar HppBreakdown fields to group records by
        where
            HppBreakdown filter to select records
        take
            Limit the maximum number of HppBreakdown records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.HppBreakdownGroupByOutput]
            A list of dictionaries representing the HppBreakdown record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group HppBreakdown records by updatedAt values
        # and count how many records are in each group
        results = await HppBreakdown.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class InventoryImpactActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.InventoryImpact]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await InventoryImpact.prisma().query_raw(
            'SELECT * FROM InventoryImpact WHERE id = $1',
            'bagbibfheb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.InventoryImpact
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await InventoryImpact.prisma().query_first(
            'SELECT * FROM InventoryImpact WHERE transaksiId = $1',
            'bidgcabjag',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.InventoryImpactCreateInput,
        include: Optional[types.InventoryImpactInclude] = None
    ) -> _PrismaModelT:
        """Create a new InventoryImpact record.

        Parameters
        ----------
        data
            InventoryImpact record data
        include
            Specifies which relations should be loaded on the returned InventoryImpact model

        Returns
        -------
        prisma.models.InventoryImpact
            The created InventoryImpact record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a InventoryImpact record from just the required fields
        inventoryimpact = await InventoryImpact.prisma().create(
            data={
                # data to create a InventoryImpact record
                'transaksiId': 'hechjdjih',
                'isTracked': True,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.InventoryImpactCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple InventoryImpact records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of InventoryImpact record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await InventoryImpact.prisma().create_many(
            data=[
                {
                    # data to create a InventoryImpact record
                    'transaksiId': 'egcidbiab',
                    'isTracked': True,
                },
                {
                    # data to create a InventoryImpact record
                    'transaksiId': 'hiaaaeeeh',
                    'isTracked': True,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.InventoryImpactWhereUniqueInput,
        include: Optional[types.InventoryImpactInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single InventoryImpact record.

        Parameters
        ----------
        where
            InventoryImpact filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned InventoryImpact model

        Returns
        -------
        prisma.models.InventoryImpact
            The deleted InventoryImpact record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        inventoryimpact = await InventoryImpact.prisma().delete(
            where={
                'id': 'jdgefgafd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.InventoryImpactWhereUniqueInput,
        include: Optional[types.InventoryImpactInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique InventoryImpact record.

        Parameters
        ----------
        where
            InventoryImpact filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned InventoryImpact model

        Returns
        -------
        prisma.models.InventoryImpact
            The found InventoryImpact record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        inventoryimpact = await InventoryImpact.prisma().find_unique(
            where={
                'id': 'bhhihbfeac',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.InventoryImpactWhereUniqueInput,
        include: Optional[types.InventoryImpactInclude] = None
    ) -> _PrismaModelT:
        """Find a unique InventoryImpact record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            InventoryImpact filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned InventoryImpact model

        Returns
        -------
        prisma.models.InventoryImpact
            The found InventoryImpact record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        inventoryimpact = await InventoryImpact.prisma().find_unique_or_raise(
            where={
                'id': 'bajegedfhj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InventoryImpactWhereInput] = None,
        cursor: Optional[types.InventoryImpactWhereUniqueInput] = None,
        include: Optional[types.InventoryImpactInclude] = None,
        order: Optional[Union[types.InventoryImpactOrderByInput, List[types.InventoryImpactOrderByInput]]] = None,
        distinct: Optional[List[types.InventoryImpactScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple InventoryImpact records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of InventoryImpact records returned
        skip
            Ignore the first N results
        where
            InventoryImpact filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned InventoryImpact model
        order
            Order the returned InventoryImpact records by any field
        distinct
            Filter InventoryImpact records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.InventoryImpact]
            The list of all InventoryImpact records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 InventoryImpact records
        inventoryimpacts = await InventoryImpact.prisma().find_many(take=10)

        # find the first 5 InventoryImpact records ordered by the isTracked field
        inventoryimpacts = await InventoryImpact.prisma().find_many(
            take=5,
            order={
                'isTracked': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.InventoryImpactWhereInput] = None,
        cursor: Optional[types.InventoryImpactWhereUniqueInput] = None,
        include: Optional[types.InventoryImpactInclude] = None,
        order: Optional[Union[types.InventoryImpactOrderByInput, List[types.InventoryImpactOrderByInput]]] = None,
        distinct: Optional[List[types.InventoryImpactScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single InventoryImpact record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            InventoryImpact filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned InventoryImpact model
        order
            Order the returned InventoryImpact records by any field
        distinct
            Filter InventoryImpact records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.InventoryImpact
            The first InventoryImpact record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second InventoryImpact record ordered by the jenisMovement field
        inventoryimpact = await InventoryImpact.prisma().find_first(
            skip=1,
            order={
                'jenisMovement': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.InventoryImpactWhereInput] = None,
        cursor: Optional[types.InventoryImpactWhereUniqueInput] = None,
        include: Optional[types.InventoryImpactInclude] = None,
        order: Optional[Union[types.InventoryImpactOrderByInput, List[types.InventoryImpactOrderByInput]]] = None,
        distinct: Optional[List[types.InventoryImpactScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single InventoryImpact record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            InventoryImpact filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned InventoryImpact model
        order
            Order the returned InventoryImpact records by any field
        distinct
            Filter InventoryImpact records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.InventoryImpact
            The first InventoryImpact record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second InventoryImpact record ordered by the lokasiGudang field
        inventoryimpact = await InventoryImpact.prisma().find_first_or_raise(
            skip=1,
            order={
                'lokasiGudang': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.InventoryImpactUpdateInput,
        where: types.InventoryImpactWhereUniqueInput,
        include: Optional[types.InventoryImpactInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single InventoryImpact record.

        Parameters
        ----------
        data
            InventoryImpact record data specifying what to update
        where
            InventoryImpact filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned InventoryImpact model

        Returns
        -------
        prisma.models.InventoryImpact
            The updated InventoryImpact record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        inventoryimpact = await InventoryImpact.prisma().update(
            where={
                'id': 'bhfjihjfhg',
            },
            data={
                # data to update the InventoryImpact record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.InventoryImpactWhereUniqueInput,
        data: types.InventoryImpactUpsertInput,
        include: Optional[types.InventoryImpactInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            InventoryImpact filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned InventoryImpact model

        Returns
        -------
        prisma.models.InventoryImpact
            The created or updated InventoryImpact record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        inventoryimpact = await InventoryImpact.prisma().upsert(
            where={
                'id': 'iicaadeeb',
            },
            data={
                'create': {
                    'id': 'iicaadeeb',
                    'transaksiId': 'hiaaaeeeh',
                    'isTracked': True,
                },
                'update': {
                    'transaksiId': 'hiaaaeeeh',
                    'isTracked': True,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.InventoryImpactUpdateManyMutationInput,
        where: types.InventoryImpactWhereInput,
    ) -> int:
        """Update multiple InventoryImpact records

        Parameters
        ----------
        data
            InventoryImpact data to update the selected InventoryImpact records to
        where
            Filter to select the InventoryImpact records to update

        Returns
        -------
        int
            The total number of InventoryImpact records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all InventoryImpact records
        total = await InventoryImpact.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InventoryImpactWhereInput] = None,
        cursor: Optional[types.InventoryImpactWhereUniqueInput] = None,
    ) -> int:
        """Count the number of InventoryImpact records present in the database

        Parameters
        ----------
        select
            Select the InventoryImpact fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            InventoryImpact filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.InventoryImpactCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await InventoryImpact.prisma().count()

        # results: prisma.types.InventoryImpactCountAggregateOutput
        results = await InventoryImpact.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.InventoryImpactCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InventoryImpactWhereInput] = None,
        cursor: Optional[types.InventoryImpactWhereUniqueInput] = None,
    ) -> types.InventoryImpactCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.InventoryImpactCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InventoryImpactWhereInput] = None,
        cursor: Optional[types.InventoryImpactWhereUniqueInput] = None,
    ) -> Union[int, types.InventoryImpactCountAggregateOutput]:
        """Count the number of InventoryImpact records present in the database

        Parameters
        ----------
        select
            Select the InventoryImpact fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            InventoryImpact filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.InventoryImpactCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await InventoryImpact.prisma().count()

        # results: prisma.types.InventoryImpactCountAggregateOutput
        results = await InventoryImpact.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.InventoryImpactCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.InventoryImpactWhereInput] = None
    ) -> int:
        """Delete multiple InventoryImpact records.

        Parameters
        ----------
        where
            Optional InventoryImpact filter to find the records to be deleted

        Returns
        -------
        int
            The total number of InventoryImpact records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all InventoryImpact records
        total = await InventoryImpact.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.InventoryImpactScalarFieldKeys'],
        *,
        where: Optional['types.InventoryImpactWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.InventoryImpactAvgAggregateInput'] = None,
        sum: Optional['types.InventoryImpactSumAggregateInput'] = None,
        min: Optional['types.InventoryImpactMinAggregateInput'] = None,
        max: Optional['types.InventoryImpactMaxAggregateInput'] = None,
        having: Optional['types.InventoryImpactScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.InventoryImpactCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.InventoryImpactScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.InventoryImpactScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.InventoryImpactGroupByOutput']:
        """Group InventoryImpact records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar InventoryImpact fields to group records by
        where
            InventoryImpact filter to select records
        take
            Limit the maximum number of InventoryImpact records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.InventoryImpactGroupByOutput]
            A list of dictionaries representing the InventoryImpact record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group InventoryImpact records by transaksiId values
        # and count how many records are in each group
        results = await InventoryImpact.prisma().group_by(
            ['transaksiId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ItemInventoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ItemInventory]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ItemInventory.prisma().query_raw(
            'SELECT * FROM ItemInventory WHERE id = $1',
            'bigjggdhac',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ItemInventory
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ItemInventory.prisma().query_first(
            'SELECT * FROM ItemInventory WHERE inventoryImpactId = $1',
            'bfdbbbjhad',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ItemInventoryCreateInput,
        include: Optional[types.ItemInventoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new ItemInventory record.

        Parameters
        ----------
        data
            ItemInventory record data
        include
            Specifies which relations should be loaded on the returned ItemInventory model

        Returns
        -------
        prisma.models.ItemInventory
            The created ItemInventory record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ItemInventory record from just the required fields
        iteminventory = await ItemInventory.prisma().create(
            data={
                # data to create a ItemInventory record
                'inventoryImpactId': 'bdibjhdici',
                'produkId': 'bceigehcbd',
                'jumlahMovement': 2047078754.99023,
                'stokSetelah': 1119030192.77042,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ItemInventoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ItemInventory records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ItemInventory record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ItemInventory.prisma().create_many(
            data=[
                {
                    # data to create a ItemInventory record
                    'inventoryImpactId': 'gjjgegdic',
                    'produkId': 'bijbiccd',
                    'jumlahMovement': 2100638428.92785,
                    'stokSetelah': 377375418.34227,
                },
                {
                    # data to create a ItemInventory record
                    'inventoryImpactId': 'bbegbdehci',
                    'produkId': 'bcebgbhhgb',
                    'jumlahMovement': 674650246.73404,
                    'stokSetelah': 338887028.93750,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ItemInventoryWhereUniqueInput,
        include: Optional[types.ItemInventoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ItemInventory record.

        Parameters
        ----------
        where
            ItemInventory filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ItemInventory model

        Returns
        -------
        prisma.models.ItemInventory
            The deleted ItemInventory record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        iteminventory = await ItemInventory.prisma().delete(
            where={
                'id': 'fcbbahcbi',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ItemInventoryWhereUniqueInput,
        include: Optional[types.ItemInventoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ItemInventory record.

        Parameters
        ----------
        where
            ItemInventory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ItemInventory model

        Returns
        -------
        prisma.models.ItemInventory
            The found ItemInventory record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        iteminventory = await ItemInventory.prisma().find_unique(
            where={
                'id': 'edcgchech',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ItemInventoryWhereUniqueInput,
        include: Optional[types.ItemInventoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ItemInventory record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ItemInventory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ItemInventory model

        Returns
        -------
        prisma.models.ItemInventory
            The found ItemInventory record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        iteminventory = await ItemInventory.prisma().find_unique_or_raise(
            where={
                'id': 'bfehccdcge',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ItemInventoryWhereInput] = None,
        cursor: Optional[types.ItemInventoryWhereUniqueInput] = None,
        include: Optional[types.ItemInventoryInclude] = None,
        order: Optional[Union[types.ItemInventoryOrderByInput, List[types.ItemInventoryOrderByInput]]] = None,
        distinct: Optional[List[types.ItemInventoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ItemInventory records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ItemInventory records returned
        skip
            Ignore the first N results
        where
            ItemInventory filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ItemInventory model
        order
            Order the returned ItemInventory records by any field
        distinct
            Filter ItemInventory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ItemInventory]
            The list of all ItemInventory records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ItemInventory records
        iteminventorys = await ItemInventory.prisma().find_many(take=10)

        # find the first 5 ItemInventory records ordered by the produkId field
        iteminventorys = await ItemInventory.prisma().find_many(
            take=5,
            order={
                'produkId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ItemInventoryWhereInput] = None,
        cursor: Optional[types.ItemInventoryWhereUniqueInput] = None,
        include: Optional[types.ItemInventoryInclude] = None,
        order: Optional[Union[types.ItemInventoryOrderByInput, List[types.ItemInventoryOrderByInput]]] = None,
        distinct: Optional[List[types.ItemInventoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ItemInventory record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ItemInventory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ItemInventory model
        order
            Order the returned ItemInventory records by any field
        distinct
            Filter ItemInventory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ItemInventory
            The first ItemInventory record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ItemInventory record ordered by the jumlahMovement field
        iteminventory = await ItemInventory.prisma().find_first(
            skip=1,
            order={
                'jumlahMovement': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ItemInventoryWhereInput] = None,
        cursor: Optional[types.ItemInventoryWhereUniqueInput] = None,
        include: Optional[types.ItemInventoryInclude] = None,
        order: Optional[Union[types.ItemInventoryOrderByInput, List[types.ItemInventoryOrderByInput]]] = None,
        distinct: Optional[List[types.ItemInventoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ItemInventory record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ItemInventory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ItemInventory model
        order
            Order the returned ItemInventory records by any field
        distinct
            Filter ItemInventory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ItemInventory
            The first ItemInventory record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ItemInventory record ordered by the stokSetelah field
        iteminventory = await ItemInventory.prisma().find_first_or_raise(
            skip=1,
            order={
                'stokSetelah': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ItemInventoryUpdateInput,
        where: types.ItemInventoryWhereUniqueInput,
        include: Optional[types.ItemInventoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ItemInventory record.

        Parameters
        ----------
        data
            ItemInventory record data specifying what to update
        where
            ItemInventory filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ItemInventory model

        Returns
        -------
        prisma.models.ItemInventory
            The updated ItemInventory record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        iteminventory = await ItemInventory.prisma().update(
            where={
                'id': 'ehcibdegf',
            },
            data={
                # data to update the ItemInventory record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ItemInventoryWhereUniqueInput,
        data: types.ItemInventoryUpsertInput,
        include: Optional[types.ItemInventoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ItemInventory filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ItemInventory model

        Returns
        -------
        prisma.models.ItemInventory
            The created or updated ItemInventory record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        iteminventory = await ItemInventory.prisma().upsert(
            where={
                'id': 'ebhjifbbi',
            },
            data={
                'create': {
                    'id': 'ebhjifbbi',
                    'inventoryImpactId': 'bbegbdehci',
                    'produkId': 'bcebgbhhgb',
                    'jumlahMovement': 674650246.73404,
                    'stokSetelah': 338887028.93750,
                },
                'update': {
                    'inventoryImpactId': 'bbegbdehci',
                    'produkId': 'bcebgbhhgb',
                    'jumlahMovement': 674650246.73404,
                    'stokSetelah': 338887028.93750,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ItemInventoryUpdateManyMutationInput,
        where: types.ItemInventoryWhereInput,
    ) -> int:
        """Update multiple ItemInventory records

        Parameters
        ----------
        data
            ItemInventory data to update the selected ItemInventory records to
        where
            Filter to select the ItemInventory records to update

        Returns
        -------
        int
            The total number of ItemInventory records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ItemInventory records
        total = await ItemInventory.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ItemInventoryWhereInput] = None,
        cursor: Optional[types.ItemInventoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ItemInventory records present in the database

        Parameters
        ----------
        select
            Select the ItemInventory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ItemInventory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ItemInventoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ItemInventory.prisma().count()

        # results: prisma.types.ItemInventoryCountAggregateOutput
        results = await ItemInventory.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ItemInventoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ItemInventoryWhereInput] = None,
        cursor: Optional[types.ItemInventoryWhereUniqueInput] = None,
    ) -> types.ItemInventoryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ItemInventoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ItemInventoryWhereInput] = None,
        cursor: Optional[types.ItemInventoryWhereUniqueInput] = None,
    ) -> Union[int, types.ItemInventoryCountAggregateOutput]:
        """Count the number of ItemInventory records present in the database

        Parameters
        ----------
        select
            Select the ItemInventory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ItemInventory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ItemInventoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ItemInventory.prisma().count()

        # results: prisma.types.ItemInventoryCountAggregateOutput
        results = await ItemInventory.prisma().count(
            select={
                '_all': True,
                'inventoryImpactId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ItemInventoryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ItemInventoryWhereInput] = None
    ) -> int:
        """Delete multiple ItemInventory records.

        Parameters
        ----------
        where
            Optional ItemInventory filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ItemInventory records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ItemInventory records
        total = await ItemInventory.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ItemInventoryScalarFieldKeys'],
        *,
        where: Optional['types.ItemInventoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ItemInventoryAvgAggregateInput'] = None,
        sum: Optional['types.ItemInventorySumAggregateInput'] = None,
        min: Optional['types.ItemInventoryMinAggregateInput'] = None,
        max: Optional['types.ItemInventoryMaxAggregateInput'] = None,
        having: Optional['types.ItemInventoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ItemInventoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ItemInventoryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ItemInventoryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ItemInventoryGroupByOutput']:
        """Group ItemInventory records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ItemInventory fields to group records by
        where
            ItemInventory filter to select records
        take
            Limit the maximum number of ItemInventory records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ItemInventoryGroupByOutput]
            A list of dictionaries representing the ItemInventory record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ItemInventory records by produkId values
        # and count how many records are in each group
        results = await ItemInventory.prisma().group_by(
            ['produkId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ProductsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Products]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Products.prisma().query_raw(
            'SELECT * FROM Products WHERE id = $1',
            'jaigficdj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Products
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Products.prisma().query_first(
            'SELECT * FROM Products WHERE tenantId = $1',
            'bggcfifgbc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ProductsCreateInput,
        include: Optional[types.ProductsInclude] = None
    ) -> _PrismaModelT:
        """Create a new Products record.

        Parameters
        ----------
        data
            Products record data
        include
            Specifies which relations should be loaded on the returned Products model

        Returns
        -------
        prisma.models.Products
            The created Products record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Products record from just the required fields
        products = await Products.prisma().create(
            data={
                # data to create a Products record
                'tenantId': 'bhidfjibgf',
                'namaProduk': 'fcgdaijha',
                'satuan': 'bbgfajah',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ProductsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Products records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Products record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Products.prisma().create_many(
            data=[
                {
                    # data to create a Products record
                    'tenantId': 'bbaecgicia',
                    'namaProduk': 'hedacahfd',
                    'satuan': 'bhgjecjac',
                },
                {
                    # data to create a Products record
                    'tenantId': 'bfbdieidhf',
                    'namaProduk': 'ffjbdcfia',
                    'satuan': 'hfeidjicb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ProductsWhereUniqueInput,
        include: Optional[types.ProductsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Products record.

        Parameters
        ----------
        where
            Products filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Products model

        Returns
        -------
        prisma.models.Products
            The deleted Products record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        products = await Products.prisma().delete(
            where={
                'id': 'bbfbdccdag',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ProductsWhereUniqueInput,
        include: Optional[types.ProductsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Products record.

        Parameters
        ----------
        where
            Products filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Products model

        Returns
        -------
        prisma.models.Products
            The found Products record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        products = await Products.prisma().find_unique(
            where={
                'id': 'biggefaged',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ProductsWhereUniqueInput,
        include: Optional[types.ProductsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Products record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Products filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Products model

        Returns
        -------
        prisma.models.Products
            The found Products record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        products = await Products.prisma().find_unique_or_raise(
            where={
                'id': 'gfdbeaejg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductsWhereInput] = None,
        cursor: Optional[types.ProductsWhereUniqueInput] = None,
        include: Optional[types.ProductsInclude] = None,
        order: Optional[Union[types.ProductsOrderByInput, List[types.ProductsOrderByInput]]] = None,
        distinct: Optional[List[types.ProductsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Products records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Products records returned
        skip
            Ignore the first N results
        where
            Products filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Products model
        order
            Order the returned Products records by any field
        distinct
            Filter Products records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Products]
            The list of all Products records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Products records
        products = await Products.prisma().find_many(take=10)

        # find the first 5 Products records ordered by the namaProduk field
        products = await Products.prisma().find_many(
            take=5,
            order={
                'namaProduk': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProductsWhereInput] = None,
        cursor: Optional[types.ProductsWhereUniqueInput] = None,
        include: Optional[types.ProductsInclude] = None,
        order: Optional[Union[types.ProductsOrderByInput, List[types.ProductsOrderByInput]]] = None,
        distinct: Optional[List[types.ProductsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Products record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Products filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Products model
        order
            Order the returned Products records by any field
        distinct
            Filter Products records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Products
            The first Products record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Products record ordered by the satuan field
        products = await Products.prisma().find_first(
            skip=1,
            order={
                'satuan': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProductsWhereInput] = None,
        cursor: Optional[types.ProductsWhereUniqueInput] = None,
        include: Optional[types.ProductsInclude] = None,
        order: Optional[Union[types.ProductsOrderByInput, List[types.ProductsOrderByInput]]] = None,
        distinct: Optional[List[types.ProductsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Products record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Products filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Products model
        order
            Order the returned Products records by any field
        distinct
            Filter Products records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Products
            The first Products record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Products record ordered by the kategori field
        products = await Products.prisma().find_first_or_raise(
            skip=1,
            order={
                'kategori': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ProductsUpdateInput,
        where: types.ProductsWhereUniqueInput,
        include: Optional[types.ProductsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Products record.

        Parameters
        ----------
        data
            Products record data specifying what to update
        where
            Products filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Products model

        Returns
        -------
        prisma.models.Products
            The updated Products record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        products = await Products.prisma().update(
            where={
                'id': 'bhacdebcb',
            },
            data={
                # data to update the Products record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ProductsWhereUniqueInput,
        data: types.ProductsUpsertInput,
        include: Optional[types.ProductsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Products filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Products model

        Returns
        -------
        prisma.models.Products
            The created or updated Products record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        products = await Products.prisma().upsert(
            where={
                'id': 'jhffeibhe',
            },
            data={
                'create': {
                    'id': 'jhffeibhe',
                    'tenantId': 'bfbdieidhf',
                    'namaProduk': 'ffjbdcfia',
                    'satuan': 'hfeidjicb',
                },
                'update': {
                    'tenantId': 'bfbdieidhf',
                    'namaProduk': 'ffjbdcfia',
                    'satuan': 'hfeidjicb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ProductsUpdateManyMutationInput,
        where: types.ProductsWhereInput,
    ) -> int:
        """Update multiple Products records

        Parameters
        ----------
        data
            Products data to update the selected Products records to
        where
            Filter to select the Products records to update

        Returns
        -------
        int
            The total number of Products records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Products records
        total = await Products.prisma().update_many(
            data={
                'hargaJual': 808844591.99793
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductsWhereInput] = None,
        cursor: Optional[types.ProductsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Products records present in the database

        Parameters
        ----------
        select
            Select the Products fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Products filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProductsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Products.prisma().count()

        # results: prisma.types.ProductsCountAggregateOutput
        results = await Products.prisma().count(
            select={
                '_all': True,
                'deskripsi': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ProductsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductsWhereInput] = None,
        cursor: Optional[types.ProductsWhereUniqueInput] = None,
    ) -> types.ProductsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ProductsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductsWhereInput] = None,
        cursor: Optional[types.ProductsWhereUniqueInput] = None,
    ) -> Union[int, types.ProductsCountAggregateOutput]:
        """Count the number of Products records present in the database

        Parameters
        ----------
        select
            Select the Products fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Products filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProductsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Products.prisma().count()

        # results: prisma.types.ProductsCountAggregateOutput
        results = await Products.prisma().count(
            select={
                '_all': True,
                'barcode': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ProductsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ProductsWhereInput] = None
    ) -> int:
        """Delete multiple Products records.

        Parameters
        ----------
        where
            Optional Products filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Products records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Products records
        total = await Products.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ProductsScalarFieldKeys'],
        *,
        where: Optional['types.ProductsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ProductsAvgAggregateInput'] = None,
        sum: Optional['types.ProductsSumAggregateInput'] = None,
        min: Optional['types.ProductsMinAggregateInput'] = None,
        max: Optional['types.ProductsMaxAggregateInput'] = None,
        having: Optional['types.ProductsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ProductsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ProductsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ProductsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ProductsGroupByOutput']:
        """Group Products records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Products fields to group records by
        where
            Products filter to select records
        take
            Limit the maximum number of Products records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ProductsGroupByOutput]
            A list of dictionaries representing the Products record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Products records by createdAt values
        # and count how many records are in each group
        results = await Products.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SupplierActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Supplier]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Supplier.prisma().query_raw(
            'SELECT * FROM Supplier WHERE id = $1',
            'bhhjcfadhd',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Supplier
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Supplier.prisma().query_first(
            'SELECT * FROM Supplier WHERE tenantId = $1',
            'fbejadda',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SupplierCreateInput,
        include: Optional[types.SupplierInclude] = None
    ) -> _PrismaModelT:
        """Create a new Supplier record.

        Parameters
        ----------
        data
            Supplier record data
        include
            Specifies which relations should be loaded on the returned Supplier model

        Returns
        -------
        prisma.models.Supplier
            The created Supplier record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Supplier record from just the required fields
        supplier = await Supplier.prisma().create(
            data={
                # data to create a Supplier record
                'tenantId': 'bjeaigeddb',
                'namaSupplier': 'eceecabdg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SupplierCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Supplier records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Supplier record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Supplier.prisma().create_many(
            data=[
                {
                    # data to create a Supplier record
                    'tenantId': 'bdgaajbcab',
                    'namaSupplier': 'chhgehieg',
                },
                {
                    # data to create a Supplier record
                    'tenantId': 'faggbiggd',
                    'namaSupplier': 'bciijiajei',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SupplierWhereUniqueInput,
        include: Optional[types.SupplierInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Supplier record.

        Parameters
        ----------
        where
            Supplier filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Supplier model

        Returns
        -------
        prisma.models.Supplier
            The deleted Supplier record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        supplier = await Supplier.prisma().delete(
            where={
                'id': 'bdjaadchgf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SupplierWhereUniqueInput,
        include: Optional[types.SupplierInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Supplier record.

        Parameters
        ----------
        where
            Supplier filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Supplier model

        Returns
        -------
        prisma.models.Supplier
            The found Supplier record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        supplier = await Supplier.prisma().find_unique(
            where={
                'id': 'biadfeebhi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SupplierWhereUniqueInput,
        include: Optional[types.SupplierInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Supplier record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Supplier filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Supplier model

        Returns
        -------
        prisma.models.Supplier
            The found Supplier record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        supplier = await Supplier.prisma().find_unique_or_raise(
            where={
                'id': 'biajdcaged',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SupplierWhereInput] = None,
        cursor: Optional[types.SupplierWhereUniqueInput] = None,
        include: Optional[types.SupplierInclude] = None,
        order: Optional[Union[types.SupplierOrderByInput, List[types.SupplierOrderByInput]]] = None,
        distinct: Optional[List[types.SupplierScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Supplier records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Supplier records returned
        skip
            Ignore the first N results
        where
            Supplier filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Supplier model
        order
            Order the returned Supplier records by any field
        distinct
            Filter Supplier records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Supplier]
            The list of all Supplier records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Supplier records
        suppliers = await Supplier.prisma().find_many(take=10)

        # find the first 5 Supplier records ordered by the namaSupplier field
        suppliers = await Supplier.prisma().find_many(
            take=5,
            order={
                'namaSupplier': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SupplierWhereInput] = None,
        cursor: Optional[types.SupplierWhereUniqueInput] = None,
        include: Optional[types.SupplierInclude] = None,
        order: Optional[Union[types.SupplierOrderByInput, List[types.SupplierOrderByInput]]] = None,
        distinct: Optional[List[types.SupplierScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Supplier record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Supplier filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Supplier model
        order
            Order the returned Supplier records by any field
        distinct
            Filter Supplier records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Supplier
            The first Supplier record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Supplier record ordered by the kontak field
        supplier = await Supplier.prisma().find_first(
            skip=1,
            order={
                'kontak': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SupplierWhereInput] = None,
        cursor: Optional[types.SupplierWhereUniqueInput] = None,
        include: Optional[types.SupplierInclude] = None,
        order: Optional[Union[types.SupplierOrderByInput, List[types.SupplierOrderByInput]]] = None,
        distinct: Optional[List[types.SupplierScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Supplier record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Supplier filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Supplier model
        order
            Order the returned Supplier records by any field
        distinct
            Filter Supplier records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Supplier
            The first Supplier record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Supplier record ordered by the alamat field
        supplier = await Supplier.prisma().find_first_or_raise(
            skip=1,
            order={
                'alamat': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SupplierUpdateInput,
        where: types.SupplierWhereUniqueInput,
        include: Optional[types.SupplierInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Supplier record.

        Parameters
        ----------
        data
            Supplier record data specifying what to update
        where
            Supplier filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Supplier model

        Returns
        -------
        prisma.models.Supplier
            The updated Supplier record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        supplier = await Supplier.prisma().update(
            where={
                'id': 'ddgjjicai',
            },
            data={
                # data to update the Supplier record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SupplierWhereUniqueInput,
        data: types.SupplierUpsertInput,
        include: Optional[types.SupplierInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Supplier filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Supplier model

        Returns
        -------
        prisma.models.Supplier
            The created or updated Supplier record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        supplier = await Supplier.prisma().upsert(
            where={
                'id': 'efihdjdcb',
            },
            data={
                'create': {
                    'id': 'efihdjdcb',
                    'tenantId': 'faggbiggd',
                    'namaSupplier': 'bciijiajei',
                },
                'update': {
                    'tenantId': 'faggbiggd',
                    'namaSupplier': 'bciijiajei',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SupplierUpdateManyMutationInput,
        where: types.SupplierWhereInput,
    ) -> int:
        """Update multiple Supplier records

        Parameters
        ----------
        data
            Supplier data to update the selected Supplier records to
        where
            Filter to select the Supplier records to update

        Returns
        -------
        int
            The total number of Supplier records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Supplier records
        total = await Supplier.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SupplierWhereInput] = None,
        cursor: Optional[types.SupplierWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Supplier records present in the database

        Parameters
        ----------
        select
            Select the Supplier fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Supplier filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SupplierCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Supplier.prisma().count()

        # results: prisma.types.SupplierCountAggregateOutput
        results = await Supplier.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SupplierCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SupplierWhereInput] = None,
        cursor: Optional[types.SupplierWhereUniqueInput] = None,
    ) -> types.SupplierCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SupplierCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SupplierWhereInput] = None,
        cursor: Optional[types.SupplierWhereUniqueInput] = None,
    ) -> Union[int, types.SupplierCountAggregateOutput]:
        """Count the number of Supplier records present in the database

        Parameters
        ----------
        select
            Select the Supplier fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Supplier filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SupplierCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Supplier.prisma().count()

        # results: prisma.types.SupplierCountAggregateOutput
        results = await Supplier.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SupplierCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SupplierWhereInput] = None
    ) -> int:
        """Delete multiple Supplier records.

        Parameters
        ----------
        where
            Optional Supplier filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Supplier records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Supplier records
        total = await Supplier.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SupplierScalarFieldKeys'],
        *,
        where: Optional['types.SupplierWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SupplierAvgAggregateInput'] = None,
        sum: Optional['types.SupplierSumAggregateInput'] = None,
        min: Optional['types.SupplierMinAggregateInput'] = None,
        max: Optional['types.SupplierMaxAggregateInput'] = None,
        having: Optional['types.SupplierScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SupplierCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SupplierScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SupplierScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SupplierGroupByOutput']:
        """Group Supplier records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Supplier fields to group records by
        where
            Supplier filter to select records
        take
            Limit the maximum number of Supplier records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SupplierGroupByOutput]
            A list of dictionaries representing the Supplier record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Supplier records by tenantId values
        # and count how many records are in each group
        results = await Supplier.prisma().group_by(
            ['tenantId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PersediaanActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Persediaan]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Persediaan.prisma().query_raw(
            'SELECT * FROM Persediaan WHERE id = $1',
            'bdeacajaig',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Persediaan
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Persediaan.prisma().query_first(
            'SELECT * FROM Persediaan WHERE tenantId = $1',
            'jddggchfb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PersediaanCreateInput,
        include: Optional[types.PersediaanInclude] = None
    ) -> _PrismaModelT:
        """Create a new Persediaan record.

        Parameters
        ----------
        data
            Persediaan record data
        include
            Specifies which relations should be loaded on the returned Persediaan model

        Returns
        -------
        prisma.models.Persediaan
            The created Persediaan record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Persediaan record from just the required fields
        persediaan = await Persediaan.prisma().create(
            data={
                # data to create a Persediaan record
                'tenantId': 'bccbfcfdfg',
                'productId': 'bjchjgjib',
                'lokasiGudang': 'ibiaaifcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PersediaanCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Persediaan records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Persediaan record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Persediaan.prisma().create_many(
            data=[
                {
                    # data to create a Persediaan record
                    'tenantId': 'bffejbbadf',
                    'productId': 'bajgjiebfc',
                    'lokasiGudang': 'bhahahadif',
                },
                {
                    # data to create a Persediaan record
                    'tenantId': 'bijhaihbcg',
                    'productId': 'cbgcjeecd',
                    'lokasiGudang': 'bebibighfg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PersediaanWhereUniqueInput,
        include: Optional[types.PersediaanInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Persediaan record.

        Parameters
        ----------
        where
            Persediaan filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Persediaan model

        Returns
        -------
        prisma.models.Persediaan
            The deleted Persediaan record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        persediaan = await Persediaan.prisma().delete(
            where={
                'id': 'bbhjeejidh',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PersediaanWhereUniqueInput,
        include: Optional[types.PersediaanInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Persediaan record.

        Parameters
        ----------
        where
            Persediaan filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Persediaan model

        Returns
        -------
        prisma.models.Persediaan
            The found Persediaan record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        persediaan = await Persediaan.prisma().find_unique(
            where={
                'id': 'bfgebdfefi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PersediaanWhereUniqueInput,
        include: Optional[types.PersediaanInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Persediaan record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Persediaan filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Persediaan model

        Returns
        -------
        prisma.models.Persediaan
            The found Persediaan record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        persediaan = await Persediaan.prisma().find_unique_or_raise(
            where={
                'id': 'jgijgagjb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PersediaanWhereInput] = None,
        cursor: Optional[types.PersediaanWhereUniqueInput] = None,
        include: Optional[types.PersediaanInclude] = None,
        order: Optional[Union[types.PersediaanOrderByInput, List[types.PersediaanOrderByInput]]] = None,
        distinct: Optional[List[types.PersediaanScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Persediaan records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Persediaan records returned
        skip
            Ignore the first N results
        where
            Persediaan filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Persediaan model
        order
            Order the returned Persediaan records by any field
        distinct
            Filter Persediaan records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Persediaan]
            The list of all Persediaan records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Persediaan records
        persediaans = await Persediaan.prisma().find_many(take=10)

        # find the first 5 Persediaan records ordered by the productId field
        persediaans = await Persediaan.prisma().find_many(
            take=5,
            order={
                'productId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PersediaanWhereInput] = None,
        cursor: Optional[types.PersediaanWhereUniqueInput] = None,
        include: Optional[types.PersediaanInclude] = None,
        order: Optional[Union[types.PersediaanOrderByInput, List[types.PersediaanOrderByInput]]] = None,
        distinct: Optional[List[types.PersediaanScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Persediaan record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Persediaan filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Persediaan model
        order
            Order the returned Persediaan records by any field
        distinct
            Filter Persediaan records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Persediaan
            The first Persediaan record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Persediaan record ordered by the lokasiGudang field
        persediaan = await Persediaan.prisma().find_first(
            skip=1,
            order={
                'lokasiGudang': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PersediaanWhereInput] = None,
        cursor: Optional[types.PersediaanWhereUniqueInput] = None,
        include: Optional[types.PersediaanInclude] = None,
        order: Optional[Union[types.PersediaanOrderByInput, List[types.PersediaanOrderByInput]]] = None,
        distinct: Optional[List[types.PersediaanScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Persediaan record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Persediaan filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Persediaan model
        order
            Order the returned Persediaan records by any field
        distinct
            Filter Persediaan records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Persediaan
            The first Persediaan record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Persediaan record ordered by the jumlah field
        persediaan = await Persediaan.prisma().find_first_or_raise(
            skip=1,
            order={
                'jumlah': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PersediaanUpdateInput,
        where: types.PersediaanWhereUniqueInput,
        include: Optional[types.PersediaanInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Persediaan record.

        Parameters
        ----------
        data
            Persediaan record data specifying what to update
        where
            Persediaan filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Persediaan model

        Returns
        -------
        prisma.models.Persediaan
            The updated Persediaan record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        persediaan = await Persediaan.prisma().update(
            where={
                'id': 'biagjfcfga',
            },
            data={
                # data to update the Persediaan record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PersediaanWhereUniqueInput,
        data: types.PersediaanUpsertInput,
        include: Optional[types.PersediaanInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Persediaan filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Persediaan model

        Returns
        -------
        prisma.models.Persediaan
            The created or updated Persediaan record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        persediaan = await Persediaan.prisma().upsert(
            where={
                'id': 'bggbhejccf',
            },
            data={
                'create': {
                    'id': 'bggbhejccf',
                    'tenantId': 'bijhaihbcg',
                    'productId': 'cbgcjeecd',
                    'lokasiGudang': 'bebibighfg',
                },
                'update': {
                    'tenantId': 'bijhaihbcg',
                    'productId': 'cbgcjeecd',
                    'lokasiGudang': 'bebibighfg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PersediaanUpdateManyMutationInput,
        where: types.PersediaanWhereInput,
    ) -> int:
        """Update multiple Persediaan records

        Parameters
        ----------
        data
            Persediaan data to update the selected Persediaan records to
        where
            Filter to select the Persediaan records to update

        Returns
        -------
        int
            The total number of Persediaan records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Persediaan records
        total = await Persediaan.prisma().update_many(
            data={
                'nilaiPerUnit': 827968622.178846
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PersediaanWhereInput] = None,
        cursor: Optional[types.PersediaanWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Persediaan records present in the database

        Parameters
        ----------
        select
            Select the Persediaan fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Persediaan filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PersediaanCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Persediaan.prisma().count()

        # results: prisma.types.PersediaanCountAggregateOutput
        results = await Persediaan.prisma().count(
            select={
                '_all': True,
                'totalNilai': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PersediaanCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PersediaanWhereInput] = None,
        cursor: Optional[types.PersediaanWhereUniqueInput] = None,
    ) -> types.PersediaanCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PersediaanCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PersediaanWhereInput] = None,
        cursor: Optional[types.PersediaanWhereUniqueInput] = None,
    ) -> Union[int, types.PersediaanCountAggregateOutput]:
        """Count the number of Persediaan records present in the database

        Parameters
        ----------
        select
            Select the Persediaan fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Persediaan filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PersediaanCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Persediaan.prisma().count()

        # results: prisma.types.PersediaanCountAggregateOutput
        results = await Persediaan.prisma().count(
            select={
                '_all': True,
                'lastMovementAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PersediaanCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PersediaanWhereInput] = None
    ) -> int:
        """Delete multiple Persediaan records.

        Parameters
        ----------
        where
            Optional Persediaan filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Persediaan records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Persediaan records
        total = await Persediaan.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PersediaanScalarFieldKeys'],
        *,
        where: Optional['types.PersediaanWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PersediaanAvgAggregateInput'] = None,
        sum: Optional['types.PersediaanSumAggregateInput'] = None,
        min: Optional['types.PersediaanMinAggregateInput'] = None,
        max: Optional['types.PersediaanMaxAggregateInput'] = None,
        having: Optional['types.PersediaanScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PersediaanCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PersediaanScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.PersediaanScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.PersediaanGroupByOutput']:
        """Group Persediaan records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Persediaan fields to group records by
        where
            Persediaan filter to select records
        take
            Limit the maximum number of Persediaan records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PersediaanGroupByOutput]
            A list of dictionaries representing the Persediaan record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Persediaan records by minimumStock values
        # and count how many records are in each group
        results = await Persediaan.prisma().group_by(
            ['minimumStock'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class OutboxActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Outbox]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Outbox.prisma().query_raw(
            'SELECT * FROM Outbox WHERE id = $1',
            'bdegidheae',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Outbox
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Outbox.prisma().query_first(
            'SELECT * FROM Outbox WHERE transaksiId = $1',
            'bddbbjidhd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.OutboxCreateInput,
        include: Optional[types.OutboxInclude] = None
    ) -> _PrismaModelT:
        """Create a new Outbox record.

        Parameters
        ----------
        data
            Outbox record data
        include
            Specifies which relations should be loaded on the returned Outbox model

        Returns
        -------
        prisma.models.Outbox
            The created Outbox record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Outbox record from just the required fields
        outbox = await Outbox.prisma().create(
            data={
                # data to create a Outbox record
                'transaksiId': 'jefedjaji',
                'eventType': 'eicbgeabb',
                'payload': Json({'fchjhjjbc': True}),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.OutboxCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Outbox records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Outbox record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Outbox.prisma().create_many(
            data=[
                {
                    # data to create a Outbox record
                    'transaksiId': 'bagfajdjcb',
                    'eventType': 'bddhgfeaig',
                    'payload': Json({'bfgchaiff': True}),
                },
                {
                    # data to create a Outbox record
                    'transaksiId': 'cifcjfbfg',
                    'eventType': 'bdcjigjhd',
                    'payload': Json({'bfefdahgac': True}),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.OutboxWhereUniqueInput,
        include: Optional[types.OutboxInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Outbox record.

        Parameters
        ----------
        where
            Outbox filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Outbox model

        Returns
        -------
        prisma.models.Outbox
            The deleted Outbox record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        outbox = await Outbox.prisma().delete(
            where={
                'id': 'bichcieged',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.OutboxWhereUniqueInput,
        include: Optional[types.OutboxInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Outbox record.

        Parameters
        ----------
        where
            Outbox filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Outbox model

        Returns
        -------
        prisma.models.Outbox
            The found Outbox record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        outbox = await Outbox.prisma().find_unique(
            where={
                'id': 'caijedigce',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.OutboxWhereUniqueInput,
        include: Optional[types.OutboxInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Outbox record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Outbox filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Outbox model

        Returns
        -------
        prisma.models.Outbox
            The found Outbox record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        outbox = await Outbox.prisma().find_unique_or_raise(
            where={
                'id': 'bebebdfbcj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OutboxWhereInput] = None,
        cursor: Optional[types.OutboxWhereUniqueInput] = None,
        include: Optional[types.OutboxInclude] = None,
        order: Optional[Union[types.OutboxOrderByInput, List[types.OutboxOrderByInput]]] = None,
        distinct: Optional[List[types.OutboxScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Outbox records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Outbox records returned
        skip
            Ignore the first N results
        where
            Outbox filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Outbox model
        order
            Order the returned Outbox records by any field
        distinct
            Filter Outbox records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Outbox]
            The list of all Outbox records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Outbox records
        outboxs = await Outbox.prisma().find_many(take=10)

        # find the first 5 Outbox records ordered by the eventType field
        outboxs = await Outbox.prisma().find_many(
            take=5,
            order={
                'eventType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OutboxWhereInput] = None,
        cursor: Optional[types.OutboxWhereUniqueInput] = None,
        include: Optional[types.OutboxInclude] = None,
        order: Optional[Union[types.OutboxOrderByInput, List[types.OutboxOrderByInput]]] = None,
        distinct: Optional[List[types.OutboxScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Outbox record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Outbox filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Outbox model
        order
            Order the returned Outbox records by any field
        distinct
            Filter Outbox records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Outbox
            The first Outbox record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Outbox record ordered by the payload field
        outbox = await Outbox.prisma().find_first(
            skip=1,
            order={
                'payload': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OutboxWhereInput] = None,
        cursor: Optional[types.OutboxWhereUniqueInput] = None,
        include: Optional[types.OutboxInclude] = None,
        order: Optional[Union[types.OutboxOrderByInput, List[types.OutboxOrderByInput]]] = None,
        distinct: Optional[List[types.OutboxScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Outbox record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Outbox filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Outbox model
        order
            Order the returned Outbox records by any field
        distinct
            Filter Outbox records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Outbox
            The first Outbox record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Outbox record ordered by the processed field
        outbox = await Outbox.prisma().find_first_or_raise(
            skip=1,
            order={
                'processed': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.OutboxUpdateInput,
        where: types.OutboxWhereUniqueInput,
        include: Optional[types.OutboxInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Outbox record.

        Parameters
        ----------
        data
            Outbox record data specifying what to update
        where
            Outbox filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Outbox model

        Returns
        -------
        prisma.models.Outbox
            The updated Outbox record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        outbox = await Outbox.prisma().update(
            where={
                'id': 'caffheehji',
            },
            data={
                # data to update the Outbox record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.OutboxWhereUniqueInput,
        data: types.OutboxUpsertInput,
        include: Optional[types.OutboxInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Outbox filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Outbox model

        Returns
        -------
        prisma.models.Outbox
            The created or updated Outbox record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        outbox = await Outbox.prisma().upsert(
            where={
                'id': 'hfdidadjj',
            },
            data={
                'create': {
                    'id': 'hfdidadjj',
                    'transaksiId': 'cifcjfbfg',
                    'eventType': 'bdcjigjhd',
                    'payload': Json({'bfefdahgac': True}),
                },
                'update': {
                    'transaksiId': 'cifcjfbfg',
                    'eventType': 'bdcjigjhd',
                    'payload': Json({'bfefdahgac': True}),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.OutboxUpdateManyMutationInput,
        where: types.OutboxWhereInput,
    ) -> int:
        """Update multiple Outbox records

        Parameters
        ----------
        data
            Outbox data to update the selected Outbox records to
        where
            Filter to select the Outbox records to update

        Returns
        -------
        int
            The total number of Outbox records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Outbox records
        total = await Outbox.prisma().update_many(
            data={
                'processedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OutboxWhereInput] = None,
        cursor: Optional[types.OutboxWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Outbox records present in the database

        Parameters
        ----------
        select
            Select the Outbox fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Outbox filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OutboxCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Outbox.prisma().count()

        # results: prisma.types.OutboxCountAggregateOutput
        results = await Outbox.prisma().count(
            select={
                '_all': True,
                'retryCount': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.OutboxCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OutboxWhereInput] = None,
        cursor: Optional[types.OutboxWhereUniqueInput] = None,
    ) -> types.OutboxCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.OutboxCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OutboxWhereInput] = None,
        cursor: Optional[types.OutboxWhereUniqueInput] = None,
    ) -> Union[int, types.OutboxCountAggregateOutput]:
        """Count the number of Outbox records present in the database

        Parameters
        ----------
        select
            Select the Outbox fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Outbox filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OutboxCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Outbox.prisma().count()

        # results: prisma.types.OutboxCountAggregateOutput
        results = await Outbox.prisma().count(
            select={
                '_all': True,
                'errorMessage': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.OutboxCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.OutboxWhereInput] = None
    ) -> int:
        """Delete multiple Outbox records.

        Parameters
        ----------
        where
            Optional Outbox filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Outbox records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Outbox records
        total = await Outbox.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.OutboxScalarFieldKeys'],
        *,
        where: Optional['types.OutboxWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.OutboxAvgAggregateInput'] = None,
        sum: Optional['types.OutboxSumAggregateInput'] = None,
        min: Optional['types.OutboxMinAggregateInput'] = None,
        max: Optional['types.OutboxMaxAggregateInput'] = None,
        having: Optional['types.OutboxScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.OutboxCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.OutboxScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.OutboxScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.OutboxGroupByOutput']:
        """Group Outbox records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Outbox fields to group records by
        where
            Outbox filter to select records
        take
            Limit the maximum number of Outbox records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.OutboxGroupByOutput]
            A list of dictionaries representing the Outbox record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Outbox records by createdAt values
        # and count how many records are in each group
        results = await Outbox.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TenantRuleActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.TenantRule]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await TenantRule.prisma().query_raw(
            'SELECT * FROM TenantRule WHERE id = $1',
            'bcdiiadeae',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.TenantRule
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await TenantRule.prisma().query_first(
            'SELECT * FROM TenantRule WHERE tenantId = $1',
            'bdhhaeiaif',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TenantRuleCreateInput,
        include: Optional[types.TenantRuleInclude] = None
    ) -> _PrismaModelT:
        """Create a new TenantRule record.

        Parameters
        ----------
        data
            TenantRule record data
        include
            Specifies which relations should be loaded on the returned TenantRule model

        Returns
        -------
        prisma.models.TenantRule
            The created TenantRule record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a TenantRule record from just the required fields
        tenantrule = await TenantRule.prisma().create(
            data={
                # data to create a TenantRule record
                'tenantId': 'caffgabefa',
                'ruleId': 'bjjajgjbbf',
                'ruleType': 'jdecjdgii',
                'ruleYaml': 'bcgbcdjjfd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TenantRuleCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple TenantRule records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of TenantRule record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await TenantRule.prisma().create_many(
            data=[
                {
                    # data to create a TenantRule record
                    'tenantId': 'bicgfdhjhe',
                    'ruleId': 'ihfjdgceh',
                    'ruleType': 'gdaedbiee',
                    'ruleYaml': 'bibdbbffjh',
                },
                {
                    # data to create a TenantRule record
                    'tenantId': 'bdjfefjjha',
                    'ruleId': 'bjcjfbafeh',
                    'ruleType': 'bchgjchgjg',
                    'ruleYaml': 'idgcdejfd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TenantRuleWhereUniqueInput,
        include: Optional[types.TenantRuleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single TenantRule record.

        Parameters
        ----------
        where
            TenantRule filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned TenantRule model

        Returns
        -------
        prisma.models.TenantRule
            The deleted TenantRule record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tenantrule = await TenantRule.prisma().delete(
            where={
                'id': 'baajcgbaag',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TenantRuleWhereUniqueInput,
        include: Optional[types.TenantRuleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique TenantRule record.

        Parameters
        ----------
        where
            TenantRule filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TenantRule model

        Returns
        -------
        prisma.models.TenantRule
            The found TenantRule record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tenantrule = await TenantRule.prisma().find_unique(
            where={
                'id': 'eahbafhhf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TenantRuleWhereUniqueInput,
        include: Optional[types.TenantRuleInclude] = None
    ) -> _PrismaModelT:
        """Find a unique TenantRule record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            TenantRule filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TenantRule model

        Returns
        -------
        prisma.models.TenantRule
            The found TenantRule record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tenantrule = await TenantRule.prisma().find_unique_or_raise(
            where={
                'id': 'chbgcaajc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TenantRuleWhereInput] = None,
        cursor: Optional[types.TenantRuleWhereUniqueInput] = None,
        include: Optional[types.TenantRuleInclude] = None,
        order: Optional[Union[types.TenantRuleOrderByInput, List[types.TenantRuleOrderByInput]]] = None,
        distinct: Optional[List[types.TenantRuleScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple TenantRule records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of TenantRule records returned
        skip
            Ignore the first N results
        where
            TenantRule filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TenantRule model
        order
            Order the returned TenantRule records by any field
        distinct
            Filter TenantRule records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.TenantRule]
            The list of all TenantRule records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 TenantRule records
        tenantrules = await TenantRule.prisma().find_many(take=10)

        # find the first 5 TenantRule records ordered by the ruleId field
        tenantrules = await TenantRule.prisma().find_many(
            take=5,
            order={
                'ruleId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TenantRuleWhereInput] = None,
        cursor: Optional[types.TenantRuleWhereUniqueInput] = None,
        include: Optional[types.TenantRuleInclude] = None,
        order: Optional[Union[types.TenantRuleOrderByInput, List[types.TenantRuleOrderByInput]]] = None,
        distinct: Optional[List[types.TenantRuleScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single TenantRule record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TenantRule filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TenantRule model
        order
            Order the returned TenantRule records by any field
        distinct
            Filter TenantRule records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TenantRule
            The first TenantRule record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TenantRule record ordered by the ruleType field
        tenantrule = await TenantRule.prisma().find_first(
            skip=1,
            order={
                'ruleType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TenantRuleWhereInput] = None,
        cursor: Optional[types.TenantRuleWhereUniqueInput] = None,
        include: Optional[types.TenantRuleInclude] = None,
        order: Optional[Union[types.TenantRuleOrderByInput, List[types.TenantRuleOrderByInput]]] = None,
        distinct: Optional[List[types.TenantRuleScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single TenantRule record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TenantRule filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TenantRule model
        order
            Order the returned TenantRule records by any field
        distinct
            Filter TenantRule records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TenantRule
            The first TenantRule record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TenantRule record ordered by the ruleYaml field
        tenantrule = await TenantRule.prisma().find_first_or_raise(
            skip=1,
            order={
                'ruleYaml': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TenantRuleUpdateInput,
        where: types.TenantRuleWhereUniqueInput,
        include: Optional[types.TenantRuleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single TenantRule record.

        Parameters
        ----------
        data
            TenantRule record data specifying what to update
        where
            TenantRule filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned TenantRule model

        Returns
        -------
        prisma.models.TenantRule
            The updated TenantRule record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        tenantrule = await TenantRule.prisma().update(
            where={
                'id': 'baafadjcdh',
            },
            data={
                # data to update the TenantRule record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TenantRuleWhereUniqueInput,
        data: types.TenantRuleUpsertInput,
        include: Optional[types.TenantRuleInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            TenantRule filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned TenantRule model

        Returns
        -------
        prisma.models.TenantRule
            The created or updated TenantRule record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tenantrule = await TenantRule.prisma().upsert(
            where={
                'id': 'beihjdafig',
            },
            data={
                'create': {
                    'id': 'beihjdafig',
                    'tenantId': 'bdjfefjjha',
                    'ruleId': 'bjcjfbafeh',
                    'ruleType': 'bchgjchgjg',
                    'ruleYaml': 'idgcdejfd',
                },
                'update': {
                    'tenantId': 'bdjfefjjha',
                    'ruleId': 'bjcjfbafeh',
                    'ruleType': 'bchgjchgjg',
                    'ruleYaml': 'idgcdejfd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TenantRuleUpdateManyMutationInput,
        where: types.TenantRuleWhereInput,
    ) -> int:
        """Update multiple TenantRule records

        Parameters
        ----------
        data
            TenantRule data to update the selected TenantRule records to
        where
            Filter to select the TenantRule records to update

        Returns
        -------
        int
            The total number of TenantRule records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all TenantRule records
        total = await TenantRule.prisma().update_many(
            data={
                'isActive': False
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TenantRuleWhereInput] = None,
        cursor: Optional[types.TenantRuleWhereUniqueInput] = None,
    ) -> int:
        """Count the number of TenantRule records present in the database

        Parameters
        ----------
        select
            Select the TenantRule fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TenantRule filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TenantRuleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TenantRule.prisma().count()

        # results: prisma.types.TenantRuleCountAggregateOutput
        results = await TenantRule.prisma().count(
            select={
                '_all': True,
                'priority': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TenantRuleCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TenantRuleWhereInput] = None,
        cursor: Optional[types.TenantRuleWhereUniqueInput] = None,
    ) -> types.TenantRuleCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TenantRuleCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TenantRuleWhereInput] = None,
        cursor: Optional[types.TenantRuleWhereUniqueInput] = None,
    ) -> Union[int, types.TenantRuleCountAggregateOutput]:
        """Count the number of TenantRule records present in the database

        Parameters
        ----------
        select
            Select the TenantRule fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TenantRule filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TenantRuleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TenantRule.prisma().count()

        # results: prisma.types.TenantRuleCountAggregateOutput
        results = await TenantRule.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TenantRuleCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TenantRuleWhereInput] = None
    ) -> int:
        """Delete multiple TenantRule records.

        Parameters
        ----------
        where
            Optional TenantRule filter to find the records to be deleted

        Returns
        -------
        int
            The total number of TenantRule records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all TenantRule records
        total = await TenantRule.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TenantRuleScalarFieldKeys'],
        *,
        where: Optional['types.TenantRuleWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TenantRuleAvgAggregateInput'] = None,
        sum: Optional['types.TenantRuleSumAggregateInput'] = None,
        min: Optional['types.TenantRuleMinAggregateInput'] = None,
        max: Optional['types.TenantRuleMaxAggregateInput'] = None,
        having: Optional['types.TenantRuleScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TenantRuleCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TenantRuleScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TenantRuleScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TenantRuleGroupByOutput']:
        """Group TenantRule records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar TenantRule fields to group records by
        where
            TenantRule filter to select records
        take
            Limit the maximum number of TenantRule records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TenantRuleGroupByOutput]
            A list of dictionaries representing the TenantRule record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group TenantRule records by updatedAt values
        # and count how many records are in each group
        results = await TenantRule.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TaxInfoActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.TaxInfo]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await TaxInfo.prisma().query_raw(
            'SELECT * FROM TaxInfo WHERE id = $1',
            'bffjafacbg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.TaxInfo
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await TaxInfo.prisma().query_first(
            'SELECT * FROM TaxInfo WHERE tenantId = $1',
            'cbafbcgeab',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TaxInfoCreateInput,
        include: Optional[types.TaxInfoInclude] = None
    ) -> _PrismaModelT:
        """Create a new TaxInfo record.

        Parameters
        ----------
        data
            TaxInfo record data
        include
            Specifies which relations should be loaded on the returned TaxInfo model

        Returns
        -------
        prisma.models.TaxInfo
            The created TaxInfo record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a TaxInfo record from just the required fields
        taxinfo = await TaxInfo.prisma().create(
            data={
                # data to create a TaxInfo record
                'tenantId': 'bedgbciecc',
                'periode': 'bfeehfcihb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TaxInfoCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple TaxInfo records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of TaxInfo record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await TaxInfo.prisma().create_many(
            data=[
                {
                    # data to create a TaxInfo record
                    'tenantId': 'ibagheidg',
                    'periode': 'bibfefchh',
                },
                {
                    # data to create a TaxInfo record
                    'tenantId': 'baeeigbje',
                    'periode': 'fibhgbdb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TaxInfoWhereUniqueInput,
        include: Optional[types.TaxInfoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single TaxInfo record.

        Parameters
        ----------
        where
            TaxInfo filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned TaxInfo model

        Returns
        -------
        prisma.models.TaxInfo
            The deleted TaxInfo record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        taxinfo = await TaxInfo.prisma().delete(
            where={
                'id': 'bbifhfaabg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TaxInfoWhereUniqueInput,
        include: Optional[types.TaxInfoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique TaxInfo record.

        Parameters
        ----------
        where
            TaxInfo filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TaxInfo model

        Returns
        -------
        prisma.models.TaxInfo
            The found TaxInfo record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        taxinfo = await TaxInfo.prisma().find_unique(
            where={
                'id': 'cbbhjdebdh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TaxInfoWhereUniqueInput,
        include: Optional[types.TaxInfoInclude] = None
    ) -> _PrismaModelT:
        """Find a unique TaxInfo record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            TaxInfo filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TaxInfo model

        Returns
        -------
        prisma.models.TaxInfo
            The found TaxInfo record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        taxinfo = await TaxInfo.prisma().find_unique_or_raise(
            where={
                'id': 'hddcfecha',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TaxInfoWhereInput] = None,
        cursor: Optional[types.TaxInfoWhereUniqueInput] = None,
        include: Optional[types.TaxInfoInclude] = None,
        order: Optional[Union[types.TaxInfoOrderByInput, List[types.TaxInfoOrderByInput]]] = None,
        distinct: Optional[List[types.TaxInfoScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple TaxInfo records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of TaxInfo records returned
        skip
            Ignore the first N results
        where
            TaxInfo filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TaxInfo model
        order
            Order the returned TaxInfo records by any field
        distinct
            Filter TaxInfo records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.TaxInfo]
            The list of all TaxInfo records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 TaxInfo records
        taxinfos = await TaxInfo.prisma().find_many(take=10)

        # find the first 5 TaxInfo records ordered by the periode field
        taxinfos = await TaxInfo.prisma().find_many(
            take=5,
            order={
                'periode': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TaxInfoWhereInput] = None,
        cursor: Optional[types.TaxInfoWhereUniqueInput] = None,
        include: Optional[types.TaxInfoInclude] = None,
        order: Optional[Union[types.TaxInfoOrderByInput, List[types.TaxInfoOrderByInput]]] = None,
        distinct: Optional[List[types.TaxInfoScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single TaxInfo record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TaxInfo filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TaxInfo model
        order
            Order the returned TaxInfo records by any field
        distinct
            Filter TaxInfo records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TaxInfo
            The first TaxInfo record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TaxInfo record ordered by the omzetBulanIni field
        taxinfo = await TaxInfo.prisma().find_first(
            skip=1,
            order={
                'omzetBulanIni': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TaxInfoWhereInput] = None,
        cursor: Optional[types.TaxInfoWhereUniqueInput] = None,
        include: Optional[types.TaxInfoInclude] = None,
        order: Optional[Union[types.TaxInfoOrderByInput, List[types.TaxInfoOrderByInput]]] = None,
        distinct: Optional[List[types.TaxInfoScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single TaxInfo record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TaxInfo filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TaxInfo model
        order
            Order the returned TaxInfo records by any field
        distinct
            Filter TaxInfo records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TaxInfo
            The first TaxInfo record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TaxInfo record ordered by the omzetTahunBerjalan field
        taxinfo = await TaxInfo.prisma().find_first_or_raise(
            skip=1,
            order={
                'omzetTahunBerjalan': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TaxInfoUpdateInput,
        where: types.TaxInfoWhereUniqueInput,
        include: Optional[types.TaxInfoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single TaxInfo record.

        Parameters
        ----------
        data
            TaxInfo record data specifying what to update
        where
            TaxInfo filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned TaxInfo model

        Returns
        -------
        prisma.models.TaxInfo
            The updated TaxInfo record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        taxinfo = await TaxInfo.prisma().update(
            where={
                'id': 'bibbehhehb',
            },
            data={
                # data to update the TaxInfo record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TaxInfoWhereUniqueInput,
        data: types.TaxInfoUpsertInput,
        include: Optional[types.TaxInfoInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            TaxInfo filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned TaxInfo model

        Returns
        -------
        prisma.models.TaxInfo
            The created or updated TaxInfo record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        taxinfo = await TaxInfo.prisma().upsert(
            where={
                'id': 'cibfeagfc',
            },
            data={
                'create': {
                    'id': 'cibfeagfc',
                    'tenantId': 'baeeigbje',
                    'periode': 'fibhgbdb',
                },
                'update': {
                    'tenantId': 'baeeigbje',
                    'periode': 'fibhgbdb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TaxInfoUpdateManyMutationInput,
        where: types.TaxInfoWhereInput,
    ) -> int:
        """Update multiple TaxInfo records

        Parameters
        ----------
        data
            TaxInfo data to update the selected TaxInfo records to
        where
            Filter to select the TaxInfo records to update

        Returns
        -------
        int
            The total number of TaxInfo records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all TaxInfo records
        total = await TaxInfo.prisma().update_many(
            data={
                'exceeds500juta': False
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TaxInfoWhereInput] = None,
        cursor: Optional[types.TaxInfoWhereUniqueInput] = None,
    ) -> int:
        """Count the number of TaxInfo records present in the database

        Parameters
        ----------
        select
            Select the TaxInfo fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TaxInfo filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TaxInfoCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TaxInfo.prisma().count()

        # results: prisma.types.TaxInfoCountAggregateOutput
        results = await TaxInfo.prisma().count(
            select={
                '_all': True,
                'exceeds4_8milyar': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TaxInfoCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TaxInfoWhereInput] = None,
        cursor: Optional[types.TaxInfoWhereUniqueInput] = None,
    ) -> types.TaxInfoCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TaxInfoCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TaxInfoWhereInput] = None,
        cursor: Optional[types.TaxInfoWhereUniqueInput] = None,
    ) -> Union[int, types.TaxInfoCountAggregateOutput]:
        """Count the number of TaxInfo records present in the database

        Parameters
        ----------
        select
            Select the TaxInfo fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TaxInfo filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TaxInfoCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TaxInfo.prisma().count()

        # results: prisma.types.TaxInfoCountAggregateOutput
        results = await TaxInfo.prisma().count(
            select={
                '_all': True,
                'pphFinalTerutang': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TaxInfoCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TaxInfoWhereInput] = None
    ) -> int:
        """Delete multiple TaxInfo records.

        Parameters
        ----------
        where
            Optional TaxInfo filter to find the records to be deleted

        Returns
        -------
        int
            The total number of TaxInfo records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all TaxInfo records
        total = await TaxInfo.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TaxInfoScalarFieldKeys'],
        *,
        where: Optional['types.TaxInfoWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TaxInfoAvgAggregateInput'] = None,
        sum: Optional['types.TaxInfoSumAggregateInput'] = None,
        min: Optional['types.TaxInfoMinAggregateInput'] = None,
        max: Optional['types.TaxInfoMaxAggregateInput'] = None,
        having: Optional['types.TaxInfoScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TaxInfoCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TaxInfoScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TaxInfoScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TaxInfoGroupByOutput']:
        """Group TaxInfo records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar TaxInfo fields to group records by
        where
            TaxInfo filter to select records
        take
            Limit the maximum number of TaxInfo records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TaxInfoGroupByOutput]
            A list of dictionaries representing the TaxInfo record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group TaxInfo records by pphFinalTerbayar values
        # and count how many records are in each group
        results = await TaxInfo.prisma().group_by(
            ['pphFinalTerbayar'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class BaganAkunActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.BaganAkun]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await BaganAkun.prisma().query_raw(
            'SELECT * FROM BaganAkun WHERE id = $1',
            'bgjehbiaja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.BaganAkun
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await BaganAkun.prisma().query_first(
            'SELECT * FROM BaganAkun WHERE tenantId = $1',
            'cadgbfjjf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.BaganAkunCreateInput,
        include: Optional[types.BaganAkunInclude] = None
    ) -> _PrismaModelT:
        """Create a new BaganAkun record.

        Parameters
        ----------
        data
            BaganAkun record data
        include
            Specifies which relations should be loaded on the returned BaganAkun model

        Returns
        -------
        prisma.models.BaganAkun
            The created BaganAkun record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a BaganAkun record from just the required fields
        baganakun = await BaganAkun.prisma().create(
            data={
                # data to create a BaganAkun record
                'tenantId': 'bgceeachbc',
                'kodeAkun': 'bbcaehffaf',
                'namaAkun': 'ddbhhchfi',
                'kategori': 'bidbdafbhf',
                'normalBalance': 'caehibbhia',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.BaganAkunCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple BaganAkun records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of BaganAkun record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await BaganAkun.prisma().create_many(
            data=[
                {
                    # data to create a BaganAkun record
                    'tenantId': 'iafgcehej',
                    'kodeAkun': 'bbaeaehiec',
                    'namaAkun': 'cfjghaged',
                    'kategori': 'biggeddiea',
                    'normalBalance': 'biahhhjceb',
                },
                {
                    # data to create a BaganAkun record
                    'tenantId': 'bdjjdgddhe',
                    'kodeAkun': 'cbaaahdbgh',
                    'namaAkun': 'cahhcbdhii',
                    'kategori': 'baibcghaef',
                    'normalBalance': 'dajaaacfa',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.BaganAkunWhereUniqueInput,
        include: Optional[types.BaganAkunInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single BaganAkun record.

        Parameters
        ----------
        where
            BaganAkun filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned BaganAkun model

        Returns
        -------
        prisma.models.BaganAkun
            The deleted BaganAkun record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        baganakun = await BaganAkun.prisma().delete(
            where={
                'id': 'gdibgabah',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.BaganAkunWhereUniqueInput,
        include: Optional[types.BaganAkunInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique BaganAkun record.

        Parameters
        ----------
        where
            BaganAkun filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned BaganAkun model

        Returns
        -------
        prisma.models.BaganAkun
            The found BaganAkun record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        baganakun = await BaganAkun.prisma().find_unique(
            where={
                'id': 'bbdgidjcea',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.BaganAkunWhereUniqueInput,
        include: Optional[types.BaganAkunInclude] = None
    ) -> _PrismaModelT:
        """Find a unique BaganAkun record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            BaganAkun filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned BaganAkun model

        Returns
        -------
        prisma.models.BaganAkun
            The found BaganAkun record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        baganakun = await BaganAkun.prisma().find_unique_or_raise(
            where={
                'id': 'bigggbcjgb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BaganAkunWhereInput] = None,
        cursor: Optional[types.BaganAkunWhereUniqueInput] = None,
        include: Optional[types.BaganAkunInclude] = None,
        order: Optional[Union[types.BaganAkunOrderByInput, List[types.BaganAkunOrderByInput]]] = None,
        distinct: Optional[List[types.BaganAkunScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple BaganAkun records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of BaganAkun records returned
        skip
            Ignore the first N results
        where
            BaganAkun filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned BaganAkun model
        order
            Order the returned BaganAkun records by any field
        distinct
            Filter BaganAkun records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.BaganAkun]
            The list of all BaganAkun records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 BaganAkun records
        baganakuns = await BaganAkun.prisma().find_many(take=10)

        # find the first 5 BaganAkun records ordered by the kodeAkun field
        baganakuns = await BaganAkun.prisma().find_many(
            take=5,
            order={
                'kodeAkun': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BaganAkunWhereInput] = None,
        cursor: Optional[types.BaganAkunWhereUniqueInput] = None,
        include: Optional[types.BaganAkunInclude] = None,
        order: Optional[Union[types.BaganAkunOrderByInput, List[types.BaganAkunOrderByInput]]] = None,
        distinct: Optional[List[types.BaganAkunScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single BaganAkun record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            BaganAkun filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned BaganAkun model
        order
            Order the returned BaganAkun records by any field
        distinct
            Filter BaganAkun records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.BaganAkun
            The first BaganAkun record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second BaganAkun record ordered by the namaAkun field
        baganakun = await BaganAkun.prisma().find_first(
            skip=1,
            order={
                'namaAkun': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BaganAkunWhereInput] = None,
        cursor: Optional[types.BaganAkunWhereUniqueInput] = None,
        include: Optional[types.BaganAkunInclude] = None,
        order: Optional[Union[types.BaganAkunOrderByInput, List[types.BaganAkunOrderByInput]]] = None,
        distinct: Optional[List[types.BaganAkunScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single BaganAkun record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            BaganAkun filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned BaganAkun model
        order
            Order the returned BaganAkun records by any field
        distinct
            Filter BaganAkun records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.BaganAkun
            The first BaganAkun record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second BaganAkun record ordered by the kategori field
        baganakun = await BaganAkun.prisma().find_first_or_raise(
            skip=1,
            order={
                'kategori': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.BaganAkunUpdateInput,
        where: types.BaganAkunWhereUniqueInput,
        include: Optional[types.BaganAkunInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single BaganAkun record.

        Parameters
        ----------
        data
            BaganAkun record data specifying what to update
        where
            BaganAkun filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned BaganAkun model

        Returns
        -------
        prisma.models.BaganAkun
            The updated BaganAkun record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        baganakun = await BaganAkun.prisma().update(
            where={
                'id': 'bfhhaicdhe',
            },
            data={
                # data to update the BaganAkun record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.BaganAkunWhereUniqueInput,
        data: types.BaganAkunUpsertInput,
        include: Optional[types.BaganAkunInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            BaganAkun filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned BaganAkun model

        Returns
        -------
        prisma.models.BaganAkun
            The created or updated BaganAkun record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        baganakun = await BaganAkun.prisma().upsert(
            where={
                'id': 'bgdeigedch',
            },
            data={
                'create': {
                    'id': 'bgdeigedch',
                    'tenantId': 'bdjjdgddhe',
                    'kodeAkun': 'cbaaahdbgh',
                    'namaAkun': 'cahhcbdhii',
                    'kategori': 'baibcghaef',
                    'normalBalance': 'dajaaacfa',
                },
                'update': {
                    'tenantId': 'bdjjdgddhe',
                    'kodeAkun': 'cbaaahdbgh',
                    'namaAkun': 'cahhcbdhii',
                    'kategori': 'baibcghaef',
                    'normalBalance': 'dajaaacfa',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.BaganAkunUpdateManyMutationInput,
        where: types.BaganAkunWhereInput,
    ) -> int:
        """Update multiple BaganAkun records

        Parameters
        ----------
        data
            BaganAkun data to update the selected BaganAkun records to
        where
            Filter to select the BaganAkun records to update

        Returns
        -------
        int
            The total number of BaganAkun records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all BaganAkun records
        total = await BaganAkun.prisma().update_many(
            data={
                'subKategori': 'gedhbbhdc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BaganAkunWhereInput] = None,
        cursor: Optional[types.BaganAkunWhereUniqueInput] = None,
    ) -> int:
        """Count the number of BaganAkun records present in the database

        Parameters
        ----------
        select
            Select the BaganAkun fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            BaganAkun filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BaganAkunCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await BaganAkun.prisma().count()

        # results: prisma.types.BaganAkunCountAggregateOutput
        results = await BaganAkun.prisma().count(
            select={
                '_all': True,
                'normalBalance': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.BaganAkunCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BaganAkunWhereInput] = None,
        cursor: Optional[types.BaganAkunWhereUniqueInput] = None,
    ) -> types.BaganAkunCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.BaganAkunCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BaganAkunWhereInput] = None,
        cursor: Optional[types.BaganAkunWhereUniqueInput] = None,
    ) -> Union[int, types.BaganAkunCountAggregateOutput]:
        """Count the number of BaganAkun records present in the database

        Parameters
        ----------
        select
            Select the BaganAkun fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            BaganAkun filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BaganAkunCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await BaganAkun.prisma().count()

        # results: prisma.types.BaganAkunCountAggregateOutput
        results = await BaganAkun.prisma().count(
            select={
                '_all': True,
                'isActive': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.BaganAkunCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.BaganAkunWhereInput] = None
    ) -> int:
        """Delete multiple BaganAkun records.

        Parameters
        ----------
        where
            Optional BaganAkun filter to find the records to be deleted

        Returns
        -------
        int
            The total number of BaganAkun records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all BaganAkun records
        total = await BaganAkun.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.BaganAkunScalarFieldKeys'],
        *,
        where: Optional['types.BaganAkunWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.BaganAkunAvgAggregateInput'] = None,
        sum: Optional['types.BaganAkunSumAggregateInput'] = None,
        min: Optional['types.BaganAkunMinAggregateInput'] = None,
        max: Optional['types.BaganAkunMaxAggregateInput'] = None,
        having: Optional['types.BaganAkunScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.BaganAkunCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.BaganAkunScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.BaganAkunScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.BaganAkunGroupByOutput']:
        """Group BaganAkun records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar BaganAkun fields to group records by
        where
            BaganAkun filter to select records
        take
            Limit the maximum number of BaganAkun records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.BaganAkunGroupByOutput]
            A list of dictionaries representing the BaganAkun record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group BaganAkun records by parentId values
        # and count how many records are in each group
        results = await BaganAkun.prisma().group_by(
            ['parentId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class JurnalEntryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.JurnalEntry]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await JurnalEntry.prisma().query_raw(
            'SELECT * FROM JurnalEntry WHERE id = $1',
            'bcgcffdgcj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.JurnalEntry
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await JurnalEntry.prisma().query_first(
            'SELECT * FROM JurnalEntry WHERE tenantId = $1',
            'bihjhiiji',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.JurnalEntryCreateInput,
        include: Optional[types.JurnalEntryInclude] = None
    ) -> _PrismaModelT:
        """Create a new JurnalEntry record.

        Parameters
        ----------
        data
            JurnalEntry record data
        include
            Specifies which relations should be loaded on the returned JurnalEntry model

        Returns
        -------
        prisma.models.JurnalEntry
            The created JurnalEntry record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a JurnalEntry record from just the required fields
        jurnalentry = await JurnalEntry.prisma().create(
            data={
                # data to create a JurnalEntry record
                'tenantId': 'ididibbff',
                'nomorJurnal': 'cgbfcibga',
                'tanggalJurnal': 15383528748,
                'totalDebit': 13337222760,
                'totalKredit': 7799678196,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.JurnalEntryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple JurnalEntry records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of JurnalEntry record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await JurnalEntry.prisma().create_many(
            data=[
                {
                    # data to create a JurnalEntry record
                    'tenantId': 'bjfaacchjg',
                    'nomorJurnal': 'beeigdcchh',
                    'tanggalJurnal': 20247391992,
                    'totalDebit': 23866266180,
                    'totalKredit': 20309868960,
                },
                {
                    # data to create a JurnalEntry record
                    'tenantId': 'hifbdafhh',
                    'nomorJurnal': 'bcabicaife',
                    'tanggalJurnal': 9803433108,
                    'totalDebit': 20046400944,
                    'totalKredit': 19300382364,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.JurnalEntryWhereUniqueInput,
        include: Optional[types.JurnalEntryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single JurnalEntry record.

        Parameters
        ----------
        where
            JurnalEntry filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned JurnalEntry model

        Returns
        -------
        prisma.models.JurnalEntry
            The deleted JurnalEntry record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        jurnalentry = await JurnalEntry.prisma().delete(
            where={
                'id': 'bdejjhhggg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.JurnalEntryWhereUniqueInput,
        include: Optional[types.JurnalEntryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique JurnalEntry record.

        Parameters
        ----------
        where
            JurnalEntry filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned JurnalEntry model

        Returns
        -------
        prisma.models.JurnalEntry
            The found JurnalEntry record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        jurnalentry = await JurnalEntry.prisma().find_unique(
            where={
                'id': 'fdahaiafb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.JurnalEntryWhereUniqueInput,
        include: Optional[types.JurnalEntryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique JurnalEntry record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            JurnalEntry filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned JurnalEntry model

        Returns
        -------
        prisma.models.JurnalEntry
            The found JurnalEntry record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        jurnalentry = await JurnalEntry.prisma().find_unique_or_raise(
            where={
                'id': 'bheidchdbc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JurnalEntryWhereInput] = None,
        cursor: Optional[types.JurnalEntryWhereUniqueInput] = None,
        include: Optional[types.JurnalEntryInclude] = None,
        order: Optional[Union[types.JurnalEntryOrderByInput, List[types.JurnalEntryOrderByInput]]] = None,
        distinct: Optional[List[types.JurnalEntryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple JurnalEntry records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of JurnalEntry records returned
        skip
            Ignore the first N results
        where
            JurnalEntry filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned JurnalEntry model
        order
            Order the returned JurnalEntry records by any field
        distinct
            Filter JurnalEntry records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.JurnalEntry]
            The list of all JurnalEntry records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 JurnalEntry records
        jurnalentrys = await JurnalEntry.prisma().find_many(take=10)

        # find the first 5 JurnalEntry records ordered by the transaksiId field
        jurnalentrys = await JurnalEntry.prisma().find_many(
            take=5,
            order={
                'transaksiId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.JurnalEntryWhereInput] = None,
        cursor: Optional[types.JurnalEntryWhereUniqueInput] = None,
        include: Optional[types.JurnalEntryInclude] = None,
        order: Optional[Union[types.JurnalEntryOrderByInput, List[types.JurnalEntryOrderByInput]]] = None,
        distinct: Optional[List[types.JurnalEntryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single JurnalEntry record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            JurnalEntry filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned JurnalEntry model
        order
            Order the returned JurnalEntry records by any field
        distinct
            Filter JurnalEntry records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.JurnalEntry
            The first JurnalEntry record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second JurnalEntry record ordered by the nomorJurnal field
        jurnalentry = await JurnalEntry.prisma().find_first(
            skip=1,
            order={
                'nomorJurnal': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.JurnalEntryWhereInput] = None,
        cursor: Optional[types.JurnalEntryWhereUniqueInput] = None,
        include: Optional[types.JurnalEntryInclude] = None,
        order: Optional[Union[types.JurnalEntryOrderByInput, List[types.JurnalEntryOrderByInput]]] = None,
        distinct: Optional[List[types.JurnalEntryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single JurnalEntry record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            JurnalEntry filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned JurnalEntry model
        order
            Order the returned JurnalEntry records by any field
        distinct
            Filter JurnalEntry records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.JurnalEntry
            The first JurnalEntry record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second JurnalEntry record ordered by the tanggalJurnal field
        jurnalentry = await JurnalEntry.prisma().find_first_or_raise(
            skip=1,
            order={
                'tanggalJurnal': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.JurnalEntryUpdateInput,
        where: types.JurnalEntryWhereUniqueInput,
        include: Optional[types.JurnalEntryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single JurnalEntry record.

        Parameters
        ----------
        data
            JurnalEntry record data specifying what to update
        where
            JurnalEntry filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned JurnalEntry model

        Returns
        -------
        prisma.models.JurnalEntry
            The updated JurnalEntry record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        jurnalentry = await JurnalEntry.prisma().update(
            where={
                'id': 'ddecgfgj',
            },
            data={
                # data to update the JurnalEntry record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.JurnalEntryWhereUniqueInput,
        data: types.JurnalEntryUpsertInput,
        include: Optional[types.JurnalEntryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            JurnalEntry filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned JurnalEntry model

        Returns
        -------
        prisma.models.JurnalEntry
            The created or updated JurnalEntry record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        jurnalentry = await JurnalEntry.prisma().upsert(
            where={
                'id': 'baafhjifec',
            },
            data={
                'create': {
                    'id': 'baafhjifec',
                    'tenantId': 'hifbdafhh',
                    'nomorJurnal': 'bcabicaife',
                    'tanggalJurnal': 9803433108,
                    'totalDebit': 20046400944,
                    'totalKredit': 19300382364,
                },
                'update': {
                    'tenantId': 'hifbdafhh',
                    'nomorJurnal': 'bcabicaife',
                    'tanggalJurnal': 9803433108,
                    'totalDebit': 20046400944,
                    'totalKredit': 19300382364,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.JurnalEntryUpdateManyMutationInput,
        where: types.JurnalEntryWhereInput,
    ) -> int:
        """Update multiple JurnalEntry records

        Parameters
        ----------
        data
            JurnalEntry data to update the selected JurnalEntry records to
        where
            Filter to select the JurnalEntry records to update

        Returns
        -------
        int
            The total number of JurnalEntry records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all JurnalEntry records
        total = await JurnalEntry.prisma().update_many(
            data={
                'keterangan': 'jgbcfighb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JurnalEntryWhereInput] = None,
        cursor: Optional[types.JurnalEntryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of JurnalEntry records present in the database

        Parameters
        ----------
        select
            Select the JurnalEntry fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            JurnalEntry filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.JurnalEntryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await JurnalEntry.prisma().count()

        # results: prisma.types.JurnalEntryCountAggregateOutput
        results = await JurnalEntry.prisma().count(
            select={
                '_all': True,
                'totalDebit': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.JurnalEntryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JurnalEntryWhereInput] = None,
        cursor: Optional[types.JurnalEntryWhereUniqueInput] = None,
    ) -> types.JurnalEntryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.JurnalEntryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JurnalEntryWhereInput] = None,
        cursor: Optional[types.JurnalEntryWhereUniqueInput] = None,
    ) -> Union[int, types.JurnalEntryCountAggregateOutput]:
        """Count the number of JurnalEntry records present in the database

        Parameters
        ----------
        select
            Select the JurnalEntry fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            JurnalEntry filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.JurnalEntryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await JurnalEntry.prisma().count()

        # results: prisma.types.JurnalEntryCountAggregateOutput
        results = await JurnalEntry.prisma().count(
            select={
                '_all': True,
                'totalKredit': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.JurnalEntryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.JurnalEntryWhereInput] = None
    ) -> int:
        """Delete multiple JurnalEntry records.

        Parameters
        ----------
        where
            Optional JurnalEntry filter to find the records to be deleted

        Returns
        -------
        int
            The total number of JurnalEntry records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all JurnalEntry records
        total = await JurnalEntry.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.JurnalEntryScalarFieldKeys'],
        *,
        where: Optional['types.JurnalEntryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.JurnalEntryAvgAggregateInput'] = None,
        sum: Optional['types.JurnalEntrySumAggregateInput'] = None,
        min: Optional['types.JurnalEntryMinAggregateInput'] = None,
        max: Optional['types.JurnalEntryMaxAggregateInput'] = None,
        having: Optional['types.JurnalEntryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.JurnalEntryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.JurnalEntryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.JurnalEntryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.JurnalEntryGroupByOutput']:
        """Group JurnalEntry records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar JurnalEntry fields to group records by
        where
            JurnalEntry filter to select records
        take
            Limit the maximum number of JurnalEntry records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.JurnalEntryGroupByOutput]
            A list of dictionaries representing the JurnalEntry record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group JurnalEntry records by status values
        # and count how many records are in each group
        results = await JurnalEntry.prisma().group_by(
            ['status'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class JurnalDetailActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.JurnalDetail]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await JurnalDetail.prisma().query_raw(
            'SELECT * FROM JurnalDetail WHERE id = $1',
            'bagjdcgfce',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.JurnalDetail
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await JurnalDetail.prisma().query_first(
            'SELECT * FROM JurnalDetail WHERE jurnalEntryId = $1',
            'gjjfcfbij',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.JurnalDetailCreateInput,
        include: Optional[types.JurnalDetailInclude] = None
    ) -> _PrismaModelT:
        """Create a new JurnalDetail record.

        Parameters
        ----------
        data
            JurnalDetail record data
        include
            Specifies which relations should be loaded on the returned JurnalDetail model

        Returns
        -------
        prisma.models.JurnalDetail
            The created JurnalDetail record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a JurnalDetail record from just the required fields
        jurnaldetail = await JurnalDetail.prisma().create(
            data={
                # data to create a JurnalDetail record
                'jurnalEntryId': 'fdejhhede',
                'akunId': 'jfjjgcdbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.JurnalDetailCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple JurnalDetail records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of JurnalDetail record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await JurnalDetail.prisma().create_many(
            data=[
                {
                    # data to create a JurnalDetail record
                    'jurnalEntryId': 'idjjhibfc',
                    'akunId': 'bjgdidgdfd',
                },
                {
                    # data to create a JurnalDetail record
                    'jurnalEntryId': 'bijcbbccda',
                    'akunId': 'baiadjcdfj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.JurnalDetailWhereUniqueInput,
        include: Optional[types.JurnalDetailInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single JurnalDetail record.

        Parameters
        ----------
        where
            JurnalDetail filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned JurnalDetail model

        Returns
        -------
        prisma.models.JurnalDetail
            The deleted JurnalDetail record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        jurnaldetail = await JurnalDetail.prisma().delete(
            where={
                'id': 'eeighihea',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.JurnalDetailWhereUniqueInput,
        include: Optional[types.JurnalDetailInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique JurnalDetail record.

        Parameters
        ----------
        where
            JurnalDetail filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned JurnalDetail model

        Returns
        -------
        prisma.models.JurnalDetail
            The found JurnalDetail record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        jurnaldetail = await JurnalDetail.prisma().find_unique(
            where={
                'id': 'bjgcaahcjd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.JurnalDetailWhereUniqueInput,
        include: Optional[types.JurnalDetailInclude] = None
    ) -> _PrismaModelT:
        """Find a unique JurnalDetail record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            JurnalDetail filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned JurnalDetail model

        Returns
        -------
        prisma.models.JurnalDetail
            The found JurnalDetail record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        jurnaldetail = await JurnalDetail.prisma().find_unique_or_raise(
            where={
                'id': 'eajaedjfe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JurnalDetailWhereInput] = None,
        cursor: Optional[types.JurnalDetailWhereUniqueInput] = None,
        include: Optional[types.JurnalDetailInclude] = None,
        order: Optional[Union[types.JurnalDetailOrderByInput, List[types.JurnalDetailOrderByInput]]] = None,
        distinct: Optional[List[types.JurnalDetailScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple JurnalDetail records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of JurnalDetail records returned
        skip
            Ignore the first N results
        where
            JurnalDetail filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned JurnalDetail model
        order
            Order the returned JurnalDetail records by any field
        distinct
            Filter JurnalDetail records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.JurnalDetail]
            The list of all JurnalDetail records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 JurnalDetail records
        jurnaldetails = await JurnalDetail.prisma().find_many(take=10)

        # find the first 5 JurnalDetail records ordered by the akunId field
        jurnaldetails = await JurnalDetail.prisma().find_many(
            take=5,
            order={
                'akunId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.JurnalDetailWhereInput] = None,
        cursor: Optional[types.JurnalDetailWhereUniqueInput] = None,
        include: Optional[types.JurnalDetailInclude] = None,
        order: Optional[Union[types.JurnalDetailOrderByInput, List[types.JurnalDetailOrderByInput]]] = None,
        distinct: Optional[List[types.JurnalDetailScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single JurnalDetail record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            JurnalDetail filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned JurnalDetail model
        order
            Order the returned JurnalDetail records by any field
        distinct
            Filter JurnalDetail records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.JurnalDetail
            The first JurnalDetail record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second JurnalDetail record ordered by the debit field
        jurnaldetail = await JurnalDetail.prisma().find_first(
            skip=1,
            order={
                'debit': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.JurnalDetailWhereInput] = None,
        cursor: Optional[types.JurnalDetailWhereUniqueInput] = None,
        include: Optional[types.JurnalDetailInclude] = None,
        order: Optional[Union[types.JurnalDetailOrderByInput, List[types.JurnalDetailOrderByInput]]] = None,
        distinct: Optional[List[types.JurnalDetailScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single JurnalDetail record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            JurnalDetail filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned JurnalDetail model
        order
            Order the returned JurnalDetail records by any field
        distinct
            Filter JurnalDetail records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.JurnalDetail
            The first JurnalDetail record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second JurnalDetail record ordered by the kredit field
        jurnaldetail = await JurnalDetail.prisma().find_first_or_raise(
            skip=1,
            order={
                'kredit': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.JurnalDetailUpdateInput,
        where: types.JurnalDetailWhereUniqueInput,
        include: Optional[types.JurnalDetailInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single JurnalDetail record.

        Parameters
        ----------
        data
            JurnalDetail record data specifying what to update
        where
            JurnalDetail filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned JurnalDetail model

        Returns
        -------
        prisma.models.JurnalDetail
            The updated JurnalDetail record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        jurnaldetail = await JurnalDetail.prisma().update(
            where={
                'id': 'diebbdcbj',
            },
            data={
                # data to update the JurnalDetail record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.JurnalDetailWhereUniqueInput,
        data: types.JurnalDetailUpsertInput,
        include: Optional[types.JurnalDetailInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            JurnalDetail filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned JurnalDetail model

        Returns
        -------
        prisma.models.JurnalDetail
            The created or updated JurnalDetail record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        jurnaldetail = await JurnalDetail.prisma().upsert(
            where={
                'id': 'bgbgicefbc',
            },
            data={
                'create': {
                    'id': 'bgbgicefbc',
                    'jurnalEntryId': 'bijcbbccda',
                    'akunId': 'baiadjcdfj',
                },
                'update': {
                    'jurnalEntryId': 'bijcbbccda',
                    'akunId': 'baiadjcdfj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.JurnalDetailUpdateManyMutationInput,
        where: types.JurnalDetailWhereInput,
    ) -> int:
        """Update multiple JurnalDetail records

        Parameters
        ----------
        data
            JurnalDetail data to update the selected JurnalDetail records to
        where
            Filter to select the JurnalDetail records to update

        Returns
        -------
        int
            The total number of JurnalDetail records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all JurnalDetail records
        total = await JurnalDetail.prisma().update_many(
            data={
                'keterangan': 'biefijhhcb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JurnalDetailWhereInput] = None,
        cursor: Optional[types.JurnalDetailWhereUniqueInput] = None,
    ) -> int:
        """Count the number of JurnalDetail records present in the database

        Parameters
        ----------
        select
            Select the JurnalDetail fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            JurnalDetail filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.JurnalDetailCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await JurnalDetail.prisma().count()

        # results: prisma.types.JurnalDetailCountAggregateOutput
        results = await JurnalDetail.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.JurnalDetailCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JurnalDetailWhereInput] = None,
        cursor: Optional[types.JurnalDetailWhereUniqueInput] = None,
    ) -> types.JurnalDetailCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.JurnalDetailCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JurnalDetailWhereInput] = None,
        cursor: Optional[types.JurnalDetailWhereUniqueInput] = None,
    ) -> Union[int, types.JurnalDetailCountAggregateOutput]:
        """Count the number of JurnalDetail records present in the database

        Parameters
        ----------
        select
            Select the JurnalDetail fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            JurnalDetail filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.JurnalDetailCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await JurnalDetail.prisma().count()

        # results: prisma.types.JurnalDetailCountAggregateOutput
        results = await JurnalDetail.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.JurnalDetailCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.JurnalDetailWhereInput] = None
    ) -> int:
        """Delete multiple JurnalDetail records.

        Parameters
        ----------
        where
            Optional JurnalDetail filter to find the records to be deleted

        Returns
        -------
        int
            The total number of JurnalDetail records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all JurnalDetail records
        total = await JurnalDetail.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.JurnalDetailScalarFieldKeys'],
        *,
        where: Optional['types.JurnalDetailWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.JurnalDetailAvgAggregateInput'] = None,
        sum: Optional['types.JurnalDetailSumAggregateInput'] = None,
        min: Optional['types.JurnalDetailMinAggregateInput'] = None,
        max: Optional['types.JurnalDetailMaxAggregateInput'] = None,
        having: Optional['types.JurnalDetailScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.JurnalDetailCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.JurnalDetailScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.JurnalDetailScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.JurnalDetailGroupByOutput']:
        """Group JurnalDetail records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar JurnalDetail fields to group records by
        where
            JurnalDetail filter to select records
        take
            Limit the maximum number of JurnalDetail records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.JurnalDetailGroupByOutput]
            A list of dictionaries representing the JurnalDetail record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group JurnalDetail records by jurnalEntryId values
        # and count how many records are in each group
        results = await JurnalDetail.prisma().group_by(
            ['jurnalEntryId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models