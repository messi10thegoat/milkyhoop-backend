import asyncio
import httpx
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import Optional, Dict, List
import json
import logging
from datetime import datetime

# Import existing services
from backend.api_gateway.app.services.ragcrud_client import RagCrudClient
from backend.api_gateway.app.services.chatbot_client import ChatbotClient
from backend.api_gateway.app.services.ragllm_client import RagLLMClient
from backend.api_gateway.app.services.tenant_client import TenantParserClient
from backend.api_gateway.app.services.intent_client import IntentParserClient
from backend.api_gateway.app.services.complaint_client import ComplaintServiceClient

# ðŸ§  NEW: Import Memory Client for multi-turn conversation
from backend.api_gateway.app.services.memory_client import MemoryClient

logger = logging.getLogger(__name__)
router = APIRouter()

# Request/Response Models
class CustomerChatRequest(BaseModel):
    message: str
    session_id: str

class ChatResponse(BaseModel):
    reply: str
    session_id: str
    conversation_context: Optional[Dict] = None

class ConversationTurn(BaseModel):
    """Structure for conversation history"""
    timestamp: str
    user_message: str
    bot_response: str
    intent: str
    matched_faq: Optional[str] = None
    context_used: bool = False

# ðŸ§  MEMORY-ENHANCED CUSTOMER CHAT ENDPOINT
@router.post("/tenant/{tenant_id}/chat", response_model=ChatResponse)
async def customer_chat_endpoint_with_memory(tenant_id: str, req: CustomerChatRequest):
    """Enhanced customer chat with multi-turn memory and context awareness"""
    
    # Initialize clients
    tenant_parser_client = TenantParserClient()
    rag_crud_client = RagCrudClient()
    memory_client = MemoryClient()
    
    try:
        # ðŸ§  STEP 1: RETRIEVE CONVERSATION HISTORY
        conversation_history = await get_conversation_history(
            memory_client, req.session_id, tenant_id
        )
        
        # ðŸ§  STEP 2: CONTEXT-AWARE INTENT PARSING
        enhanced_message = await enhance_message_with_context(
            req.message, conversation_history
        )
        
        # Parse intent with enhanced context
        parsed = await tenant_parser_client.parse(
            user_id="customer", 
            message=enhanced_message
        )
        
        intent = parsed.get("intent", "general_inquiry")
        entities = parsed.get("entities", {})
        
        logger.info(f"Enhanced query: '{enhanced_message}' | Intent: {intent}")
        
        # ðŸ§  STEP 3: SEMANTIC SEARCH WITH CONTEXT BOOSTING
        response = None
        matched_faq = None
        context_used = False
        
        if intent in ["product_inquiry", "pricing_inquiry", "service_info", "booking_request", "order_request"]:
            search_query = entities.get('FAQ', {}).get('question', enhanced_message)
            matching_faqs = await rag_crud_client.search_documents(tenant_id, search_query, top_k=3)
            
            if matching_faqs and len(matching_faqs) > 0:
                best_match = matching_faqs[0]
                response = best_match.content
                matched_faq = best_match.title
                
                # Check if context was used in matching
                if enhanced_message != req.message:
                    context_used = True
                    
        # Fallback for unmatched queries
        if not response:
            response = await generate_contextual_fallback(
                req.message, conversation_history, tenant_id
            )
        
        # ðŸ§  STEP 4: STORE CONVERSATION TURN IN MEMORY
        conversation_turn = ConversationTurn(
            timestamp=datetime.now().isoformat(),
            user_message=req.message,
            bot_response=response,
            intent=intent,
            matched_faq=matched_faq,
            context_used=context_used
        )
        
        await store_conversation_turn(
            memory_client, req.session_id, tenant_id, conversation_turn
        )
        
        # ðŸ§  STEP 5: RETURN ENHANCED RESPONSE
        return ChatResponse(
            reply=response,
            session_id=req.session_id,
            conversation_context={
                "turns_count": len(conversation_history) + 1,
                "context_used": context_used,
                "matched_faq": matched_faq,
                "intent": intent
            }
        )
        
    except Exception as e:
        logger.error(f"Enhanced chat error: {e}")
        return ChatResponse(
            reply="Maaf, terjadi kesalahan. Silakan coba lagi.",
            session_id=req.session_id
        )

# ðŸ§  HELPER FUNCTIONS FOR MEMORY & CONTEXT

async def get_conversation_history(memory_client: MemoryClient, session_id: str, tenant_id: str) -> List[ConversationTurn]:
    """Retrieve conversation history from memory"""
    try:
        history_data = await memory_client.get_memory(
            user_id=session_id,
            tenant_id=tenant_id,
            key="conversation_history"
        )
        
        if history_data and "turns" in history_data:
            return [ConversationTurn(**turn) for turn in history_data["turns"]]
        
        return []
        
    except Exception as e:
        logger.warning(f"Failed to retrieve conversation history: {e}")
        return []

async def enhance_message_with_context(message: str, history: List[ConversationTurn]) -> str:
    """Enhance user message with context from conversation history"""
    
    # Handle reference resolution
    if any(ref in message.lower() for ref in ["yang tadi", "itu", "tersebut", "yang kemarin"]):
        if len(history) > 0:
            last_turn = history[-1]
            
            # Extract key entities from last conversation
            if last_turn.matched_faq:
                # Add context from last FAQ topic
                enhanced = f"{message} (konteks: {last_turn.matched_faq})"
                return enhanced
            
            # Add context from last user message
            if len(last_turn.user_message) > 10:
                key_terms = extract_key_terms(last_turn.user_message)
                if key_terms:
                    enhanced = f"{message} {' '.join(key_terms)}"
                    return enhanced
    
    # Handle follow-up questions
    if any(followup in message.lower() for followup in ["terus", "lalu", "selanjutnya", "gimana", "bagaimana"]):
        if len(history) > 0:
            last_context = history[-1].user_message
            enhanced = f"{last_context} {message}"
            return enhanced
    
    return message

def extract_key_terms(text: str) -> List[str]:
    """Extract key terms from text for context enhancement"""
    # Simple keyword extraction for context
    key_terms = []
    important_words = ["rekening", "tabungan", "bca", "setoran", "admin", "kartu", "tahapan", "xpresi"]
    
    text_lower = text.lower()
    for word in important_words:
        if word in text_lower:
            key_terms.append(word)
    
    return key_terms[:3]  # Limit to 3 key terms

async def generate_contextual_fallback(message: str, history: List[ConversationTurn], tenant_id: str) -> str:
    """Generate contextual fallback response based on conversation history"""
    
    if len(history) > 0:
        last_intent = history[-1].intent
        
        # Context-aware fallbacks
        if last_intent in ["product_inquiry", "pricing_inquiry"]:
            return f"Untuk informasi lebih detail tentang produk atau harga, silakan hubungi customer service kami. Saya bisa bantu dengan pertanyaan lain yang tersedia di FAQ."
        
        if last_intent == "booking_request":
            return f"Untuk proses pemesanan atau booking, silakan hubungi customer service langsung. Ada yang bisa saya bantu terkait informasi produk?"
    
    # Default fallback
    return "Maaf, informasi yang Anda cari belum tersedia dalam FAQ kami. Untuk bantuan lebih lanjut, silakan hubungi customer service kami."

async def store_conversation_turn(memory_client: MemoryClient, session_id: str, tenant_id: str, turn: ConversationTurn):
    """Store conversation turn in memory with history management"""
    try:
        # Get existing history
        existing_history = await memory_client.get_memory(
            user_id=session_id,
            tenant_id=tenant_id,
            key="conversation_history"
        )
        
        # Initialize or update history
        if existing_history and "turns" in existing_history:
            turns = existing_history["turns"]
        else:
            turns = []
        
        # Add new turn
        turns.append(turn.dict())
        
        # Keep only last 10 turns to prevent memory bloat
        if len(turns) > 10:
            turns = turns[-10:]
        
        # Store updated history
        await memory_client.store_memory(
            user_id=session_id,
            tenant_id=tenant_id,
            key="conversation_history",
            value={"turns": turns, "updated_at": datetime.now().isoformat()},
            ttl=3600  # 1 hour TTL
        )
        
        logger.info(f"Stored conversation turn for session {session_id[:8]}...")
        
    except Exception as e:
        logger.error(f"Failed to store conversation turn: {e}")

# Keep existing endpoints (setup mode, etc.)
# ... (other existing endpoints remain unchanged)

