import asyncio
import httpx
import json
import time
import re
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import Dict, List, Optional, Any

from backend.api_gateway.app.services.ragcrud_client import RagCrudClient
from backend.api_gateway.app.services.chatbot_client import ChatbotClient
from backend.api_gateway.app.services.ragllm_client import RagLLMClient
from backend.api_gateway.app.services.tenant_client import TenantParserClient
from backend.api_gateway.app.services.intent_client import IntentParserClient
from backend.api_gateway.app.services.complaint_client import ComplaintServiceClient

# Level 13 imports - PROPER PROTO ACCESS
import grpc
import sys
sys.path.append('/app/backend/api_gateway/libs')

router = APIRouter()

class ChatRequest(BaseModel):
    user_id: str
    session_id: str
    message: str
    tenant_id: str

class ChatResponse(BaseModel):
    reply: str

class CustomerChatRequest(BaseModel):
    session_id: str = "anonymous"
    message: str

# =====================================================
# LEVEL 13 CONTEXT CLIENT - ALL 22 METHODS
# =====================================================
            
            stub = CustContextServiceStub(channel)
            request = CaptureFeedbackFromConversationRequest(
                session_id=session_id,
                tenant_id=tenant_id
            )
            response = await stub.CaptureFeedbackFromConversation(request)
            await channel.close()
            return {
                'success': response.success,
                'feedback_type': response.feedback_type
            }
        except Exception as e:
            print(f"âš ï¸ CaptureFeedbackFromConversation error: {e}")
            return {'success': False, 'feedback_type': 'none'}


# =====================================================
# HELPER FUNCTIONS
# =====================================================

def detect_message_mood(message: str) -> tuple:
    """Simple mood detection from user message"""
    message_lower = message.lower()
    
    # Frustrated/angry indicators
    if any(word in message_lower for word in ['susah', 'ribet', 'lama', 'mahal', 'sulit', 'rumit', 'lambat', 'gak bisa', 'tidak bisa', 'error', 'gagal']):
        return "frustrated", "negative_keywords_detected"
    
    # Happy/satisfied indicators  
    elif any(word in message_lower for word in ['bagus', 'oke', 'terima kasih', 'makasih', 'mantap', 'keren', 'sip', 'good', 'baik', 'senang']):
        return "satisfied", "positive_keywords_detected"
    
    # Confused/questioning indicators
    elif any(word in message_lower for word in ['gimana', 'bagaimana', 'bingung', 'tidak tahu', 'gak ngerti', 'tidak mengerti', 'tidak paham']):
        return "confused", "question_pattern_detected"
    
    # Urgent/impatient indicators
    elif any(word in message_lower for word in ['cepat', 'urgent', 'penting', 'segera', 'buru-buru', 'sekarang', 'asap']):
        return "urgent", "urgency_keywords_detected"
    
    # Default neutral
    else:
        return "neutral", "no_specific_mood_indicators"

def detect_user_intent(message: str, entities: list) -> str:
    """Intent detection based on message and entities"""
    message_lower = message.lower()
    
    # Product inquiry intents
    if any(entity.get('type') == 'product' for entity in entities):
        if any(word in message_lower for word in ['harga', 'biaya', 'berapa']):
            return "product_pricing_inquiry"
        elif any(word in message_lower for word in ['syarat', 'dokumen', 'requirement']):
            return "product_requirements_inquiry"
        elif any(word in message_lower for word in ['fitur', 'benefit', 'keuntungan']):
            return "product_features_inquiry"
        else:
            return "general_product_inquiry"
    
    # Service-related intents
    elif any(word in message_lower for word in ['buka rekening', 'daftar', 'apply']):
        return "account_opening_intent"
    elif any(word in message_lower for word in ['complaint', 'keluhan', 'masalah']):
        return "complaint_intent"
    elif any(word in message_lower for word in ['lokasi', 'cabang', 'atm']):
        return "location_inquiry"
    
    # Reference resolution intents
    elif any(word in message_lower for word in ['yang itu', 'yang tadi', 'itu']):
        return "reference_resolution_intent"
    
    # Default
    else:
        return "general_inquiry"

def extract_entities_from_content(content: str, query: str) -> list:
    """Extract entities from FAQ content for Level 13 context"""
    entities = []
    
    # Extract product/service mentions
    products = ['tahapan xpresi', 'tahapan bca', 'tabunganku', 'tapres', 'simpel', 'tahapan gold']
    for product in products:
        if product.lower() in content.lower() or product.lower() in query.lower():
            entities.append({
                'type': 'product',
                'name': product.title(),
                'details': {'mentioned_in': 'faq_response', 'turn': 'current'}
            })
    
    # Extract pricing entities
    if any(word in query.lower() for word in ['harga', 'biaya', 'setoran', 'admin']):
        entities.append({
            'type': 'intent', 
            'name': 'pricing_inquiry',
            'details': {'category': 'pricing', 'user_intent': 'price_information'}
        })
    
    return entities

def extract_answer_only(faq_content: str) -> str:
    """Extract only the answer part from FAQ content"""
    if "A:" in faq_content:
        answer_part = faq_content.split("A:", 1)[1].strip()
        return answer_part
    return faq_content

# =====================================================
# MAIN ENDPOINTS
# =====================================================

@router.post("/chat/")
async def chat_endpoint(req: ChatRequest):
    """Setup Mode Chat - Business owner manages chatbot"""
    chatbot_client = ChatbotClient()
    intent_client = IntentParserClient()
    
    try:
        parsed = await intent_client.parse(user_id=req.user_id, reason="message_analysis")
        intent_type = parsed.get("intent_type", "unknown")
        entities = parsed.get("entities", {})
        
        chatbot_response = await chatbot_client.chat(
            req.user_id, req.session_id, req.message, req.tenant_id
        )
        
        return ChatResponse(reply=chatbot_response)
        
    except Exception as e:
        import traceback; traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"gRPC or HTTP call failed: {str(e)}")

@router.post("/tenant/{tenant_id}/chat")
async def customer_chat_endpoint(tenant_id: str, req: CustomerChatRequest):
    """ğŸš€ ENHANCED Customer Mode Chat - WITH CONFIDENCE ENGINE"""
    
    # Performance tracking
    start_time = time.time()
    
    # Initialize clients - ADD TENANT_PARSER CLIENT
    rag_crud_client = RagCrudClient()
    tenant_parser_client = TenantParserClient()  # ğŸ¯ CONFIDENCE ENGINE CLIENT
    
    # Method tracking
    method_results = {}
    confidence_data = {}  # ğŸ¯ CONFIDENCE METADATA
    
    try:
        print(f"\n{'='*60}")
        print(f"ğŸš€ Enhanced Customer Mode - Session: {req.session_id}")
        print(f"ğŸ“ Query: {req.message}")
        print(f"ğŸ¯ Confidence Engine: ACTIVE")
        print(f"{'='*60}")
        
        # ========== PHASE 1: CONTEXT INITIALIZATION ==========
        print("\nğŸ“‚ PHASE 1: Context Initialization")
        
        # Method 1: CreateContext
            session_id=req.session_id,
            tenant_id=tenant_id,
            ttl_seconds=3600
        )
        method_results['CreateContext'] = context_created
        print(f"  1. CreateContext: {'âœ…' if context_created else 'âŒ'}")
        
        # ========== PHASE 2: MOOD & INTENT DETECTION ==========
        print("\nğŸ­ PHASE 2: Mood & Intent Detection")
        
        # Method 7: SetConversationMood
        detected_mood, mood_reason = detect_message_mood(req.message)
            session_id=req.session_id,
            tenant_id=tenant_id,
            mood=detected_mood,
            reason=mood_reason
        )
        print(f"  7. SetConversationMood: {'âœ…' if mood_result.get('success') else 'âŒ'} [{detected_mood}]")
        
        # Extract initial entities
        entities = extract_entities_from_content("", req.message)
        
        # Method 8: TrackUserIntent
        detected_intent = detect_user_intent(req.message, entities)
            session_id=req.session_id,
            tenant_id=tenant_id,
            intent=detected_intent,
            confidence=0.8,
            detected_from="message_content"
        )
        print(f"  8. TrackUserIntent: {'âœ…' if intent_result.get('success') else 'âŒ'} [{detected_intent}]")

        
        # ========== PHASE 3: ENHANCED CONFIDENCE ENGINE PROCESSING ==========
        print("\nğŸ¯ PHASE 3: Enhanced Confidence Engine Processing")
        
        try:
            # ğŸ¯ CALL ENHANCED TENANT_PARSER WITH CONFIDENCE ENGINE
            tenant_parser_response = await tenant_parser_client.parse_customer_query(
            tenant_id=tenant_id,
            message=req.message,
            session_id=req.session_id
        )
            
            print(f"  ğŸš€ Enhanced tenant_parser: âœ… CALLED")
            
            # Parse tenant_parser response
            if tenant_parser_response and isinstance(tenant_parser_response, dict) and 'confidence_metadata' in tenant_parser_response:
                import json
                # Response is already dict, use directly
                parsed_result = tenant_parser_response
                
                # Extract response content
                natural_response = parsed_result.get('answer', 'Informasi tidak tersedia')
                
                # ğŸ¯ EXTRACT CONFIDENCE METADATA
                confidence_metadata = parsed_result.get('confidence_metadata', {})
                if confidence_metadata:
                    confidence_data = {
                        'confidence_score': confidence_metadata.get('confidence_score', 0.0),
                        'route_taken': confidence_metadata.get('route_taken', 'unknown'),
                        'cost_estimate': confidence_metadata.get('cost_estimate', 0.0),
                        'tokens_used': confidence_metadata.get('tokens_used', 0),
                        'optimization_active': confidence_metadata.get('optimization_active', True)
                    }
                    print(f"  ğŸ¯ Confidence Score: {confidence_data['confidence_score']:.3f}")
                    print(f"  ğŸ¯ Route Taken: {confidence_data['route_taken']}")
                    print(f"  ğŸ’° Cost Estimate: Rp {confidence_data['cost_estimate']}")
                else:
                    confidence_data = {
                        'confidence_score': 0.0,
                        'route_taken': 'legacy_fallback',
                        'cost_estimate': 0.0,
                        'tokens_used': 0,
                        'optimization_active': False
                    }
                
                method_results['EnhancedTenantParser'] = True
                
            else:
                print(f"  âœ… Enhanced tenant_parser: SUCCESS")
                # Extract response from tenant_parser
                if isinstance(tenant_parser_response, dict):
                    natural_response = tenant_parser_response.get("answer", "FAQ content tidak ditemukan")
                    confidence_data = {
                        "confidence_score": 0.8,
                        "route_taken": "enhanced_tenant_parser",
                        "cost_estimate": 0.0,
                        "tokens_used": 0,
                        "optimization_active": True
                    }
                else:
                    natural_response = str(tenant_parser_response)
                    confidence_data = {
                        "confidence_score": 0.8,
                        "route_taken": "enhanced_tenant_parser",
                        "cost_estimate": 0.0,
                        "tokens_used": 0,
                        "optimization_active": True
                    }
                method_results["EnhancedTenantParser"] = True
        except Exception as e:
            print(f"  âŒ Enhanced tenant_parser error: {str(e)}")
            # Fallback to original FAQ search if enhanced engine fails
            print("\nğŸ“š FALLBACK: Direct FAQ Search")
            
            search_results = await rag_crud_client.search_documents(
                tenant_id=tenant_id,
                query=req.message,
                limit=3
            )
            
            if search_results and len(search_results) > 0:
                best_result = search_results[0]
                natural_response = extract_answer_from_faq(best_result.get('content', ''))
            else:
                natural_response = f"Maaf, informasi yang Anda cari untuk {tenant_id} belum tersedia saat ini."
            
            confidence_data = {
                'confidence_score': 0.0,
                'route_taken': 'fallback_faq',
                'cost_estimate': 0.0,
                'tokens_used': 0,
                'optimization_active': False
            }
            method_results['EnhancedTenantParser'] = False
        
        # ========== PHASE 4: CONTEXT UPDATE & RESPONSE ==========
        print("\nğŸ“ PHASE 4: Context Update & Response")
        
        # Method 2: UpdateContext
            session_id=req.session_id,
            tenant_id=tenant_id,
            message=req.message,
            entities=entities
        )
        method_results['UpdateContext'] = context_updated
        print(f"  2. UpdateContext: {'âœ…' if context_updated else 'âŒ'}")
        
        # Performance metrics
        end_time = time.time()
        processing_time = round((end_time - start_time) * 1000, 2)
        
        print(f"\nğŸ“Š PROCESSING COMPLETE")
        print(f"  â±ï¸  Processing Time: {processing_time}ms")
        print(f"  ğŸ¯ Confidence Engine: {'âœ… ACTIVE' if confidence_data.get('optimization_active') else 'âŒ INACTIVE'}")
        print(f"  ğŸ’° Estimated Cost: Rp {confidence_data.get('cost_estimate', 0)}")
        print(f"  ğŸš€ Route: {confidence_data.get('route_taken', 'unknown')}")
        
        # ğŸ¯ ENHANCED RESPONSE WITH CONFIDENCE METADATA
        response_data = {
            "confidence": confidence_data.get("confidence_score", 0.0),
            "routing": confidence_data.get("route", confidence_data.get("route_taken", "unknown")),
            "confidence": confidence_data.get("confidence_score", 0.0),
            "routing": confidence_data.get("route", confidence_data.get("route_taken", "unknown")),
            "reply": natural_response,
            "confidence_metadata": confidence_data,  # ğŸ¯ NEW: CONFIDENCE DATA
            "processing_time_ms": processing_time,
            "methods_executed": method_results,
            "session_id": req.session_id,
            "tenant_id": tenant_id
        }
        
        return response_data
        
    except Exception as e:
        print(f"âŒ Customer chat error: {str(e)}")
        return ChatResponse(reply=f"Maaf ada kendala untuk {tenant_id}, silakan coba lagi.")

# Helper function for FAQ answer extraction
def extract_answer_from_faq(content: str) -> str:
    """Extract clean answer from FAQ content"""
    if content.startswith("Q:") and "\nA:" in content:
        return content.split("\nA:", 1)[1].strip()
    return content.strip()