{"ast":null,"code":"import _objectSpread from\"/root/milkyhoop-dev/frontend/web/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{getToken,isTokenExpiringSoon,refreshAccessToken}from'./auth';// API base URL from environment variable\n// If empty, use relative paths (nginx proxy handles it in production)\n// If set, use absolute URL (for development or direct backend access)\nconst API_BASE_URL=process.env.REACT_APP_API_URL||'';/**\n * Build full URL from relative path\n * - If API_BASE_URL is set: use absolute URL (development)\n * - If API_BASE_URL is empty: use relative path (production with nginx proxy)\n */const buildUrl=url=>{// Already absolute URL\nif(url.startsWith('http'))return url;// Use base URL if configured (development)\nif(API_BASE_URL)return\"\".concat(API_BASE_URL).concat(url);// Use relative path (production with nginx proxy)\nreturn url;};/**\n * Fetch wrapper with automatic token refresh and retry logic\n * Industry standard: seamless authentication like Claude/ChatGPT\n */const fetchWithAuth=async function(url){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};let retryCount=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;const MAX_RETRIES=2;// Check if token needs refresh before request\nif(isTokenExpiringSoon()){console.log('[fetchWithAuth] Token expiring soon, refreshing...');const refreshed=await refreshAccessToken();if(!refreshed){throw new Error('Token refresh failed - user logged out');}}// Get fresh token\nconst token=getToken();// Make request with token\nconst fullUrl=buildUrl(url);const response=await fetch(fullUrl,_objectSpread(_objectSpread({},options),{},{headers:_objectSpread(_objectSpread({},options.headers),token&&{'Authorization':\"Bearer \".concat(token)})}));// If 401 Unauthorized - try refresh and retry\nif(response.status===401){if(retryCount<MAX_RETRIES){console.log(\"[fetchWithAuth] Got 401, attempting token refresh (retry \".concat(retryCount+1,\"/\").concat(MAX_RETRIES,\")...\"));const refreshed=await refreshAccessToken();if(refreshed){// Retry request with new token\nconst newToken=getToken();const fullUrl=buildUrl(url);return fetch(fullUrl,_objectSpread(_objectSpread({},options),{},{headers:_objectSpread(_objectSpread({},options.headers),newToken&&{'Authorization':\"Bearer \".concat(newToken)})}));}else{// Refresh failed - user already logged out by refreshAccessToken()\nthrow new Error('Authentication failed - please login again');}}else{console.error('[fetchWithAuth] Max retries reached for 401');throw new Error('Authentication failed after retries');}}return response;};/**\n * Check if user has tenant access\n * Since backend doesn't have /access endpoint, we validate by:\n * 1. Check if token exists\n * 2. Make a test call to tenant chat endpoint\n * Backend will return 403 if user not authorized\n */export const checkTenantAccess=async tenantId=>{const token=getToken();if(!token)return false;try{const response=await fetchWithAuth(\"/api/tenant/\".concat(tenantId,\"/chat\"),{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({message:'__check_access__'})});return response.ok;}catch(error){console.error('[checkTenantAccess] Failed:',error);return false;}};/**\n * Send message to tenant chat endpoint\n * Automatically includes auth token and handles refresh\n */export const sendTenantMessage=async(tenantId,message)=>{const response=await fetchWithAuth(\"/api/tenant/\".concat(tenantId,\"/chat\"),{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({message})});if(!response.ok){throw new Error(\"API call failed: \".concat(response.status));}return response.json();};/**\n * Send message to customer (public) chat endpoint\n * No authentication required\n */export const sendCustomerMessage=async(tenantId,message)=>{// Customer endpoint is public\nconst endpoint=\"/\".concat(tenantId,\"/chat\");const fullUrl=buildUrl(endpoint);const response=await fetch(fullUrl,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({message})});if(!response.ok){throw new Error(\"API call failed: \".concat(response.status));}return response.json();};","map":{"version":3,"names":["getToken","isTokenExpiringSoon","refreshAccessToken","API_BASE_URL","process","env","REACT_APP_API_URL","buildUrl","url","startsWith","concat","fetchWithAuth","options","arguments","length","undefined","retryCount","MAX_RETRIES","console","log","refreshed","Error","token","fullUrl","response","fetch","_objectSpread","headers","status","newToken","error","checkTenantAccess","tenantId","method","body","JSON","stringify","message","ok","sendTenantMessage","json","sendCustomerMessage","endpoint"],"sources":["/root/milkyhoop-dev/frontend/web/src/utils/api.ts"],"sourcesContent":["import { getToken, isTokenExpiringSoon, refreshAccessToken } from './auth';\n\n// API base URL from environment variable\n// If empty, use relative paths (nginx proxy handles it in production)\n// If set, use absolute URL (for development or direct backend access)\nconst API_BASE_URL = process.env.REACT_APP_API_URL || '';\n\n/**\n * Build full URL from relative path\n * - If API_BASE_URL is set: use absolute URL (development)\n * - If API_BASE_URL is empty: use relative path (production with nginx proxy)\n */\nconst buildUrl = (url: string): string => {\n  // Already absolute URL\n  if (url.startsWith('http')) return url;\n  // Use base URL if configured (development)\n  if (API_BASE_URL) return `${API_BASE_URL}${url}`;\n  // Use relative path (production with nginx proxy)\n  return url;\n};\n\n/**\n * Fetch wrapper with automatic token refresh and retry logic\n * Industry standard: seamless authentication like Claude/ChatGPT\n */\nconst fetchWithAuth = async (url: string, options: RequestInit = {}, retryCount = 0): Promise<Response> => {\n  const MAX_RETRIES = 2;\n  \n  // Check if token needs refresh before request\n  if (isTokenExpiringSoon()) {\n    console.log('[fetchWithAuth] Token expiring soon, refreshing...');\n    const refreshed = await refreshAccessToken();\n    if (!refreshed) {\n      throw new Error('Token refresh failed - user logged out');\n    }\n  }\n  \n  // Get fresh token\n  const token = getToken();\n  \n  // Make request with token\n  const fullUrl = buildUrl(url);\n  const response = await fetch(fullUrl, {\n    ...options,\n    headers: {\n      ...options.headers,\n      ...(token && { 'Authorization': `Bearer ${token}` })\n    }\n  });\n  \n  // If 401 Unauthorized - try refresh and retry\n  if (response.status === 401) {\n    if (retryCount < MAX_RETRIES) {\n      console.log(`[fetchWithAuth] Got 401, attempting token refresh (retry ${retryCount + 1}/${MAX_RETRIES})...`);\n      const refreshed = await refreshAccessToken();\n      \n      if (refreshed) {\n        // Retry request with new token\n        const newToken = getToken();\n        const fullUrl = buildUrl(url);\n        return fetch(fullUrl, {\n          ...options,\n          headers: {\n            ...options.headers,\n            ...(newToken && { 'Authorization': `Bearer ${newToken}` })\n          }\n        });\n      } else {\n        // Refresh failed - user already logged out by refreshAccessToken()\n        throw new Error('Authentication failed - please login again');\n      }\n    } else {\n      console.error('[fetchWithAuth] Max retries reached for 401');\n      throw new Error('Authentication failed after retries');\n    }\n  }\n  \n  return response;\n};\n\n/**\n * Check if user has tenant access\n * Since backend doesn't have /access endpoint, we validate by:\n * 1. Check if token exists\n * 2. Make a test call to tenant chat endpoint\n * Backend will return 403 if user not authorized\n */\nexport const checkTenantAccess = async (tenantId: string): Promise<boolean> => {\n  const token = getToken();\n  if (!token) return false;\n  \n  try {\n    const response = await fetchWithAuth(`/api/tenant/${tenantId}/chat`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ message: '__check_access__' })\n    });\n    \n    return response.ok;\n  } catch (error) {\n    console.error('[checkTenantAccess] Failed:', error);\n    return false;\n  }\n};\n\n/**\n * Send message to tenant chat endpoint\n * Automatically includes auth token and handles refresh\n */\nexport const sendTenantMessage = async (tenantId: string, message: string) => {\n  const response = await fetchWithAuth(`/api/tenant/${tenantId}/chat`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({ message })\n  });\n  \n  if (!response.ok) {\n    throw new Error(`API call failed: ${response.status}`);\n  }\n  \n  return response.json();\n};\n\n/**\n * Send message to customer (public) chat endpoint\n * No authentication required\n */\nexport const sendCustomerMessage = async (tenantId: string, message: string) => {\n  // Customer endpoint is public\n  const endpoint = `/${tenantId}/chat`;\n  const fullUrl = buildUrl(endpoint);\n  const response = await fetch(fullUrl, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({ message })\n  });\n  \n  if (!response.ok) {\n    throw new Error(`API call failed: ${response.status}`);\n  }\n  \n  return response.json();\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}