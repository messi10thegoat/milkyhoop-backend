{"ast":null,"code":"import _objectSpread from\"/root/milkyhoop-dev/frontend/web/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{getToken,isTokenExpiringSoon,refreshAccessToken}from'./auth';/**\n * Fetch wrapper with automatic token refresh and retry logic\n * Industry standard: seamless authentication like Claude/ChatGPT\n */const fetchWithAuth=async function(url){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};let retryCount=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;const MAX_RETRIES=2;// Check if token needs refresh before request\nif(isTokenExpiringSoon()){console.log('[fetchWithAuth] Token expiring soon, refreshing...');const refreshed=await refreshAccessToken();if(!refreshed){throw new Error('Token refresh failed - user logged out');}}// Get fresh token\nconst token=getToken();// Make request with token\nconst response=await fetch(url,_objectSpread(_objectSpread({},options),{},{headers:_objectSpread(_objectSpread({},options.headers),token&&{'Authorization':\"Bearer \".concat(token)})}));// If 401 Unauthorized - try refresh and retry\nif(response.status===401){if(retryCount<MAX_RETRIES){console.log(\"[fetchWithAuth] Got 401, attempting token refresh (retry \".concat(retryCount+1,\"/\").concat(MAX_RETRIES,\")...\"));const refreshed=await refreshAccessToken();if(refreshed){// Retry request with new token\nconst newToken=getToken();return fetch(url,_objectSpread(_objectSpread({},options),{},{headers:_objectSpread(_objectSpread({},options.headers),newToken&&{'Authorization':\"Bearer \".concat(newToken)})}));}else{// Refresh failed - user already logged out by refreshAccessToken()\nthrow new Error('Authentication failed - please login again');}}else{console.error('[fetchWithAuth] Max retries reached for 401');throw new Error('Authentication failed after retries');}}return response;};/**\n * Check if user has tenant access\n * Since backend doesn't have /access endpoint, we validate by:\n * 1. Check if token exists\n * 2. Make a test call to tenant chat endpoint\n * Backend will return 403 if user not authorized\n */export const checkTenantAccess=async tenantId=>{const token=getToken();if(!token)return false;try{const response=await fetchWithAuth(\"/api/tenant/\".concat(tenantId,\"/chat\"),{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({message:'__check_access__'})});return response.ok;}catch(error){console.error('[checkTenantAccess] Failed:',error);return false;}};/**\n * Send message to tenant chat endpoint\n * Automatically includes auth token and handles refresh\n */export const sendTenantMessage=async(tenantId,message)=>{const response=await fetchWithAuth(\"/api/tenant/\".concat(tenantId,\"/chat\"),{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({message})});if(!response.ok){throw new Error(\"API call failed: \".concat(response.status));}return response.json();};/**\n * Send message to customer (public) chat endpoint\n * No authentication required\n */export const sendCustomerMessage=async(tenantId,message)=>{const response=await fetch(\"/\".concat(tenantId,\"/chat\"),{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({message})});if(!response.ok){throw new Error(\"API call failed: \".concat(response.status));}return response.json();};","map":{"version":3,"names":["getToken","isTokenExpiringSoon","refreshAccessToken","fetchWithAuth","url","options","arguments","length","undefined","retryCount","MAX_RETRIES","console","log","refreshed","Error","token","response","fetch","_objectSpread","headers","concat","status","newToken","error","checkTenantAccess","tenantId","method","body","JSON","stringify","message","ok","sendTenantMessage","json","sendCustomerMessage"],"sources":["/root/milkyhoop-dev/frontend/web/src/utils/api.ts"],"sourcesContent":["import { getToken, isTokenExpiringSoon, refreshAccessToken } from './auth';\n\n/**\n * Fetch wrapper with automatic token refresh and retry logic\n * Industry standard: seamless authentication like Claude/ChatGPT\n */\nconst fetchWithAuth = async (url: string, options: RequestInit = {}, retryCount = 0): Promise<Response> => {\n  const MAX_RETRIES = 2;\n  \n  // Check if token needs refresh before request\n  if (isTokenExpiringSoon()) {\n    console.log('[fetchWithAuth] Token expiring soon, refreshing...');\n    const refreshed = await refreshAccessToken();\n    if (!refreshed) {\n      throw new Error('Token refresh failed - user logged out');\n    }\n  }\n  \n  // Get fresh token\n  const token = getToken();\n  \n  // Make request with token\n  const response = await fetch(url, {\n    ...options,\n    headers: {\n      ...options.headers,\n      ...(token && { 'Authorization': `Bearer ${token}` })\n    }\n  });\n  \n  // If 401 Unauthorized - try refresh and retry\n  if (response.status === 401) {\n    if (retryCount < MAX_RETRIES) {\n      console.log(`[fetchWithAuth] Got 401, attempting token refresh (retry ${retryCount + 1}/${MAX_RETRIES})...`);\n      const refreshed = await refreshAccessToken();\n      \n      if (refreshed) {\n        // Retry request with new token\n        const newToken = getToken();\n        return fetch(url, {\n          ...options,\n          headers: {\n            ...options.headers,\n            ...(newToken && { 'Authorization': `Bearer ${newToken}` })\n          }\n        });\n      } else {\n        // Refresh failed - user already logged out by refreshAccessToken()\n        throw new Error('Authentication failed - please login again');\n      }\n    } else {\n      console.error('[fetchWithAuth] Max retries reached for 401');\n      throw new Error('Authentication failed after retries');\n    }\n  }\n  \n  return response;\n};\n\n/**\n * Check if user has tenant access\n * Since backend doesn't have /access endpoint, we validate by:\n * 1. Check if token exists\n * 2. Make a test call to tenant chat endpoint\n * Backend will return 403 if user not authorized\n */\nexport const checkTenantAccess = async (tenantId: string): Promise<boolean> => {\n  const token = getToken();\n  if (!token) return false;\n  \n  try {\n    const response = await fetchWithAuth(`/api/tenant/${tenantId}/chat`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ message: '__check_access__' })\n    });\n    \n    return response.ok;\n  } catch (error) {\n    console.error('[checkTenantAccess] Failed:', error);\n    return false;\n  }\n};\n\n/**\n * Send message to tenant chat endpoint\n * Automatically includes auth token and handles refresh\n */\nexport const sendTenantMessage = async (tenantId: string, message: string) => {\n  const response = await fetchWithAuth(`/api/tenant/${tenantId}/chat`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({ message })\n  });\n  \n  if (!response.ok) {\n    throw new Error(`API call failed: ${response.status}`);\n  }\n  \n  return response.json();\n};\n\n/**\n * Send message to customer (public) chat endpoint\n * No authentication required\n */\nexport const sendCustomerMessage = async (tenantId: string, message: string) => {\n  const response = await fetch(`/${tenantId}/chat`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({ message })\n  });\n  \n  if (!response.ok) {\n    throw new Error(`API call failed: ${response.status}`);\n  }\n  \n  return response.json();\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}