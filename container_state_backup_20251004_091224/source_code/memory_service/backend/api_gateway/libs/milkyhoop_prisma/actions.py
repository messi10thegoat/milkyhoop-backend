# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE email = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'email': 'ggciceaie',
                'password_hash': 'bbehjachib',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'email': 'cadfabfehe',
                    'password_hash': 'dgiiaaijj',
                },
                {
                    # data to create a User record
                    'email': 'bfaiacjjfc',
                    'password_hash': 'eigcfgbif',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 'bagcfbhiig',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 'cghideieh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 'biabhbdai',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the password_hash field
        users = await User.prisma().find_many(
            take=5,
            order={
                'password_hash': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the username field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'username': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the name field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 'idghgaicb',
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 'fjfddhigg',
            },
            data={
                'create': {
                    'id': 'fjfddhigg',
                    'email': 'bfaiacjjfc',
                    'password_hash': 'eigcfgbif',
                },
                'update': {
                    'email': 'bfaiacjjfc',
                    'password_hash': 'eigcfgbif',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'fullname': 'hjaecfifb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'nickname': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'avatarUrl': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by coverPhotoUrl values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['coverPhotoUrl'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AccountActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Account]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Account.prisma().query_raw(
            'SELECT * FROM Account WHERE id = $1',
            'cbbbjbfcii',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Account
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Account.prisma().query_first(
            'SELECT * FROM Account WHERE userId = $1',
            'bbejhfidcb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AccountCreateInput,
        include: Optional[types.AccountInclude] = None
    ) -> _PrismaModelT:
        """Create a new Account record.

        Parameters
        ----------
        data
            Account record data
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The created Account record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Account record from just the required fields
        account = await Account.prisma().create(
            data={
                # data to create a Account record
                'userId': 'bgeecijdgg',
                'type': 'bdiicjafbj',
                'provider': 'bgehebiafc',
                'providerAccountId': 'bghffegacj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AccountCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Account records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Account record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Account.prisma().create_many(
            data=[
                {
                    # data to create a Account record
                    'userId': 'bhghchehcc',
                    'type': 'dcgchcbbf',
                    'provider': 'bdedcabahc',
                    'providerAccountId': 'ghfhiafcb',
                },
                {
                    # data to create a Account record
                    'userId': 'heejgedji',
                    'type': 'bjgjgibgbf',
                    'provider': 'bbbgbhfjge',
                    'providerAccountId': 'igbehcbab',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AccountWhereUniqueInput,
        include: Optional[types.AccountInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Account record.

        Parameters
        ----------
        where
            Account filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The deleted Account record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        account = await Account.prisma().delete(
            where={
                'id': 'bdadaadhag',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AccountWhereUniqueInput,
        include: Optional[types.AccountInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Account record.

        Parameters
        ----------
        where
            Account filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The found Account record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        account = await Account.prisma().find_unique(
            where={
                'id': 'bgiggdidbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AccountWhereUniqueInput,
        include: Optional[types.AccountInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Account record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Account filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The found Account record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        account = await Account.prisma().find_unique_or_raise(
            where={
                'id': 'caaaedabfc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
        include: Optional[types.AccountInclude] = None,
        order: Optional[Union[types.AccountOrderByInput, List[types.AccountOrderByInput]]] = None,
        distinct: Optional[List[types.AccountScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Account records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Account records returned
        skip
            Ignore the first N results
        where
            Account filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Account model
        order
            Order the returned Account records by any field
        distinct
            Filter Account records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Account]
            The list of all Account records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Account records
        accounts = await Account.prisma().find_many(take=10)

        # find the first 5 Account records ordered by the type field
        accounts = await Account.prisma().find_many(
            take=5,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
        include: Optional[types.AccountInclude] = None,
        order: Optional[Union[types.AccountOrderByInput, List[types.AccountOrderByInput]]] = None,
        distinct: Optional[List[types.AccountScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Account record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Account filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Account model
        order
            Order the returned Account records by any field
        distinct
            Filter Account records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Account
            The first Account record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Account record ordered by the provider field
        account = await Account.prisma().find_first(
            skip=1,
            order={
                'provider': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
        include: Optional[types.AccountInclude] = None,
        order: Optional[Union[types.AccountOrderByInput, List[types.AccountOrderByInput]]] = None,
        distinct: Optional[List[types.AccountScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Account record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Account filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Account model
        order
            Order the returned Account records by any field
        distinct
            Filter Account records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Account
            The first Account record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Account record ordered by the providerAccountId field
        account = await Account.prisma().find_first_or_raise(
            skip=1,
            order={
                'providerAccountId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AccountUpdateInput,
        where: types.AccountWhereUniqueInput,
        include: Optional[types.AccountInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Account record.

        Parameters
        ----------
        data
            Account record data specifying what to update
        where
            Account filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The updated Account record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        account = await Account.prisma().update(
            where={
                'id': 'bigibebcib',
            },
            data={
                # data to update the Account record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AccountWhereUniqueInput,
        data: types.AccountUpsertInput,
        include: Optional[types.AccountInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Account filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Account model

        Returns
        -------
        prisma.models.Account
            The created or updated Account record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        account = await Account.prisma().upsert(
            where={
                'id': 'bigaiehgcc',
            },
            data={
                'create': {
                    'id': 'bigaiehgcc',
                    'userId': 'heejgedji',
                    'type': 'bjgjgibgbf',
                    'provider': 'bbbgbhfjge',
                    'providerAccountId': 'igbehcbab',
                },
                'update': {
                    'userId': 'heejgedji',
                    'type': 'bjgjgibgbf',
                    'provider': 'bbbgbhfjge',
                    'providerAccountId': 'igbehcbab',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AccountUpdateManyMutationInput,
        where: types.AccountWhereInput,
    ) -> int:
        """Update multiple Account records

        Parameters
        ----------
        data
            Account data to update the selected Account records to
        where
            Filter to select the Account records to update

        Returns
        -------
        int
            The total number of Account records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Account records
        total = await Account.prisma().update_many(
            data={
                'access_token': 'beeifcbebf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Account records present in the database

        Parameters
        ----------
        select
            Select the Account fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Account filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AccountCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Account.prisma().count()

        # results: prisma.types.AccountCountAggregateOutput
        results = await Account.prisma().count(
            select={
                '_all': True,
                'expires_at': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AccountCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
    ) -> types.AccountCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AccountCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AccountWhereInput] = None,
        cursor: Optional[types.AccountWhereUniqueInput] = None,
    ) -> Union[int, types.AccountCountAggregateOutput]:
        """Count the number of Account records present in the database

        Parameters
        ----------
        select
            Select the Account fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Account filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AccountCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Account.prisma().count()

        # results: prisma.types.AccountCountAggregateOutput
        results = await Account.prisma().count(
            select={
                '_all': True,
                'id_token': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AccountCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AccountWhereInput] = None
    ) -> int:
        """Delete multiple Account records.

        Parameters
        ----------
        where
            Optional Account filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Account records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Account records
        total = await Account.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AccountScalarFieldKeys'],
        *,
        where: Optional['types.AccountWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AccountAvgAggregateInput'] = None,
        sum: Optional['types.AccountSumAggregateInput'] = None,
        min: Optional['types.AccountMinAggregateInput'] = None,
        max: Optional['types.AccountMaxAggregateInput'] = None,
        having: Optional['types.AccountScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AccountCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AccountScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AccountScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AccountGroupByOutput']:
        """Group Account records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Account fields to group records by
        where
            Account filter to select records
        take
            Limit the maximum number of Account records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AccountGroupByOutput]
            A list of dictionaries representing the Account record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Account records by refresh_token values
        # and count how many records are in each group
        results = await Account.prisma().group_by(
            ['refresh_token'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SessionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Session]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Session.prisma().query_raw(
            'SELECT * FROM Session WHERE id = $1',
            'bgcigfahea',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Session
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Session.prisma().query_first(
            'SELECT * FROM Session WHERE sessionToken = $1',
            'bcejgaggif',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SessionCreateInput,
        include: Optional[types.SessionInclude] = None
    ) -> _PrismaModelT:
        """Create a new Session record.

        Parameters
        ----------
        data
            Session record data
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The created Session record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Session record from just the required fields
        session = await Session.prisma().create(
            data={
                # data to create a Session record
                'sessionToken': 'idfjadbcc',
                'userId': 'hgdhbjhhj',
                'expires': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SessionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Session records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Session record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Session.prisma().create_many(
            data=[
                {
                    # data to create a Session record
                    'sessionToken': 'ecjjjfbae',
                    'userId': 'bhhfibbigf',
                    'expires': datetime.datetime.utcnow(),
                },
                {
                    # data to create a Session record
                    'sessionToken': 'ijdbeffgg',
                    'userId': 'jjfeafhfj',
                    'expires': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Session record.

        Parameters
        ----------
        where
            Session filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The deleted Session record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = await Session.prisma().delete(
            where={
                'id': 'cbachdgfce',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Session record.

        Parameters
        ----------
        where
            Session filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The found Session record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = await Session.prisma().find_unique(
            where={
                'id': 'chbfcacbd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Session record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Session filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The found Session record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = await Session.prisma().find_unique_or_raise(
            where={
                'id': 'efggddide',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
        include: Optional[types.SessionInclude] = None,
        order: Optional[Union[types.SessionOrderByInput, List[types.SessionOrderByInput]]] = None,
        distinct: Optional[List[types.SessionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Session records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Session records returned
        skip
            Ignore the first N results
        where
            Session filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Session model
        order
            Order the returned Session records by any field
        distinct
            Filter Session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Session]
            The list of all Session records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Session records
        sessions = await Session.prisma().find_many(take=10)

        # find the first 5 Session records ordered by the userId field
        sessions = await Session.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
        include: Optional[types.SessionInclude] = None,
        order: Optional[Union[types.SessionOrderByInput, List[types.SessionOrderByInput]]] = None,
        distinct: Optional[List[types.SessionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Session record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Session filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Session model
        order
            Order the returned Session records by any field
        distinct
            Filter Session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Session
            The first Session record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Session record ordered by the expires field
        session = await Session.prisma().find_first(
            skip=1,
            order={
                'expires': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
        include: Optional[types.SessionInclude] = None,
        order: Optional[Union[types.SessionOrderByInput, List[types.SessionOrderByInput]]] = None,
        distinct: Optional[List[types.SessionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Session record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Session filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Session model
        order
            Order the returned Session records by any field
        distinct
            Filter Session records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Session
            The first Session record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Session record ordered by the id field
        session = await Session.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SessionUpdateInput,
        where: types.SessionWhereUniqueInput,
        include: Optional[types.SessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Session record.

        Parameters
        ----------
        data
            Session record data specifying what to update
        where
            Session filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The updated Session record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        session = await Session.prisma().update(
            where={
                'id': 'caficfigfb',
            },
            data={
                # data to update the Session record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SessionWhereUniqueInput,
        data: types.SessionUpsertInput,
        include: Optional[types.SessionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Session filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Session model

        Returns
        -------
        prisma.models.Session
            The created or updated Session record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        session = await Session.prisma().upsert(
            where={
                'id': 'bfidgijfjc',
            },
            data={
                'create': {
                    'id': 'bfidgijfjc',
                    'sessionToken': 'ijdbeffgg',
                    'userId': 'jjfeafhfj',
                    'expires': datetime.datetime.utcnow(),
                },
                'update': {
                    'sessionToken': 'ijdbeffgg',
                    'userId': 'jjfeafhfj',
                    'expires': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SessionUpdateManyMutationInput,
        where: types.SessionWhereInput,
    ) -> int:
        """Update multiple Session records

        Parameters
        ----------
        data
            Session data to update the selected Session records to
        where
            Filter to select the Session records to update

        Returns
        -------
        int
            The total number of Session records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Session records
        total = await Session.prisma().update_many(
            data={
                'sessionToken': 'ihieecagf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Session records present in the database

        Parameters
        ----------
        select
            Select the Session fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Session filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Session.prisma().count()

        # results: prisma.types.SessionCountAggregateOutput
        results = await Session.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SessionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
    ) -> types.SessionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SessionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SessionWhereInput] = None,
        cursor: Optional[types.SessionWhereUniqueInput] = None,
    ) -> Union[int, types.SessionCountAggregateOutput]:
        """Count the number of Session records present in the database

        Parameters
        ----------
        select
            Select the Session fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Session filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Session.prisma().count()

        # results: prisma.types.SessionCountAggregateOutput
        results = await Session.prisma().count(
            select={
                '_all': True,
                'expires': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SessionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SessionWhereInput] = None
    ) -> int:
        """Delete multiple Session records.

        Parameters
        ----------
        where
            Optional Session filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Session records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Session records
        total = await Session.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SessionScalarFieldKeys'],
        *,
        where: Optional['types.SessionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SessionAvgAggregateInput'] = None,
        sum: Optional['types.SessionSumAggregateInput'] = None,
        min: Optional['types.SessionMinAggregateInput'] = None,
        max: Optional['types.SessionMaxAggregateInput'] = None,
        having: Optional['types.SessionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SessionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SessionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SessionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SessionGroupByOutput']:
        """Group Session records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Session fields to group records by
        where
            Session filter to select records
        take
            Limit the maximum number of Session records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SessionGroupByOutput]
            A list of dictionaries representing the Session record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Session records by id values
        # and count how many records are in each group
        results = await Session.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserSecurityActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserSecurity]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserSecurity.prisma().query_raw(
            'SELECT * FROM UserSecurity WHERE id = $1',
            'bghfciaafe',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserSecurity
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserSecurity.prisma().query_first(
            'SELECT * FROM UserSecurity WHERE userId = $1',
            'bgchfhgceh',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserSecurityCreateInput,
        include: Optional[types.UserSecurityInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserSecurity record.

        Parameters
        ----------
        data
            UserSecurity record data
        include
            Specifies which relations should be loaded on the returned UserSecurity model

        Returns
        -------
        prisma.models.UserSecurity
            The created UserSecurity record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserSecurity record from just the required fields
        usersecurity = await UserSecurity.prisma().create(
            data={
                # data to create a UserSecurity record
                'userId': 'cafeiaccbc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserSecurityCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserSecurity records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserSecurity record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserSecurity.prisma().create_many(
            data=[
                {
                    # data to create a UserSecurity record
                    'userId': 'gaddfhfh',
                },
                {
                    # data to create a UserSecurity record
                    'userId': 'gieegcbeg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserSecurityWhereUniqueInput,
        include: Optional[types.UserSecurityInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserSecurity record.

        Parameters
        ----------
        where
            UserSecurity filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserSecurity model

        Returns
        -------
        prisma.models.UserSecurity
            The deleted UserSecurity record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usersecurity = await UserSecurity.prisma().delete(
            where={
                'id': 'bgcffadich',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserSecurityWhereUniqueInput,
        include: Optional[types.UserSecurityInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserSecurity record.

        Parameters
        ----------
        where
            UserSecurity filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserSecurity model

        Returns
        -------
        prisma.models.UserSecurity
            The found UserSecurity record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usersecurity = await UserSecurity.prisma().find_unique(
            where={
                'id': 'fcbichhci',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserSecurityWhereUniqueInput,
        include: Optional[types.UserSecurityInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserSecurity record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserSecurity filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserSecurity model

        Returns
        -------
        prisma.models.UserSecurity
            The found UserSecurity record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usersecurity = await UserSecurity.prisma().find_unique_or_raise(
            where={
                'id': 'bcggadccgf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserSecurityWhereInput] = None,
        cursor: Optional[types.UserSecurityWhereUniqueInput] = None,
        include: Optional[types.UserSecurityInclude] = None,
        order: Optional[Union[types.UserSecurityOrderByInput, List[types.UserSecurityOrderByInput]]] = None,
        distinct: Optional[List[types.UserSecurityScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserSecurity records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserSecurity records returned
        skip
            Ignore the first N results
        where
            UserSecurity filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserSecurity model
        order
            Order the returned UserSecurity records by any field
        distinct
            Filter UserSecurity records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserSecurity]
            The list of all UserSecurity records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserSecurity records
        usersecuritys = await UserSecurity.prisma().find_many(take=10)

        # find the first 5 UserSecurity records ordered by the passwordHash field
        usersecuritys = await UserSecurity.prisma().find_many(
            take=5,
            order={
                'passwordHash': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserSecurityWhereInput] = None,
        cursor: Optional[types.UserSecurityWhereUniqueInput] = None,
        include: Optional[types.UserSecurityInclude] = None,
        order: Optional[Union[types.UserSecurityOrderByInput, List[types.UserSecurityOrderByInput]]] = None,
        distinct: Optional[List[types.UserSecurityScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserSecurity record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserSecurity filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserSecurity model
        order
            Order the returned UserSecurity records by any field
        distinct
            Filter UserSecurity records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserSecurity
            The first UserSecurity record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserSecurity record ordered by the twoFactorEnabled field
        usersecurity = await UserSecurity.prisma().find_first(
            skip=1,
            order={
                'twoFactorEnabled': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserSecurityWhereInput] = None,
        cursor: Optional[types.UserSecurityWhereUniqueInput] = None,
        include: Optional[types.UserSecurityInclude] = None,
        order: Optional[Union[types.UserSecurityOrderByInput, List[types.UserSecurityOrderByInput]]] = None,
        distinct: Optional[List[types.UserSecurityScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserSecurity record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserSecurity filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserSecurity model
        order
            Order the returned UserSecurity records by any field
        distinct
            Filter UserSecurity records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserSecurity
            The first UserSecurity record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserSecurity record ordered by the oauthId field
        usersecurity = await UserSecurity.prisma().find_first_or_raise(
            skip=1,
            order={
                'oauthId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserSecurityUpdateInput,
        where: types.UserSecurityWhereUniqueInput,
        include: Optional[types.UserSecurityInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserSecurity record.

        Parameters
        ----------
        data
            UserSecurity record data specifying what to update
        where
            UserSecurity filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserSecurity model

        Returns
        -------
        prisma.models.UserSecurity
            The updated UserSecurity record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        usersecurity = await UserSecurity.prisma().update(
            where={
                'id': 'jdcfdcgc',
            },
            data={
                # data to update the UserSecurity record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserSecurityWhereUniqueInput,
        data: types.UserSecurityUpsertInput,
        include: Optional[types.UserSecurityInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserSecurity filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserSecurity model

        Returns
        -------
        prisma.models.UserSecurity
            The created or updated UserSecurity record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usersecurity = await UserSecurity.prisma().upsert(
            where={
                'id': 'cafdaehjid',
            },
            data={
                'create': {
                    'id': 'cafdaehjid',
                    'userId': 'gieegcbeg',
                },
                'update': {
                    'userId': 'gieegcbeg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserSecurityUpdateManyMutationInput,
        where: types.UserSecurityWhereInput,
    ) -> int:
        """Update multiple UserSecurity records

        Parameters
        ----------
        data
            UserSecurity data to update the selected UserSecurity records to
        where
            Filter to select the UserSecurity records to update

        Returns
        -------
        int
            The total number of UserSecurity records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserSecurity records
        total = await UserSecurity.prisma().update_many(
            data={
                'oauthProvider': 'gifdddbia'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserSecurityWhereInput] = None,
        cursor: Optional[types.UserSecurityWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserSecurity records present in the database

        Parameters
        ----------
        select
            Select the UserSecurity fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserSecurity filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserSecurityCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserSecurity.prisma().count()

        # results: prisma.types.UserSecurityCountAggregateOutput
        results = await UserSecurity.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserSecurityCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserSecurityWhereInput] = None,
        cursor: Optional[types.UserSecurityWhereUniqueInput] = None,
    ) -> types.UserSecurityCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserSecurityCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserSecurityWhereInput] = None,
        cursor: Optional[types.UserSecurityWhereUniqueInput] = None,
    ) -> Union[int, types.UserSecurityCountAggregateOutput]:
        """Count the number of UserSecurity records present in the database

        Parameters
        ----------
        select
            Select the UserSecurity fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserSecurity filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserSecurityCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserSecurity.prisma().count()

        # results: prisma.types.UserSecurityCountAggregateOutput
        results = await UserSecurity.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserSecurityCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserSecurityWhereInput] = None
    ) -> int:
        """Delete multiple UserSecurity records.

        Parameters
        ----------
        where
            Optional UserSecurity filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserSecurity records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserSecurity records
        total = await UserSecurity.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserSecurityScalarFieldKeys'],
        *,
        where: Optional['types.UserSecurityWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserSecurityAvgAggregateInput'] = None,
        sum: Optional['types.UserSecuritySumAggregateInput'] = None,
        min: Optional['types.UserSecurityMinAggregateInput'] = None,
        max: Optional['types.UserSecurityMaxAggregateInput'] = None,
        having: Optional['types.UserSecurityScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserSecurityCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserSecurityScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserSecurityScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserSecurityGroupByOutput']:
        """Group UserSecurity records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserSecurity fields to group records by
        where
            UserSecurity filter to select records
        take
            Limit the maximum number of UserSecurity records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserSecurityGroupByOutput]
            A list of dictionaries representing the UserSecurity record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserSecurity records by passwordHash values
        # and count how many records are in each group
        results = await UserSecurity.prisma().group_by(
            ['passwordHash'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserProfileActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserProfile]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserProfile.prisma().query_raw(
            'SELECT * FROM UserProfile WHERE id = $1',
            'bchehecef',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserProfile
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserProfile.prisma().query_first(
            'SELECT * FROM UserProfile WHERE userId = $1',
            'jeijcbhfe',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserProfileCreateInput,
        include: Optional[types.UserProfileInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserProfile record.

        Parameters
        ----------
        data
            UserProfile record data
        include
            Specifies which relations should be loaded on the returned UserProfile model

        Returns
        -------
        prisma.models.UserProfile
            The created UserProfile record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserProfile record from just the required fields
        userprofile = await UserProfile.prisma().create(
            data={
                # data to create a UserProfile record
                'userId': 'bjgejjabff',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserProfileCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserProfile records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserProfile record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserProfile.prisma().create_many(
            data=[
                {
                    # data to create a UserProfile record
                    'userId': 'bcciijbibg',
                },
                {
                    # data to create a UserProfile record
                    'userId': 'cffcachfd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserProfileWhereUniqueInput,
        include: Optional[types.UserProfileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserProfile record.

        Parameters
        ----------
        where
            UserProfile filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserProfile model

        Returns
        -------
        prisma.models.UserProfile
            The deleted UserProfile record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userprofile = await UserProfile.prisma().delete(
            where={
                'id': 'bccdfhdigc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserProfileWhereUniqueInput,
        include: Optional[types.UserProfileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserProfile record.

        Parameters
        ----------
        where
            UserProfile filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserProfile model

        Returns
        -------
        prisma.models.UserProfile
            The found UserProfile record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userprofile = await UserProfile.prisma().find_unique(
            where={
                'id': 'febcgjbfj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserProfileWhereUniqueInput,
        include: Optional[types.UserProfileInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserProfile record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserProfile filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserProfile model

        Returns
        -------
        prisma.models.UserProfile
            The found UserProfile record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userprofile = await UserProfile.prisma().find_unique_or_raise(
            where={
                'id': 'bageiegghg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserProfileWhereInput] = None,
        cursor: Optional[types.UserProfileWhereUniqueInput] = None,
        include: Optional[types.UserProfileInclude] = None,
        order: Optional[Union[types.UserProfileOrderByInput, List[types.UserProfileOrderByInput]]] = None,
        distinct: Optional[List[types.UserProfileScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserProfile records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserProfile records returned
        skip
            Ignore the first N results
        where
            UserProfile filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserProfile model
        order
            Order the returned UserProfile records by any field
        distinct
            Filter UserProfile records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserProfile]
            The list of all UserProfile records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserProfile records
        userprofiles = await UserProfile.prisma().find_many(take=10)

        # find the first 5 UserProfile records ordered by the bio field
        userprofiles = await UserProfile.prisma().find_many(
            take=5,
            order={
                'bio': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserProfileWhereInput] = None,
        cursor: Optional[types.UserProfileWhereUniqueInput] = None,
        include: Optional[types.UserProfileInclude] = None,
        order: Optional[Union[types.UserProfileOrderByInput, List[types.UserProfileOrderByInput]]] = None,
        distinct: Optional[List[types.UserProfileScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserProfile record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserProfile filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserProfile model
        order
            Order the returned UserProfile records by any field
        distinct
            Filter UserProfile records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserProfile
            The first UserProfile record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserProfile record ordered by the phoneNumber field
        userprofile = await UserProfile.prisma().find_first(
            skip=1,
            order={
                'phoneNumber': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserProfileWhereInput] = None,
        cursor: Optional[types.UserProfileWhereUniqueInput] = None,
        include: Optional[types.UserProfileInclude] = None,
        order: Optional[Union[types.UserProfileOrderByInput, List[types.UserProfileOrderByInput]]] = None,
        distinct: Optional[List[types.UserProfileScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserProfile record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserProfile filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserProfile model
        order
            Order the returned UserProfile records by any field
        distinct
            Filter UserProfile records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserProfile
            The first UserProfile record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserProfile record ordered by the tagline field
        userprofile = await UserProfile.prisma().find_first_or_raise(
            skip=1,
            order={
                'tagline': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserProfileUpdateInput,
        where: types.UserProfileWhereUniqueInput,
        include: Optional[types.UserProfileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserProfile record.

        Parameters
        ----------
        data
            UserProfile record data specifying what to update
        where
            UserProfile filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserProfile model

        Returns
        -------
        prisma.models.UserProfile
            The updated UserProfile record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        userprofile = await UserProfile.prisma().update(
            where={
                'id': 'faidicegb',
            },
            data={
                # data to update the UserProfile record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserProfileWhereUniqueInput,
        data: types.UserProfileUpsertInput,
        include: Optional[types.UserProfileInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserProfile filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserProfile model

        Returns
        -------
        prisma.models.UserProfile
            The created or updated UserProfile record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userprofile = await UserProfile.prisma().upsert(
            where={
                'id': 'bacecgfhbe',
            },
            data={
                'create': {
                    'id': 'bacecgfhbe',
                    'userId': 'cffcachfd',
                },
                'update': {
                    'userId': 'cffcachfd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserProfileUpdateManyMutationInput,
        where: types.UserProfileWhereInput,
    ) -> int:
        """Update multiple UserProfile records

        Parameters
        ----------
        data
            UserProfile data to update the selected UserProfile records to
        where
            Filter to select the UserProfile records to update

        Returns
        -------
        int
            The total number of UserProfile records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserProfile records
        total = await UserProfile.prisma().update_many(
            data={
                'publicUrlSlug': 'ihcahiead'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserProfileWhereInput] = None,
        cursor: Optional[types.UserProfileWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserProfile records present in the database

        Parameters
        ----------
        select
            Select the UserProfile fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserProfile filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserProfileCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserProfile.prisma().count()

        # results: prisma.types.UserProfileCountAggregateOutput
        results = await UserProfile.prisma().count(
            select={
                '_all': True,
                'digitalSignature': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserProfileCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserProfileWhereInput] = None,
        cursor: Optional[types.UserProfileWhereUniqueInput] = None,
    ) -> types.UserProfileCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserProfileCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserProfileWhereInput] = None,
        cursor: Optional[types.UserProfileWhereUniqueInput] = None,
    ) -> Union[int, types.UserProfileCountAggregateOutput]:
        """Count the number of UserProfile records present in the database

        Parameters
        ----------
        select
            Select the UserProfile fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserProfile filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserProfileCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserProfile.prisma().count()

        # results: prisma.types.UserProfileCountAggregateOutput
        results = await UserProfile.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserProfileCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserProfileWhereInput] = None
    ) -> int:
        """Delete multiple UserProfile records.

        Parameters
        ----------
        where
            Optional UserProfile filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserProfile records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserProfile records
        total = await UserProfile.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserProfileScalarFieldKeys'],
        *,
        where: Optional['types.UserProfileWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserProfileAvgAggregateInput'] = None,
        sum: Optional['types.UserProfileSumAggregateInput'] = None,
        min: Optional['types.UserProfileMinAggregateInput'] = None,
        max: Optional['types.UserProfileMaxAggregateInput'] = None,
        having: Optional['types.UserProfileScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserProfileCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserProfileScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserProfileScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserProfileGroupByOutput']:
        """Group UserProfile records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserProfile fields to group records by
        where
            UserProfile filter to select records
        take
            Limit the maximum number of UserProfile records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserProfileGroupByOutput]
            A list of dictionaries representing the UserProfile record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserProfile records by userId values
        # and count how many records are in each group
        results = await UserProfile.prisma().group_by(
            ['userId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class VerificationTokenActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.VerificationToken]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await VerificationToken.prisma().query_raw(
            'SELECT * FROM VerificationToken WHERE identifier = $1',
            'biheheiajg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.VerificationToken
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await VerificationToken.prisma().query_first(
            'SELECT * FROM VerificationToken WHERE token = $1',
            'jbgijghgb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.VerificationTokenCreateInput,
        include: Optional[types.VerificationTokenInclude] = None
    ) -> _PrismaModelT:
        """Create a new VerificationToken record.

        Parameters
        ----------
        data
            VerificationToken record data
        include
            Specifies which relations should be loaded on the returned VerificationToken model

        Returns
        -------
        prisma.models.VerificationToken
            The created VerificationToken record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a VerificationToken record from just the required fields
        verificationtoken = await VerificationToken.prisma().create(
            data={
                # data to create a VerificationToken record
                'identifier': 'hgjcghfbi',
                'token': 'icadbcehj',
                'expires': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.VerificationTokenCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple VerificationToken records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of VerificationToken record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await VerificationToken.prisma().create_many(
            data=[
                {
                    # data to create a VerificationToken record
                    'identifier': 'jchciaee',
                    'token': 'deeificjd',
                    'expires': datetime.datetime.utcnow(),
                },
                {
                    # data to create a VerificationToken record
                    'identifier': 'bbcbhebbda',
                    'token': 'bejfijgcfb',
                    'expires': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.VerificationTokenWhereUniqueInput,
        include: Optional[types.VerificationTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single VerificationToken record.

        Parameters
        ----------
        where
            VerificationToken filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned VerificationToken model

        Returns
        -------
        prisma.models.VerificationToken
            The deleted VerificationToken record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        verificationtoken = await VerificationToken.prisma().delete(
            where={
                'token': 'caifcbgii',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.VerificationTokenWhereUniqueInput,
        include: Optional[types.VerificationTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique VerificationToken record.

        Parameters
        ----------
        where
            VerificationToken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned VerificationToken model

        Returns
        -------
        prisma.models.VerificationToken
            The found VerificationToken record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        verificationtoken = await VerificationToken.prisma().find_unique(
            where={
                'token': 'igaibbfgj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.VerificationTokenWhereUniqueInput,
        include: Optional[types.VerificationTokenInclude] = None
    ) -> _PrismaModelT:
        """Find a unique VerificationToken record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            VerificationToken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned VerificationToken model

        Returns
        -------
        prisma.models.VerificationToken
            The found VerificationToken record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        verificationtoken = await VerificationToken.prisma().find_unique_or_raise(
            where={
                'token': 'bggajdcbbi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VerificationTokenWhereInput] = None,
        cursor: Optional[types.VerificationTokenWhereUniqueInput] = None,
        include: Optional[types.VerificationTokenInclude] = None,
        order: Optional[Union[types.VerificationTokenOrderByInput, List[types.VerificationTokenOrderByInput]]] = None,
        distinct: Optional[List[types.VerificationTokenScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple VerificationToken records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of VerificationToken records returned
        skip
            Ignore the first N results
        where
            VerificationToken filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned VerificationToken model
        order
            Order the returned VerificationToken records by any field
        distinct
            Filter VerificationToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.VerificationToken]
            The list of all VerificationToken records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 VerificationToken records
        verificationtokens = await VerificationToken.prisma().find_many(take=10)

        # find the first 5 VerificationToken records ordered by the expires field
        verificationtokens = await VerificationToken.prisma().find_many(
            take=5,
            order={
                'expires': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.VerificationTokenWhereInput] = None,
        cursor: Optional[types.VerificationTokenWhereUniqueInput] = None,
        include: Optional[types.VerificationTokenInclude] = None,
        order: Optional[Union[types.VerificationTokenOrderByInput, List[types.VerificationTokenOrderByInput]]] = None,
        distinct: Optional[List[types.VerificationTokenScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single VerificationToken record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            VerificationToken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned VerificationToken model
        order
            Order the returned VerificationToken records by any field
        distinct
            Filter VerificationToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.VerificationToken
            The first VerificationToken record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second VerificationToken record ordered by the identifier field
        verificationtoken = await VerificationToken.prisma().find_first(
            skip=1,
            order={
                'identifier': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.VerificationTokenWhereInput] = None,
        cursor: Optional[types.VerificationTokenWhereUniqueInput] = None,
        include: Optional[types.VerificationTokenInclude] = None,
        order: Optional[Union[types.VerificationTokenOrderByInput, List[types.VerificationTokenOrderByInput]]] = None,
        distinct: Optional[List[types.VerificationTokenScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single VerificationToken record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            VerificationToken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned VerificationToken model
        order
            Order the returned VerificationToken records by any field
        distinct
            Filter VerificationToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.VerificationToken
            The first VerificationToken record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second VerificationToken record ordered by the token field
        verificationtoken = await VerificationToken.prisma().find_first_or_raise(
            skip=1,
            order={
                'token': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.VerificationTokenUpdateInput,
        where: types.VerificationTokenWhereUniqueInput,
        include: Optional[types.VerificationTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single VerificationToken record.

        Parameters
        ----------
        data
            VerificationToken record data specifying what to update
        where
            VerificationToken filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned VerificationToken model

        Returns
        -------
        prisma.models.VerificationToken
            The updated VerificationToken record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        verificationtoken = await VerificationToken.prisma().update(
            where={
                'token': 'fcfhgbjed',
            },
            data={
                # data to update the VerificationToken record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.VerificationTokenWhereUniqueInput,
        data: types.VerificationTokenUpsertInput,
        include: Optional[types.VerificationTokenInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            VerificationToken filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned VerificationToken model

        Returns
        -------
        prisma.models.VerificationToken
            The created or updated VerificationToken record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        verificationtoken = await VerificationToken.prisma().upsert(
            where={
                'token': 'hdgcajhjg',
            },
            data={
                'create': {
                    'token': 'hdgcajhjg',
                    'identifier': 'bbcbhebbda',
                    'expires': datetime.datetime.utcnow(),
                },
                'update': {
                    'identifier': 'bbcbhebbda',
                    'expires': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.VerificationTokenUpdateManyMutationInput,
        where: types.VerificationTokenWhereInput,
    ) -> int:
        """Update multiple VerificationToken records

        Parameters
        ----------
        data
            VerificationToken data to update the selected VerificationToken records to
        where
            Filter to select the VerificationToken records to update

        Returns
        -------
        int
            The total number of VerificationToken records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all VerificationToken records
        total = await VerificationToken.prisma().update_many(
            data={
                'expires': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VerificationTokenWhereInput] = None,
        cursor: Optional[types.VerificationTokenWhereUniqueInput] = None,
    ) -> int:
        """Count the number of VerificationToken records present in the database

        Parameters
        ----------
        select
            Select the VerificationToken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            VerificationToken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.VerificationTokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await VerificationToken.prisma().count()

        # results: prisma.types.VerificationTokenCountAggregateOutput
        results = await VerificationToken.prisma().count(
            select={
                '_all': True,
                'identifier': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.VerificationTokenCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VerificationTokenWhereInput] = None,
        cursor: Optional[types.VerificationTokenWhereUniqueInput] = None,
    ) -> types.VerificationTokenCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.VerificationTokenCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VerificationTokenWhereInput] = None,
        cursor: Optional[types.VerificationTokenWhereUniqueInput] = None,
    ) -> Union[int, types.VerificationTokenCountAggregateOutput]:
        """Count the number of VerificationToken records present in the database

        Parameters
        ----------
        select
            Select the VerificationToken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            VerificationToken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.VerificationTokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await VerificationToken.prisma().count()

        # results: prisma.types.VerificationTokenCountAggregateOutput
        results = await VerificationToken.prisma().count(
            select={
                '_all': True,
                'token': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.VerificationTokenCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.VerificationTokenWhereInput] = None
    ) -> int:
        """Delete multiple VerificationToken records.

        Parameters
        ----------
        where
            Optional VerificationToken filter to find the records to be deleted

        Returns
        -------
        int
            The total number of VerificationToken records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all VerificationToken records
        total = await VerificationToken.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.VerificationTokenScalarFieldKeys'],
        *,
        where: Optional['types.VerificationTokenWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.VerificationTokenAvgAggregateInput'] = None,
        sum: Optional['types.VerificationTokenSumAggregateInput'] = None,
        min: Optional['types.VerificationTokenMinAggregateInput'] = None,
        max: Optional['types.VerificationTokenMaxAggregateInput'] = None,
        having: Optional['types.VerificationTokenScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.VerificationTokenCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.VerificationTokenScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.VerificationTokenScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.VerificationTokenGroupByOutput']:
        """Group VerificationToken records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar VerificationToken fields to group records by
        where
            VerificationToken filter to select records
        take
            Limit the maximum number of VerificationToken records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.VerificationTokenGroupByOutput]
            A list of dictionaries representing the VerificationToken record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group VerificationToken records by expires values
        # and count how many records are in each group
        results = await VerificationToken.prisma().group_by(
            ['expires'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class messagesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.messages]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await messages.prisma().query_raw(
            'SELECT * FROM messages WHERE id = $1',
            493907821,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.messages
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await messages.prisma().query_first(
            'SELECT * FROM messages WHERE user_id = $1',
            'gdjgigfgc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.messagesCreateInput,
        include: Optional[types.messagesInclude] = None
    ) -> _PrismaModelT:
        """Create a new messages record.

        Parameters
        ----------
        data
            messages record data
        include
            Specifies which relations should be loaded on the returned messages model

        Returns
        -------
        prisma.models.messages
            The created messages record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a messages record from just the required fields
        messages = await messages.prisma().create(
            data={
                # data to create a messages record
                'user_id': 'gfeaahdeh',
                'message': 'bjafcgbffc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.messagesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple messages records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of messages record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await messages.prisma().create_many(
            data=[
                {
                    # data to create a messages record
                    'user_id': 'hihegjif',
                    'message': 'bdjidcidac',
                },
                {
                    # data to create a messages record
                    'user_id': 'ifgaaagff',
                    'message': 'befcddgjce',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.messagesWhereUniqueInput,
        include: Optional[types.messagesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single messages record.

        Parameters
        ----------
        where
            messages filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned messages model

        Returns
        -------
        prisma.models.messages
            The deleted messages record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        messages = await messages.prisma().delete(
            where={
                'id': 1573199653,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.messagesWhereUniqueInput,
        include: Optional[types.messagesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique messages record.

        Parameters
        ----------
        where
            messages filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned messages model

        Returns
        -------
        prisma.models.messages
            The found messages record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        messages = await messages.prisma().find_unique(
            where={
                'id': 2013903098,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.messagesWhereUniqueInput,
        include: Optional[types.messagesInclude] = None
    ) -> _PrismaModelT:
        """Find a unique messages record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            messages filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned messages model

        Returns
        -------
        prisma.models.messages
            The found messages record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        messages = await messages.prisma().find_unique_or_raise(
            where={
                'id': 500965035,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.messagesWhereInput] = None,
        cursor: Optional[types.messagesWhereUniqueInput] = None,
        include: Optional[types.messagesInclude] = None,
        order: Optional[Union[types.messagesOrderByInput, List[types.messagesOrderByInput]]] = None,
        distinct: Optional[List[types.messagesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple messages records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of messages records returned
        skip
            Ignore the first N results
        where
            messages filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned messages model
        order
            Order the returned messages records by any field
        distinct
            Filter messages records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.messages]
            The list of all messages records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 messages records
        messages = await messages.prisma().find_many(take=10)

        # find the first 5 messages records ordered by the message field
        messages = await messages.prisma().find_many(
            take=5,
            order={
                'message': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.messagesWhereInput] = None,
        cursor: Optional[types.messagesWhereUniqueInput] = None,
        include: Optional[types.messagesInclude] = None,
        order: Optional[Union[types.messagesOrderByInput, List[types.messagesOrderByInput]]] = None,
        distinct: Optional[List[types.messagesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single messages record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            messages filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned messages model
        order
            Order the returned messages records by any field
        distinct
            Filter messages records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.messages
            The first messages record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second messages record ordered by the created_at field
        messages = await messages.prisma().find_first(
            skip=1,
            order={
                'created_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.messagesWhereInput] = None,
        cursor: Optional[types.messagesWhereUniqueInput] = None,
        include: Optional[types.messagesInclude] = None,
        order: Optional[Union[types.messagesOrderByInput, List[types.messagesOrderByInput]]] = None,
        distinct: Optional[List[types.messagesScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single messages record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            messages filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned messages model
        order
            Order the returned messages records by any field
        distinct
            Filter messages records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.messages
            The first messages record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second messages record ordered by the id field
        messages = await messages.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.messagesUpdateInput,
        where: types.messagesWhereUniqueInput,
        include: Optional[types.messagesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single messages record.

        Parameters
        ----------
        data
            messages record data specifying what to update
        where
            messages filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned messages model

        Returns
        -------
        prisma.models.messages
            The updated messages record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        messages = await messages.prisma().update(
            where={
                'id': 1800624392,
            },
            data={
                # data to update the messages record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.messagesWhereUniqueInput,
        data: types.messagesUpsertInput,
        include: Optional[types.messagesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            messages filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned messages model

        Returns
        -------
        prisma.models.messages
            The created or updated messages record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        messages = await messages.prisma().upsert(
            where={
                'id': 2077067425,
            },
            data={
                'create': {
                    'id': 2077067425,
                    'user_id': 'ifgaaagff',
                    'message': 'befcddgjce',
                },
                'update': {
                    'user_id': 'ifgaaagff',
                    'message': 'befcddgjce',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.messagesUpdateManyMutationInput,
        where: types.messagesWhereInput,
    ) -> int:
        """Update multiple messages records

        Parameters
        ----------
        data
            messages data to update the selected messages records to
        where
            Filter to select the messages records to update

        Returns
        -------
        int
            The total number of messages records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all messages records
        total = await messages.prisma().update_many(
            data={
                'user_id': 'bghcbbcidi'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.messagesWhereInput] = None,
        cursor: Optional[types.messagesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of messages records present in the database

        Parameters
        ----------
        select
            Select the messages fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            messages filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.messagesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await messages.prisma().count()

        # results: prisma.types.messagesCountAggregateOutput
        results = await messages.prisma().count(
            select={
                '_all': True,
                'message': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.messagesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.messagesWhereInput] = None,
        cursor: Optional[types.messagesWhereUniqueInput] = None,
    ) -> types.messagesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.messagesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.messagesWhereInput] = None,
        cursor: Optional[types.messagesWhereUniqueInput] = None,
    ) -> Union[int, types.messagesCountAggregateOutput]:
        """Count the number of messages records present in the database

        Parameters
        ----------
        select
            Select the messages fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            messages filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.messagesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await messages.prisma().count()

        # results: prisma.types.messagesCountAggregateOutput
        results = await messages.prisma().count(
            select={
                '_all': True,
                'created_at': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.messagesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.messagesWhereInput] = None
    ) -> int:
        """Delete multiple messages records.

        Parameters
        ----------
        where
            Optional messages filter to find the records to be deleted

        Returns
        -------
        int
            The total number of messages records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all messages records
        total = await messages.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.messagesScalarFieldKeys'],
        *,
        where: Optional['types.messagesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.messagesAvgAggregateInput'] = None,
        sum: Optional['types.messagesSumAggregateInput'] = None,
        min: Optional['types.messagesMinAggregateInput'] = None,
        max: Optional['types.messagesMaxAggregateInput'] = None,
        having: Optional['types.messagesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.messagesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.messagesScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.messagesScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.messagesGroupByOutput']:
        """Group messages records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar messages fields to group records by
        where
            messages filter to select records
        take
            Limit the maximum number of messages records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.messagesGroupByOutput]
            A list of dictionaries representing the messages record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group messages records by id values
        # and count how many records are in each group
        results = await messages.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserBusinessActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserBusiness]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserBusiness.prisma().query_raw(
            'SELECT * FROM UserBusiness WHERE businessId = $1',
            'jcgghhgdj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserBusiness
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserBusiness.prisma().query_first(
            'SELECT * FROM UserBusiness WHERE userId = $1',
            'beehgcebbg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserBusinessCreateInput,
        include: Optional[types.UserBusinessInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserBusiness record.

        Parameters
        ----------
        data
            UserBusiness record data
        include
            Specifies which relations should be loaded on the returned UserBusiness model

        Returns
        -------
        prisma.models.UserBusiness
            The created UserBusiness record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserBusiness record from just the required fields
        userbusiness = await UserBusiness.prisma().create(
            data={
                # data to create a UserBusiness record
                'userId': 'bhdiaidiaf',
                'businessName': 'deajegcfi',
                'businessCategory': 'gabahhhjf',
                'businessLicense': 'cjagadcjg',
                'taxId': 'bifficggej',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserBusinessCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserBusiness records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserBusiness record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserBusiness.prisma().create_many(
            data=[
                {
                    # data to create a UserBusiness record
                    'userId': 'bgbbaajbic',
                    'businessName': 'eegghdhjb',
                    'businessCategory': 'daafgidjg',
                    'businessLicense': 'gdcgcgagj',
                    'taxId': 'bhceabbgja',
                },
                {
                    # data to create a UserBusiness record
                    'userId': 'ehabfhegh',
                    'businessName': 'bcajcajjbc',
                    'businessCategory': 'bfdgheeegf',
                    'businessLicense': 'ececbijji',
                    'taxId': 'cbcfgdcdhf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserBusinessWhereUniqueInput,
        include: Optional[types.UserBusinessInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserBusiness record.

        Parameters
        ----------
        where
            UserBusiness filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserBusiness model

        Returns
        -------
        prisma.models.UserBusiness
            The deleted UserBusiness record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userbusiness = await UserBusiness.prisma().delete(
            where={
                'businessId': 'fdgjfbhia',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserBusinessWhereUniqueInput,
        include: Optional[types.UserBusinessInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserBusiness record.

        Parameters
        ----------
        where
            UserBusiness filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserBusiness model

        Returns
        -------
        prisma.models.UserBusiness
            The found UserBusiness record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userbusiness = await UserBusiness.prisma().find_unique(
            where={
                'businessId': 'jcehcdchh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserBusinessWhereUniqueInput,
        include: Optional[types.UserBusinessInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserBusiness record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserBusiness filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserBusiness model

        Returns
        -------
        prisma.models.UserBusiness
            The found UserBusiness record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userbusiness = await UserBusiness.prisma().find_unique_or_raise(
            where={
                'businessId': 'bgcbjdhjcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserBusinessWhereInput] = None,
        cursor: Optional[types.UserBusinessWhereUniqueInput] = None,
        include: Optional[types.UserBusinessInclude] = None,
        order: Optional[Union[types.UserBusinessOrderByInput, List[types.UserBusinessOrderByInput]]] = None,
        distinct: Optional[List[types.UserBusinessScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserBusiness records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserBusiness records returned
        skip
            Ignore the first N results
        where
            UserBusiness filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserBusiness model
        order
            Order the returned UserBusiness records by any field
        distinct
            Filter UserBusiness records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserBusiness]
            The list of all UserBusiness records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserBusiness records
        userbusiness = await UserBusiness.prisma().find_many(take=10)

        # find the first 5 UserBusiness records ordered by the businessName field
        userbusiness = await UserBusiness.prisma().find_many(
            take=5,
            order={
                'businessName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserBusinessWhereInput] = None,
        cursor: Optional[types.UserBusinessWhereUniqueInput] = None,
        include: Optional[types.UserBusinessInclude] = None,
        order: Optional[Union[types.UserBusinessOrderByInput, List[types.UserBusinessOrderByInput]]] = None,
        distinct: Optional[List[types.UserBusinessScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserBusiness record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserBusiness filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserBusiness model
        order
            Order the returned UserBusiness records by any field
        distinct
            Filter UserBusiness records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserBusiness
            The first UserBusiness record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserBusiness record ordered by the businessCategory field
        userbusiness = await UserBusiness.prisma().find_first(
            skip=1,
            order={
                'businessCategory': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserBusinessWhereInput] = None,
        cursor: Optional[types.UserBusinessWhereUniqueInput] = None,
        include: Optional[types.UserBusinessInclude] = None,
        order: Optional[Union[types.UserBusinessOrderByInput, List[types.UserBusinessOrderByInput]]] = None,
        distinct: Optional[List[types.UserBusinessScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserBusiness record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserBusiness filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserBusiness model
        order
            Order the returned UserBusiness records by any field
        distinct
            Filter UserBusiness records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserBusiness
            The first UserBusiness record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserBusiness record ordered by the businessLicense field
        userbusiness = await UserBusiness.prisma().find_first_or_raise(
            skip=1,
            order={
                'businessLicense': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserBusinessUpdateInput,
        where: types.UserBusinessWhereUniqueInput,
        include: Optional[types.UserBusinessInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserBusiness record.

        Parameters
        ----------
        data
            UserBusiness record data specifying what to update
        where
            UserBusiness filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserBusiness model

        Returns
        -------
        prisma.models.UserBusiness
            The updated UserBusiness record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        userbusiness = await UserBusiness.prisma().update(
            where={
                'businessId': 'bieiidcabj',
            },
            data={
                # data to update the UserBusiness record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserBusinessWhereUniqueInput,
        data: types.UserBusinessUpsertInput,
        include: Optional[types.UserBusinessInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserBusiness filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserBusiness model

        Returns
        -------
        prisma.models.UserBusiness
            The created or updated UserBusiness record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userbusiness = await UserBusiness.prisma().upsert(
            where={
                'businessId': 'bjcbfcieaa',
            },
            data={
                'create': {
                    'businessId': 'bjcbfcieaa',
                    'userId': 'ehabfhegh',
                    'businessName': 'bcajcajjbc',
                    'businessCategory': 'bfdgheeegf',
                    'businessLicense': 'ececbijji',
                    'taxId': 'cbcfgdcdhf',
                },
                'update': {
                    'userId': 'ehabfhegh',
                    'businessName': 'bcajcajjbc',
                    'businessCategory': 'bfdgheeegf',
                    'businessLicense': 'ececbijji',
                    'taxId': 'cbcfgdcdhf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserBusinessUpdateManyMutationInput,
        where: types.UserBusinessWhereInput,
    ) -> int:
        """Update multiple UserBusiness records

        Parameters
        ----------
        data
            UserBusiness data to update the selected UserBusiness records to
        where
            Filter to select the UserBusiness records to update

        Returns
        -------
        int
            The total number of UserBusiness records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserBusiness records
        total = await UserBusiness.prisma().update_many(
            data={
                'taxId': 'cbaaechiej'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserBusinessWhereInput] = None,
        cursor: Optional[types.UserBusinessWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserBusiness records present in the database

        Parameters
        ----------
        select
            Select the UserBusiness fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserBusiness filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserBusinessCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserBusiness.prisma().count()

        # results: prisma.types.UserBusinessCountAggregateOutput
        results = await UserBusiness.prisma().count(
            select={
                '_all': True,
                'businessWebsite': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserBusinessCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserBusinessWhereInput] = None,
        cursor: Optional[types.UserBusinessWhereUniqueInput] = None,
    ) -> types.UserBusinessCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserBusinessCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserBusinessWhereInput] = None,
        cursor: Optional[types.UserBusinessWhereUniqueInput] = None,
    ) -> Union[int, types.UserBusinessCountAggregateOutput]:
        """Count the number of UserBusiness records present in the database

        Parameters
        ----------
        select
            Select the UserBusiness fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserBusiness filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserBusinessCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserBusiness.prisma().count()

        # results: prisma.types.UserBusinessCountAggregateOutput
        results = await UserBusiness.prisma().count(
            select={
                '_all': True,
                'businessId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserBusinessCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserBusinessWhereInput] = None
    ) -> int:
        """Delete multiple UserBusiness records.

        Parameters
        ----------
        where
            Optional UserBusiness filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserBusiness records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserBusiness records
        total = await UserBusiness.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserBusinessScalarFieldKeys'],
        *,
        where: Optional['types.UserBusinessWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserBusinessAvgAggregateInput'] = None,
        sum: Optional['types.UserBusinessSumAggregateInput'] = None,
        min: Optional['types.UserBusinessMinAggregateInput'] = None,
        max: Optional['types.UserBusinessMaxAggregateInput'] = None,
        having: Optional['types.UserBusinessScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserBusinessCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserBusinessScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserBusinessScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserBusinessGroupByOutput']:
        """Group UserBusiness records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserBusiness fields to group records by
        where
            UserBusiness filter to select records
        take
            Limit the maximum number of UserBusiness records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserBusinessGroupByOutput]
            A list of dictionaries representing the UserBusiness record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserBusiness records by userId values
        # and count how many records are in each group
        results = await UserBusiness.prisma().group_by(
            ['userId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserLocationsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserLocations]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserLocations.prisma().query_raw(
            'SELECT * FROM UserLocations WHERE locationId = $1',
            'iejbeaaeg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserLocations
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserLocations.prisma().query_first(
            'SELECT * FROM UserLocations WHERE userId = $1',
            'jcibfcbhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserLocationsCreateInput,
        include: Optional[types.UserLocationsInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserLocations record.

        Parameters
        ----------
        data
            UserLocations record data
        include
            Specifies which relations should be loaded on the returned UserLocations model

        Returns
        -------
        prisma.models.UserLocations
            The created UserLocations record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserLocations record from just the required fields
        userlocations = await UserLocations.prisma().create(
            data={
                # data to create a UserLocations record
                'userId': 'chdadcaga',
                'latitude': 982848517.51073,
                'longitude': 2117488267.140194,
                'addressDetail': 'bcjhgahffd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserLocationsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserLocations records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserLocations record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserLocations.prisma().create_many(
            data=[
                {
                    # data to create a UserLocations record
                    'userId': 'fbjeiiffa',
                    'latitude': 976832615.169642,
                    'longitude': 169262781.102308,
                    'addressDetail': 'dchgibach',
                },
                {
                    # data to create a UserLocations record
                    'userId': 'fchheijjc',
                    'latitude': 2029357497.131859,
                    'longitude': 2122112351.102494,
                    'addressDetail': 'bhbhdahfaj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserLocationsWhereUniqueInput,
        include: Optional[types.UserLocationsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserLocations record.

        Parameters
        ----------
        where
            UserLocations filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserLocations model

        Returns
        -------
        prisma.models.UserLocations
            The deleted UserLocations record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userlocations = await UserLocations.prisma().delete(
            where={
                'locationId': 'bfjibceaec',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserLocationsWhereUniqueInput,
        include: Optional[types.UserLocationsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserLocations record.

        Parameters
        ----------
        where
            UserLocations filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserLocations model

        Returns
        -------
        prisma.models.UserLocations
            The found UserLocations record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userlocations = await UserLocations.prisma().find_unique(
            where={
                'locationId': 'ibhgcdbgd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserLocationsWhereUniqueInput,
        include: Optional[types.UserLocationsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserLocations record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserLocations filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserLocations model

        Returns
        -------
        prisma.models.UserLocations
            The found UserLocations record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userlocations = await UserLocations.prisma().find_unique_or_raise(
            where={
                'locationId': 'badaffhddg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserLocationsWhereInput] = None,
        cursor: Optional[types.UserLocationsWhereUniqueInput] = None,
        include: Optional[types.UserLocationsInclude] = None,
        order: Optional[Union[types.UserLocationsOrderByInput, List[types.UserLocationsOrderByInput]]] = None,
        distinct: Optional[List[types.UserLocationsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserLocations records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserLocations records returned
        skip
            Ignore the first N results
        where
            UserLocations filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserLocations model
        order
            Order the returned UserLocations records by any field
        distinct
            Filter UserLocations records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserLocations]
            The list of all UserLocations records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserLocations records
        userlocations = await UserLocations.prisma().find_many(take=10)

        # find the first 5 UserLocations records ordered by the latitude field
        userlocations = await UserLocations.prisma().find_many(
            take=5,
            order={
                'latitude': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserLocationsWhereInput] = None,
        cursor: Optional[types.UserLocationsWhereUniqueInput] = None,
        include: Optional[types.UserLocationsInclude] = None,
        order: Optional[Union[types.UserLocationsOrderByInput, List[types.UserLocationsOrderByInput]]] = None,
        distinct: Optional[List[types.UserLocationsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserLocations record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserLocations filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserLocations model
        order
            Order the returned UserLocations records by any field
        distinct
            Filter UserLocations records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserLocations
            The first UserLocations record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserLocations record ordered by the longitude field
        userlocations = await UserLocations.prisma().find_first(
            skip=1,
            order={
                'longitude': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserLocationsWhereInput] = None,
        cursor: Optional[types.UserLocationsWhereUniqueInput] = None,
        include: Optional[types.UserLocationsInclude] = None,
        order: Optional[Union[types.UserLocationsOrderByInput, List[types.UserLocationsOrderByInput]]] = None,
        distinct: Optional[List[types.UserLocationsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserLocations record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserLocations filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserLocations model
        order
            Order the returned UserLocations records by any field
        distinct
            Filter UserLocations records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserLocations
            The first UserLocations record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserLocations record ordered by the addressDetail field
        userlocations = await UserLocations.prisma().find_first_or_raise(
            skip=1,
            order={
                'addressDetail': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserLocationsUpdateInput,
        where: types.UserLocationsWhereUniqueInput,
        include: Optional[types.UserLocationsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserLocations record.

        Parameters
        ----------
        data
            UserLocations record data specifying what to update
        where
            UserLocations filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserLocations model

        Returns
        -------
        prisma.models.UserLocations
            The updated UserLocations record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        userlocations = await UserLocations.prisma().update(
            where={
                'locationId': 'bbdbfcfihd',
            },
            data={
                # data to update the UserLocations record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserLocationsWhereUniqueInput,
        data: types.UserLocationsUpsertInput,
        include: Optional[types.UserLocationsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserLocations filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserLocations model

        Returns
        -------
        prisma.models.UserLocations
            The created or updated UserLocations record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userlocations = await UserLocations.prisma().upsert(
            where={
                'locationId': 'cbagggbji',
            },
            data={
                'create': {
                    'locationId': 'cbagggbji',
                    'userId': 'fchheijjc',
                    'latitude': 2029357497.131859,
                    'longitude': 2122112351.102494,
                    'addressDetail': 'bhbhdahfaj',
                },
                'update': {
                    'userId': 'fchheijjc',
                    'latitude': 2029357497.131859,
                    'longitude': 2122112351.102494,
                    'addressDetail': 'bhbhdahfaj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserLocationsUpdateManyMutationInput,
        where: types.UserLocationsWhereInput,
    ) -> int:
        """Update multiple UserLocations records

        Parameters
        ----------
        data
            UserLocations data to update the selected UserLocations records to
        where
            Filter to select the UserLocations records to update

        Returns
        -------
        int
            The total number of UserLocations records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserLocations records
        total = await UserLocations.prisma().update_many(
            data={
                'isPrimary': False
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserLocationsWhereInput] = None,
        cursor: Optional[types.UserLocationsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserLocations records present in the database

        Parameters
        ----------
        select
            Select the UserLocations fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserLocations filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserLocationsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserLocations.prisma().count()

        # results: prisma.types.UserLocationsCountAggregateOutput
        results = await UserLocations.prisma().count(
            select={
                '_all': True,
                'locationId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserLocationsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserLocationsWhereInput] = None,
        cursor: Optional[types.UserLocationsWhereUniqueInput] = None,
    ) -> types.UserLocationsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserLocationsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserLocationsWhereInput] = None,
        cursor: Optional[types.UserLocationsWhereUniqueInput] = None,
    ) -> Union[int, types.UserLocationsCountAggregateOutput]:
        """Count the number of UserLocations records present in the database

        Parameters
        ----------
        select
            Select the UserLocations fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserLocations filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserLocationsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserLocations.prisma().count()

        # results: prisma.types.UserLocationsCountAggregateOutput
        results = await UserLocations.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserLocationsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserLocationsWhereInput] = None
    ) -> int:
        """Delete multiple UserLocations records.

        Parameters
        ----------
        where
            Optional UserLocations filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserLocations records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserLocations records
        total = await UserLocations.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserLocationsScalarFieldKeys'],
        *,
        where: Optional['types.UserLocationsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserLocationsAvgAggregateInput'] = None,
        sum: Optional['types.UserLocationsSumAggregateInput'] = None,
        min: Optional['types.UserLocationsMinAggregateInput'] = None,
        max: Optional['types.UserLocationsMaxAggregateInput'] = None,
        having: Optional['types.UserLocationsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserLocationsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserLocationsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserLocationsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserLocationsGroupByOutput']:
        """Group UserLocations records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserLocations fields to group records by
        where
            UserLocations filter to select records
        take
            Limit the maximum number of UserLocations records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserLocationsGroupByOutput]
            A list of dictionaries representing the UserLocations record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserLocations records by latitude values
        # and count how many records are in each group
        results = await UserLocations.prisma().group_by(
            ['latitude'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserFinanceActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserFinance]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserFinance.prisma().query_raw(
            'SELECT * FROM UserFinance WHERE financeId = $1',
            'heffgjdei',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserFinance
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserFinance.prisma().query_first(
            'SELECT * FROM UserFinance WHERE userId = $1',
            'dahihgbeb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserFinanceCreateInput,
        include: Optional[types.UserFinanceInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserFinance record.

        Parameters
        ----------
        data
            UserFinance record data
        include
            Specifies which relations should be loaded on the returned UserFinance model

        Returns
        -------
        prisma.models.UserFinance
            The created UserFinance record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserFinance record from just the required fields
        userfinance = await UserFinance.prisma().create(
            data={
                # data to create a UserFinance record
                'userId': 'bgheaejbcc',
                'currency': 'bfcgifeged',
                'paymentMethods': Json({'jfiahhbae': True}),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserFinanceCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserFinance records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserFinance record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserFinance.prisma().create_many(
            data=[
                {
                    # data to create a UserFinance record
                    'userId': 'bfbdafajcb',
                    'currency': 'caeghehde',
                    'paymentMethods': Json({'caghgfbggd': True}),
                },
                {
                    # data to create a UserFinance record
                    'userId': 'bbidjbbjaa',
                    'currency': 'bfijhaejdd',
                    'paymentMethods': Json({'bcedehfiji': True}),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserFinanceWhereUniqueInput,
        include: Optional[types.UserFinanceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserFinance record.

        Parameters
        ----------
        where
            UserFinance filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserFinance model

        Returns
        -------
        prisma.models.UserFinance
            The deleted UserFinance record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userfinance = await UserFinance.prisma().delete(
            where={
                'financeId': 'bdgjicijhb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserFinanceWhereUniqueInput,
        include: Optional[types.UserFinanceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserFinance record.

        Parameters
        ----------
        where
            UserFinance filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserFinance model

        Returns
        -------
        prisma.models.UserFinance
            The found UserFinance record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userfinance = await UserFinance.prisma().find_unique(
            where={
                'financeId': 'bghifjdeia',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserFinanceWhereUniqueInput,
        include: Optional[types.UserFinanceInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserFinance record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserFinance filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserFinance model

        Returns
        -------
        prisma.models.UserFinance
            The found UserFinance record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userfinance = await UserFinance.prisma().find_unique_or_raise(
            where={
                'financeId': 'eadfcbbcb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserFinanceWhereInput] = None,
        cursor: Optional[types.UserFinanceWhereUniqueInput] = None,
        include: Optional[types.UserFinanceInclude] = None,
        order: Optional[Union[types.UserFinanceOrderByInput, List[types.UserFinanceOrderByInput]]] = None,
        distinct: Optional[List[types.UserFinanceScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserFinance records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserFinance records returned
        skip
            Ignore the first N results
        where
            UserFinance filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserFinance model
        order
            Order the returned UserFinance records by any field
        distinct
            Filter UserFinance records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserFinance]
            The list of all UserFinance records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserFinance records
        userfinances = await UserFinance.prisma().find_many(take=10)

        # find the first 5 UserFinance records ordered by the balance field
        userfinances = await UserFinance.prisma().find_many(
            take=5,
            order={
                'balance': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserFinanceWhereInput] = None,
        cursor: Optional[types.UserFinanceWhereUniqueInput] = None,
        include: Optional[types.UserFinanceInclude] = None,
        order: Optional[Union[types.UserFinanceOrderByInput, List[types.UserFinanceOrderByInput]]] = None,
        distinct: Optional[List[types.UserFinanceScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserFinance record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserFinance filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserFinance model
        order
            Order the returned UserFinance records by any field
        distinct
            Filter UserFinance records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserFinance
            The first UserFinance record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserFinance record ordered by the currency field
        userfinance = await UserFinance.prisma().find_first(
            skip=1,
            order={
                'currency': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserFinanceWhereInput] = None,
        cursor: Optional[types.UserFinanceWhereUniqueInput] = None,
        include: Optional[types.UserFinanceInclude] = None,
        order: Optional[Union[types.UserFinanceOrderByInput, List[types.UserFinanceOrderByInput]]] = None,
        distinct: Optional[List[types.UserFinanceScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserFinance record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserFinance filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserFinance model
        order
            Order the returned UserFinance records by any field
        distinct
            Filter UserFinance records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserFinance
            The first UserFinance record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserFinance record ordered by the paymentMethods field
        userfinance = await UserFinance.prisma().find_first_or_raise(
            skip=1,
            order={
                'paymentMethods': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserFinanceUpdateInput,
        where: types.UserFinanceWhereUniqueInput,
        include: Optional[types.UserFinanceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserFinance record.

        Parameters
        ----------
        data
            UserFinance record data specifying what to update
        where
            UserFinance filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserFinance model

        Returns
        -------
        prisma.models.UserFinance
            The updated UserFinance record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        userfinance = await UserFinance.prisma().update(
            where={
                'financeId': 'geihgahba',
            },
            data={
                # data to update the UserFinance record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserFinanceWhereUniqueInput,
        data: types.UserFinanceUpsertInput,
        include: Optional[types.UserFinanceInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserFinance filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserFinance model

        Returns
        -------
        prisma.models.UserFinance
            The created or updated UserFinance record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userfinance = await UserFinance.prisma().upsert(
            where={
                'financeId': 'gahdcdhbj',
            },
            data={
                'create': {
                    'financeId': 'gahdcdhbj',
                    'userId': 'bbidjbbjaa',
                    'currency': 'bfijhaejdd',
                    'paymentMethods': Json({'bcedehfiji': True}),
                },
                'update': {
                    'userId': 'bbidjbbjaa',
                    'currency': 'bfijhaejdd',
                    'paymentMethods': Json({'bcedehfiji': True}),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserFinanceUpdateManyMutationInput,
        where: types.UserFinanceWhereInput,
    ) -> int:
        """Update multiple UserFinance records

        Parameters
        ----------
        data
            UserFinance data to update the selected UserFinance records to
        where
            Filter to select the UserFinance records to update

        Returns
        -------
        int
            The total number of UserFinance records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserFinance records
        total = await UserFinance.prisma().update_many(
            data={
                'loyaltyPoints': 1468890740
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserFinanceWhereInput] = None,
        cursor: Optional[types.UserFinanceWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserFinance records present in the database

        Parameters
        ----------
        select
            Select the UserFinance fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserFinance filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserFinanceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserFinance.prisma().count()

        # results: prisma.types.UserFinanceCountAggregateOutput
        results = await UserFinance.prisma().count(
            select={
                '_all': True,
                'financeId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserFinanceCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserFinanceWhereInput] = None,
        cursor: Optional[types.UserFinanceWhereUniqueInput] = None,
    ) -> types.UserFinanceCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserFinanceCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserFinanceWhereInput] = None,
        cursor: Optional[types.UserFinanceWhereUniqueInput] = None,
    ) -> Union[int, types.UserFinanceCountAggregateOutput]:
        """Count the number of UserFinance records present in the database

        Parameters
        ----------
        select
            Select the UserFinance fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserFinance filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserFinanceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserFinance.prisma().count()

        # results: prisma.types.UserFinanceCountAggregateOutput
        results = await UserFinance.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserFinanceCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserFinanceWhereInput] = None
    ) -> int:
        """Delete multiple UserFinance records.

        Parameters
        ----------
        where
            Optional UserFinance filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserFinance records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserFinance records
        total = await UserFinance.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserFinanceScalarFieldKeys'],
        *,
        where: Optional['types.UserFinanceWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserFinanceAvgAggregateInput'] = None,
        sum: Optional['types.UserFinanceSumAggregateInput'] = None,
        min: Optional['types.UserFinanceMinAggregateInput'] = None,
        max: Optional['types.UserFinanceMaxAggregateInput'] = None,
        having: Optional['types.UserFinanceScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserFinanceCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserFinanceScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserFinanceScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserFinanceGroupByOutput']:
        """Group UserFinance records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserFinance fields to group records by
        where
            UserFinance filter to select records
        take
            Limit the maximum number of UserFinance records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserFinanceGroupByOutput]
            A list of dictionaries representing the UserFinance record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserFinance records by balance values
        # and count how many records are in each group
        results = await UserFinance.prisma().group_by(
            ['balance'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserSubscriptionsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserSubscriptions]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserSubscriptions.prisma().query_raw(
            'SELECT * FROM UserSubscriptions WHERE subscriptionId = $1',
            'gcjadjaaf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserSubscriptions
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserSubscriptions.prisma().query_first(
            'SELECT * FROM UserSubscriptions WHERE userId = $1',
            'bcbebgiaic',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserSubscriptionsCreateInput,
        include: Optional[types.UserSubscriptionsInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserSubscriptions record.

        Parameters
        ----------
        data
            UserSubscriptions record data
        include
            Specifies which relations should be loaded on the returned UserSubscriptions model

        Returns
        -------
        prisma.models.UserSubscriptions
            The created UserSubscriptions record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserSubscriptions record from just the required fields
        usersubscriptions = await UserSubscriptions.prisma().create(
            data={
                # data to create a UserSubscriptions record
                'userId': 'ijigbdcbj',
                'planId': 'gfidhicai',
                'tokenLimit': 954620057,
                'tokenResetAt': datetime.datetime.utcnow(),
                'subscriptionStart': datetime.datetime.utcnow(),
                'subscriptionEnd': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserSubscriptionsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserSubscriptions records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserSubscriptions record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserSubscriptions.prisma().create_many(
            data=[
                {
                    # data to create a UserSubscriptions record
                    'userId': 'bcbeiajjfa',
                    'planId': 'baehicaajf',
                    'tokenLimit': 1302734860,
                    'tokenResetAt': datetime.datetime.utcnow(),
                    'subscriptionStart': datetime.datetime.utcnow(),
                    'subscriptionEnd': datetime.datetime.utcnow(),
                },
                {
                    # data to create a UserSubscriptions record
                    'userId': 'ijdafccef',
                    'planId': 'ciaaiddag',
                    'tokenLimit': 549668955,
                    'tokenResetAt': datetime.datetime.utcnow(),
                    'subscriptionStart': datetime.datetime.utcnow(),
                    'subscriptionEnd': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserSubscriptionsWhereUniqueInput,
        include: Optional[types.UserSubscriptionsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserSubscriptions record.

        Parameters
        ----------
        where
            UserSubscriptions filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserSubscriptions model

        Returns
        -------
        prisma.models.UserSubscriptions
            The deleted UserSubscriptions record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usersubscriptions = await UserSubscriptions.prisma().delete(
            where={
                'subscriptionId': 'hghjaaai',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserSubscriptionsWhereUniqueInput,
        include: Optional[types.UserSubscriptionsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserSubscriptions record.

        Parameters
        ----------
        where
            UserSubscriptions filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserSubscriptions model

        Returns
        -------
        prisma.models.UserSubscriptions
            The found UserSubscriptions record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usersubscriptions = await UserSubscriptions.prisma().find_unique(
            where={
                'subscriptionId': 'cajicjjdef',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserSubscriptionsWhereUniqueInput,
        include: Optional[types.UserSubscriptionsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserSubscriptions record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserSubscriptions filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserSubscriptions model

        Returns
        -------
        prisma.models.UserSubscriptions
            The found UserSubscriptions record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usersubscriptions = await UserSubscriptions.prisma().find_unique_or_raise(
            where={
                'subscriptionId': 'cefjaadec',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserSubscriptionsWhereInput] = None,
        cursor: Optional[types.UserSubscriptionsWhereUniqueInput] = None,
        include: Optional[types.UserSubscriptionsInclude] = None,
        order: Optional[Union[types.UserSubscriptionsOrderByInput, List[types.UserSubscriptionsOrderByInput]]] = None,
        distinct: Optional[List[types.UserSubscriptionsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserSubscriptions records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserSubscriptions records returned
        skip
            Ignore the first N results
        where
            UserSubscriptions filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserSubscriptions model
        order
            Order the returned UserSubscriptions records by any field
        distinct
            Filter UserSubscriptions records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserSubscriptions]
            The list of all UserSubscriptions records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserSubscriptions records
        usersubscriptions = await UserSubscriptions.prisma().find_many(take=10)

        # find the first 5 UserSubscriptions records ordered by the planId field
        usersubscriptions = await UserSubscriptions.prisma().find_many(
            take=5,
            order={
                'planId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserSubscriptionsWhereInput] = None,
        cursor: Optional[types.UserSubscriptionsWhereUniqueInput] = None,
        include: Optional[types.UserSubscriptionsInclude] = None,
        order: Optional[Union[types.UserSubscriptionsOrderByInput, List[types.UserSubscriptionsOrderByInput]]] = None,
        distinct: Optional[List[types.UserSubscriptionsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserSubscriptions record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserSubscriptions filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserSubscriptions model
        order
            Order the returned UserSubscriptions records by any field
        distinct
            Filter UserSubscriptions records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserSubscriptions
            The first UserSubscriptions record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserSubscriptions record ordered by the tokenUsage field
        usersubscriptions = await UserSubscriptions.prisma().find_first(
            skip=1,
            order={
                'tokenUsage': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserSubscriptionsWhereInput] = None,
        cursor: Optional[types.UserSubscriptionsWhereUniqueInput] = None,
        include: Optional[types.UserSubscriptionsInclude] = None,
        order: Optional[Union[types.UserSubscriptionsOrderByInput, List[types.UserSubscriptionsOrderByInput]]] = None,
        distinct: Optional[List[types.UserSubscriptionsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserSubscriptions record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserSubscriptions filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserSubscriptions model
        order
            Order the returned UserSubscriptions records by any field
        distinct
            Filter UserSubscriptions records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserSubscriptions
            The first UserSubscriptions record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserSubscriptions record ordered by the tokenLimit field
        usersubscriptions = await UserSubscriptions.prisma().find_first_or_raise(
            skip=1,
            order={
                'tokenLimit': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserSubscriptionsUpdateInput,
        where: types.UserSubscriptionsWhereUniqueInput,
        include: Optional[types.UserSubscriptionsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserSubscriptions record.

        Parameters
        ----------
        data
            UserSubscriptions record data specifying what to update
        where
            UserSubscriptions filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserSubscriptions model

        Returns
        -------
        prisma.models.UserSubscriptions
            The updated UserSubscriptions record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        usersubscriptions = await UserSubscriptions.prisma().update(
            where={
                'subscriptionId': 'ibbigdigd',
            },
            data={
                # data to update the UserSubscriptions record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserSubscriptionsWhereUniqueInput,
        data: types.UserSubscriptionsUpsertInput,
        include: Optional[types.UserSubscriptionsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserSubscriptions filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserSubscriptions model

        Returns
        -------
        prisma.models.UserSubscriptions
            The created or updated UserSubscriptions record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usersubscriptions = await UserSubscriptions.prisma().upsert(
            where={
                'subscriptionId': 'bdiiiabbii',
            },
            data={
                'create': {
                    'subscriptionId': 'bdiiiabbii',
                    'userId': 'ijdafccef',
                    'planId': 'ciaaiddag',
                    'tokenLimit': 549668955,
                    'tokenResetAt': datetime.datetime.utcnow(),
                    'subscriptionStart': datetime.datetime.utcnow(),
                    'subscriptionEnd': datetime.datetime.utcnow(),
                },
                'update': {
                    'userId': 'ijdafccef',
                    'planId': 'ciaaiddag',
                    'tokenLimit': 549668955,
                    'tokenResetAt': datetime.datetime.utcnow(),
                    'subscriptionStart': datetime.datetime.utcnow(),
                    'subscriptionEnd': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserSubscriptionsUpdateManyMutationInput,
        where: types.UserSubscriptionsWhereInput,
    ) -> int:
        """Update multiple UserSubscriptions records

        Parameters
        ----------
        data
            UserSubscriptions data to update the selected UserSubscriptions records to
        where
            Filter to select the UserSubscriptions records to update

        Returns
        -------
        int
            The total number of UserSubscriptions records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserSubscriptions records
        total = await UserSubscriptions.prisma().update_many(
            data={
                'tokenResetAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserSubscriptionsWhereInput] = None,
        cursor: Optional[types.UserSubscriptionsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserSubscriptions records present in the database

        Parameters
        ----------
        select
            Select the UserSubscriptions fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserSubscriptions filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserSubscriptionsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserSubscriptions.prisma().count()

        # results: prisma.types.UserSubscriptionsCountAggregateOutput
        results = await UserSubscriptions.prisma().count(
            select={
                '_all': True,
                'subscriptionStart': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserSubscriptionsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserSubscriptionsWhereInput] = None,
        cursor: Optional[types.UserSubscriptionsWhereUniqueInput] = None,
    ) -> types.UserSubscriptionsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserSubscriptionsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserSubscriptionsWhereInput] = None,
        cursor: Optional[types.UserSubscriptionsWhereUniqueInput] = None,
    ) -> Union[int, types.UserSubscriptionsCountAggregateOutput]:
        """Count the number of UserSubscriptions records present in the database

        Parameters
        ----------
        select
            Select the UserSubscriptions fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserSubscriptions filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserSubscriptionsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserSubscriptions.prisma().count()

        # results: prisma.types.UserSubscriptionsCountAggregateOutput
        results = await UserSubscriptions.prisma().count(
            select={
                '_all': True,
                'subscriptionEnd': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserSubscriptionsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserSubscriptionsWhereInput] = None
    ) -> int:
        """Delete multiple UserSubscriptions records.

        Parameters
        ----------
        where
            Optional UserSubscriptions filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserSubscriptions records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserSubscriptions records
        total = await UserSubscriptions.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserSubscriptionsScalarFieldKeys'],
        *,
        where: Optional['types.UserSubscriptionsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserSubscriptionsAvgAggregateInput'] = None,
        sum: Optional['types.UserSubscriptionsSumAggregateInput'] = None,
        min: Optional['types.UserSubscriptionsMinAggregateInput'] = None,
        max: Optional['types.UserSubscriptionsMaxAggregateInput'] = None,
        having: Optional['types.UserSubscriptionsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserSubscriptionsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserSubscriptionsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserSubscriptionsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserSubscriptionsGroupByOutput']:
        """Group UserSubscriptions records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserSubscriptions fields to group records by
        where
            UserSubscriptions filter to select records
        take
            Limit the maximum number of UserSubscriptions records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserSubscriptionsGroupByOutput]
            A list of dictionaries representing the UserSubscriptions record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserSubscriptions records by subscriptionId values
        # and count how many records are in each group
        results = await UserSubscriptions.prisma().group_by(
            ['subscriptionId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PlansActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Plans]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Plans.prisma().query_raw(
            'SELECT * FROM Plans WHERE planId = $1',
            'hfcfhhadh',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Plans
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Plans.prisma().query_first(
            'SELECT * FROM Plans WHERE planName = $1',
            'bbihggdcji',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PlansCreateInput,
        include: Optional[types.PlansInclude] = None
    ) -> _PrismaModelT:
        """Create a new Plans record.

        Parameters
        ----------
        data
            Plans record data
        include
            Specifies which relations should be loaded on the returned Plans model

        Returns
        -------
        prisma.models.Plans
            The created Plans record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Plans record from just the required fields
        plans = await Plans.prisma().create(
            data={
                # data to create a Plans record
                'planName': 'hgjgibdgd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PlansCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Plans records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Plans record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Plans.prisma().create_many(
            data=[
                {
                    # data to create a Plans record
                    'planName': 'bcbecjfice',
                },
                {
                    # data to create a Plans record
                    'planName': 'bacbebhjjd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PlansWhereUniqueInput,
        include: Optional[types.PlansInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Plans record.

        Parameters
        ----------
        where
            Plans filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Plans model

        Returns
        -------
        prisma.models.Plans
            The deleted Plans record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        plans = await Plans.prisma().delete(
            where={
                'planId': 'dfbfaddhe',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PlansWhereUniqueInput,
        include: Optional[types.PlansInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Plans record.

        Parameters
        ----------
        where
            Plans filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Plans model

        Returns
        -------
        prisma.models.Plans
            The found Plans record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        plans = await Plans.prisma().find_unique(
            where={
                'planId': 'bdcbbieibf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PlansWhereUniqueInput,
        include: Optional[types.PlansInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Plans record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Plans filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Plans model

        Returns
        -------
        prisma.models.Plans
            The found Plans record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        plans = await Plans.prisma().find_unique_or_raise(
            where={
                'planId': 'dgjhdcggi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlansWhereInput] = None,
        cursor: Optional[types.PlansWhereUniqueInput] = None,
        include: Optional[types.PlansInclude] = None,
        order: Optional[Union[types.PlansOrderByInput, List[types.PlansOrderByInput]]] = None,
        distinct: Optional[List[types.PlansScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Plans records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Plans records returned
        skip
            Ignore the first N results
        where
            Plans filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Plans model
        order
            Order the returned Plans records by any field
        distinct
            Filter Plans records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Plans]
            The list of all Plans records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Plans records
        plans = await Plans.prisma().find_many(take=10)

        # find the first 5 Plans records ordered by the planId field
        plans = await Plans.prisma().find_many(
            take=5,
            order={
                'planId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PlansWhereInput] = None,
        cursor: Optional[types.PlansWhereUniqueInput] = None,
        include: Optional[types.PlansInclude] = None,
        order: Optional[Union[types.PlansOrderByInput, List[types.PlansOrderByInput]]] = None,
        distinct: Optional[List[types.PlansScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Plans record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Plans filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Plans model
        order
            Order the returned Plans records by any field
        distinct
            Filter Plans records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Plans
            The first Plans record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Plans record ordered by the planName field
        plans = await Plans.prisma().find_first(
            skip=1,
            order={
                'planName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PlansWhereInput] = None,
        cursor: Optional[types.PlansWhereUniqueInput] = None,
        include: Optional[types.PlansInclude] = None,
        order: Optional[Union[types.PlansOrderByInput, List[types.PlansOrderByInput]]] = None,
        distinct: Optional[List[types.PlansScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Plans record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Plans filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Plans model
        order
            Order the returned Plans records by any field
        distinct
            Filter Plans records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Plans
            The first Plans record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Plans record ordered by the planId field
        plans = await Plans.prisma().find_first_or_raise(
            skip=1,
            order={
                'planId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PlansUpdateInput,
        where: types.PlansWhereUniqueInput,
        include: Optional[types.PlansInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Plans record.

        Parameters
        ----------
        data
            Plans record data specifying what to update
        where
            Plans filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Plans model

        Returns
        -------
        prisma.models.Plans
            The updated Plans record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        plans = await Plans.prisma().update(
            where={
                'planId': 'bbjbcdfabd',
            },
            data={
                # data to update the Plans record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PlansWhereUniqueInput,
        data: types.PlansUpsertInput,
        include: Optional[types.PlansInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Plans filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Plans model

        Returns
        -------
        prisma.models.Plans
            The created or updated Plans record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        plans = await Plans.prisma().upsert(
            where={
                'planId': 'gchfgbcec',
            },
            data={
                'create': {
                    'planId': 'gchfgbcec',
                    'planName': 'bacbebhjjd',
                },
                'update': {
                    'planName': 'bacbebhjjd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PlansUpdateManyMutationInput,
        where: types.PlansWhereInput,
    ) -> int:
        """Update multiple Plans records

        Parameters
        ----------
        data
            Plans data to update the selected Plans records to
        where
            Filter to select the Plans records to update

        Returns
        -------
        int
            The total number of Plans records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Plans records
        total = await Plans.prisma().update_many(
            data={
                'planName': 'bihcjfcjah'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlansWhereInput] = None,
        cursor: Optional[types.PlansWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Plans records present in the database

        Parameters
        ----------
        select
            Select the Plans fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Plans filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PlansCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Plans.prisma().count()

        # results: prisma.types.PlansCountAggregateOutput
        results = await Plans.prisma().count(
            select={
                '_all': True,
                'planId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PlansCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlansWhereInput] = None,
        cursor: Optional[types.PlansWhereUniqueInput] = None,
    ) -> types.PlansCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PlansCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlansWhereInput] = None,
        cursor: Optional[types.PlansWhereUniqueInput] = None,
    ) -> Union[int, types.PlansCountAggregateOutput]:
        """Count the number of Plans records present in the database

        Parameters
        ----------
        select
            Select the Plans fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Plans filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PlansCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Plans.prisma().count()

        # results: prisma.types.PlansCountAggregateOutput
        results = await Plans.prisma().count(
            select={
                '_all': True,
                'planName': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PlansCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PlansWhereInput] = None
    ) -> int:
        """Delete multiple Plans records.

        Parameters
        ----------
        where
            Optional Plans filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Plans records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Plans records
        total = await Plans.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PlansScalarFieldKeys'],
        *,
        where: Optional['types.PlansWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PlansAvgAggregateInput'] = None,
        sum: Optional['types.PlansSumAggregateInput'] = None,
        min: Optional['types.PlansMinAggregateInput'] = None,
        max: Optional['types.PlansMaxAggregateInput'] = None,
        having: Optional['types.PlansScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PlansCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PlansScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.PlansScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.PlansGroupByOutput']:
        """Group Plans records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Plans fields to group records by
        where
            Plans filter to select records
        take
            Limit the maximum number of Plans records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PlansGroupByOutput]
            A list of dictionaries representing the Plans record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Plans records by planId values
        # and count how many records are in each group
        results = await Plans.prisma().group_by(
            ['planId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserAISettingsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserAISettings]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserAISettings.prisma().query_raw(
            'SELECT * FROM UserAISettings WHERE aiSettingsId = $1',
            'bhjdcicaii',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserAISettings
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserAISettings.prisma().query_first(
            'SELECT * FROM UserAISettings WHERE userId = $1',
            'bibedjhcej',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserAISettingsCreateInput,
        include: Optional[types.UserAISettingsInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserAISettings record.

        Parameters
        ----------
        data
            UserAISettings record data
        include
            Specifies which relations should be loaded on the returned UserAISettings model

        Returns
        -------
        prisma.models.UserAISettings
            The created UserAISettings record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserAISettings record from just the required fields
        useraisettings = await UserAISettings.prisma().create(
            data={
                # data to create a UserAISettings record
                'userId': 'bjcdajabfa',
                'botSlug': 'bchhceeeff',
                'aiPersonalityProfile': Json({'bbgaifhdaa': True}),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserAISettingsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserAISettings records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserAISettings record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserAISettings.prisma().create_many(
            data=[
                {
                    # data to create a UserAISettings record
                    'userId': 'dgbcdaegb',
                    'botSlug': 'beagfbbjig',
                    'aiPersonalityProfile': Json({'beicihhijb': True}),
                },
                {
                    # data to create a UserAISettings record
                    'userId': 'fgggcdcjg',
                    'botSlug': 'ccjbbjigf',
                    'aiPersonalityProfile': Json({'bhfaabbaha': True}),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserAISettingsWhereUniqueInput,
        include: Optional[types.UserAISettingsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserAISettings record.

        Parameters
        ----------
        where
            UserAISettings filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserAISettings model

        Returns
        -------
        prisma.models.UserAISettings
            The deleted UserAISettings record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        useraisettings = await UserAISettings.prisma().delete(
            where={
                'aiSettingsId': 'ebajedhhf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserAISettingsWhereUniqueInput,
        include: Optional[types.UserAISettingsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserAISettings record.

        Parameters
        ----------
        where
            UserAISettings filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserAISettings model

        Returns
        -------
        prisma.models.UserAISettings
            The found UserAISettings record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        useraisettings = await UserAISettings.prisma().find_unique(
            where={
                'aiSettingsId': 'jajacedge',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserAISettingsWhereUniqueInput,
        include: Optional[types.UserAISettingsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserAISettings record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserAISettings filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserAISettings model

        Returns
        -------
        prisma.models.UserAISettings
            The found UserAISettings record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        useraisettings = await UserAISettings.prisma().find_unique_or_raise(
            where={
                'aiSettingsId': 'hffgbabgf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserAISettingsWhereInput] = None,
        cursor: Optional[types.UserAISettingsWhereUniqueInput] = None,
        include: Optional[types.UserAISettingsInclude] = None,
        order: Optional[Union[types.UserAISettingsOrderByInput, List[types.UserAISettingsOrderByInput]]] = None,
        distinct: Optional[List[types.UserAISettingsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserAISettings records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserAISettings records returned
        skip
            Ignore the first N results
        where
            UserAISettings filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserAISettings model
        order
            Order the returned UserAISettings records by any field
        distinct
            Filter UserAISettings records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserAISettings]
            The list of all UserAISettings records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserAISettings records
        useraisettings = await UserAISettings.prisma().find_many(take=10)

        # find the first 5 UserAISettings records ordered by the botSlug field
        useraisettings = await UserAISettings.prisma().find_many(
            take=5,
            order={
                'botSlug': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserAISettingsWhereInput] = None,
        cursor: Optional[types.UserAISettingsWhereUniqueInput] = None,
        include: Optional[types.UserAISettingsInclude] = None,
        order: Optional[Union[types.UserAISettingsOrderByInput, List[types.UserAISettingsOrderByInput]]] = None,
        distinct: Optional[List[types.UserAISettingsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserAISettings record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserAISettings filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserAISettings model
        order
            Order the returned UserAISettings records by any field
        distinct
            Filter UserAISettings records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserAISettings
            The first UserAISettings record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserAISettings record ordered by the ragEnabled field
        useraisettings = await UserAISettings.prisma().find_first(
            skip=1,
            order={
                'ragEnabled': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserAISettingsWhereInput] = None,
        cursor: Optional[types.UserAISettingsWhereUniqueInput] = None,
        include: Optional[types.UserAISettingsInclude] = None,
        order: Optional[Union[types.UserAISettingsOrderByInput, List[types.UserAISettingsOrderByInput]]] = None,
        distinct: Optional[List[types.UserAISettingsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserAISettings record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserAISettings filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserAISettings model
        order
            Order the returned UserAISettings records by any field
        distinct
            Filter UserAISettings records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserAISettings
            The first UserAISettings record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserAISettings record ordered by the aiPersonalityProfile field
        useraisettings = await UserAISettings.prisma().find_first_or_raise(
            skip=1,
            order={
                'aiPersonalityProfile': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserAISettingsUpdateInput,
        where: types.UserAISettingsWhereUniqueInput,
        include: Optional[types.UserAISettingsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserAISettings record.

        Parameters
        ----------
        data
            UserAISettings record data specifying what to update
        where
            UserAISettings filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserAISettings model

        Returns
        -------
        prisma.models.UserAISettings
            The updated UserAISettings record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        useraisettings = await UserAISettings.prisma().update(
            where={
                'aiSettingsId': 'biacbiieja',
            },
            data={
                # data to update the UserAISettings record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserAISettingsWhereUniqueInput,
        data: types.UserAISettingsUpsertInput,
        include: Optional[types.UserAISettingsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserAISettings filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserAISettings model

        Returns
        -------
        prisma.models.UserAISettings
            The created or updated UserAISettings record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        useraisettings = await UserAISettings.prisma().upsert(
            where={
                'aiSettingsId': 'cjejbgbff',
            },
            data={
                'create': {
                    'aiSettingsId': 'cjejbgbff',
                    'userId': 'fgggcdcjg',
                    'botSlug': 'ccjbbjigf',
                    'aiPersonalityProfile': Json({'bhfaabbaha': True}),
                },
                'update': {
                    'userId': 'fgggcdcjg',
                    'botSlug': 'ccjbbjigf',
                    'aiPersonalityProfile': Json({'bhfaabbaha': True}),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserAISettingsUpdateManyMutationInput,
        where: types.UserAISettingsWhereInput,
    ) -> int:
        """Update multiple UserAISettings records

        Parameters
        ----------
        data
            UserAISettings data to update the selected UserAISettings records to
        where
            Filter to select the UserAISettings records to update

        Returns
        -------
        int
            The total number of UserAISettings records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserAISettings records
        total = await UserAISettings.prisma().update_many(
            data={
                'aiSettingsId': 'fgeahddae'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserAISettingsWhereInput] = None,
        cursor: Optional[types.UserAISettingsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserAISettings records present in the database

        Parameters
        ----------
        select
            Select the UserAISettings fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserAISettings filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserAISettingsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserAISettings.prisma().count()

        # results: prisma.types.UserAISettingsCountAggregateOutput
        results = await UserAISettings.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserAISettingsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserAISettingsWhereInput] = None,
        cursor: Optional[types.UserAISettingsWhereUniqueInput] = None,
    ) -> types.UserAISettingsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserAISettingsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserAISettingsWhereInput] = None,
        cursor: Optional[types.UserAISettingsWhereUniqueInput] = None,
    ) -> Union[int, types.UserAISettingsCountAggregateOutput]:
        """Count the number of UserAISettings records present in the database

        Parameters
        ----------
        select
            Select the UserAISettings fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserAISettings filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserAISettingsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserAISettings.prisma().count()

        # results: prisma.types.UserAISettingsCountAggregateOutput
        results = await UserAISettings.prisma().count(
            select={
                '_all': True,
                'botSlug': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserAISettingsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserAISettingsWhereInput] = None
    ) -> int:
        """Delete multiple UserAISettings records.

        Parameters
        ----------
        where
            Optional UserAISettings filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserAISettings records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserAISettings records
        total = await UserAISettings.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserAISettingsScalarFieldKeys'],
        *,
        where: Optional['types.UserAISettingsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAISettingsAvgAggregateInput'] = None,
        sum: Optional['types.UserAISettingsSumAggregateInput'] = None,
        min: Optional['types.UserAISettingsMinAggregateInput'] = None,
        max: Optional['types.UserAISettingsMaxAggregateInput'] = None,
        having: Optional['types.UserAISettingsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserAISettingsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserAISettingsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserAISettingsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserAISettingsGroupByOutput']:
        """Group UserAISettings records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserAISettings fields to group records by
        where
            UserAISettings filter to select records
        take
            Limit the maximum number of UserAISettings records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserAISettingsGroupByOutput]
            A list of dictionaries representing the UserAISettings record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserAISettings records by ragEnabled values
        # and count how many records are in each group
        results = await UserAISettings.prisma().group_by(
            ['ragEnabled'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserMediaActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserMedia]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserMedia.prisma().query_raw(
            'SELECT * FROM UserMedia WHERE mediaId = $1',
            'diageigcf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserMedia
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserMedia.prisma().query_first(
            'SELECT * FROM UserMedia WHERE userId = $1',
            'badagbgeha',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserMediaCreateInput,
        include: Optional[types.UserMediaInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserMedia record.

        Parameters
        ----------
        data
            UserMedia record data
        include
            Specifies which relations should be loaded on the returned UserMedia model

        Returns
        -------
        prisma.models.UserMedia
            The created UserMedia record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserMedia record from just the required fields
        usermedia = await UserMedia.prisma().create(
            data={
                # data to create a UserMedia record
                'userId': 'ibgebbjch',
                'mediaType': enums.MediaType.IMAGE,
                'mediaUrl': 'baieajjiee',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserMediaCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserMedia records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserMedia record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserMedia.prisma().create_many(
            data=[
                {
                    # data to create a UserMedia record
                    'userId': 'bahjhaccfd',
                    'mediaType': enums.MediaType.IMAGE,
                    'mediaUrl': 'hffhfabhi',
                },
                {
                    # data to create a UserMedia record
                    'userId': 'bbcigiadhb',
                    'mediaType': enums.MediaType.IMAGE,
                    'mediaUrl': 'cfjagbbae',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserMediaWhereUniqueInput,
        include: Optional[types.UserMediaInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserMedia record.

        Parameters
        ----------
        where
            UserMedia filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserMedia model

        Returns
        -------
        prisma.models.UserMedia
            The deleted UserMedia record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usermedia = await UserMedia.prisma().delete(
            where={
                'mediaId': 'bbbfhdidef',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserMediaWhereUniqueInput,
        include: Optional[types.UserMediaInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserMedia record.

        Parameters
        ----------
        where
            UserMedia filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserMedia model

        Returns
        -------
        prisma.models.UserMedia
            The found UserMedia record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usermedia = await UserMedia.prisma().find_unique(
            where={
                'mediaId': 'bdadhibhec',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserMediaWhereUniqueInput,
        include: Optional[types.UserMediaInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserMedia record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserMedia filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserMedia model

        Returns
        -------
        prisma.models.UserMedia
            The found UserMedia record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usermedia = await UserMedia.prisma().find_unique_or_raise(
            where={
                'mediaId': 'bfhdjaiejf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserMediaWhereInput] = None,
        cursor: Optional[types.UserMediaWhereUniqueInput] = None,
        include: Optional[types.UserMediaInclude] = None,
        order: Optional[Union[types.UserMediaOrderByInput, List[types.UserMediaOrderByInput]]] = None,
        distinct: Optional[List[types.UserMediaScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserMedia records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserMedia records returned
        skip
            Ignore the first N results
        where
            UserMedia filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserMedia model
        order
            Order the returned UserMedia records by any field
        distinct
            Filter UserMedia records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserMedia]
            The list of all UserMedia records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserMedia records
        usermedias = await UserMedia.prisma().find_many(take=10)

        # find the first 5 UserMedia records ordered by the mediaType field
        usermedias = await UserMedia.prisma().find_many(
            take=5,
            order={
                'mediaType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserMediaWhereInput] = None,
        cursor: Optional[types.UserMediaWhereUniqueInput] = None,
        include: Optional[types.UserMediaInclude] = None,
        order: Optional[Union[types.UserMediaOrderByInput, List[types.UserMediaOrderByInput]]] = None,
        distinct: Optional[List[types.UserMediaScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserMedia record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserMedia filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserMedia model
        order
            Order the returned UserMedia records by any field
        distinct
            Filter UserMedia records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserMedia
            The first UserMedia record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserMedia record ordered by the mediaUrl field
        usermedia = await UserMedia.prisma().find_first(
            skip=1,
            order={
                'mediaUrl': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserMediaWhereInput] = None,
        cursor: Optional[types.UserMediaWhereUniqueInput] = None,
        include: Optional[types.UserMediaInclude] = None,
        order: Optional[Union[types.UserMediaOrderByInput, List[types.UserMediaOrderByInput]]] = None,
        distinct: Optional[List[types.UserMediaScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserMedia record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserMedia filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserMedia model
        order
            Order the returned UserMedia records by any field
        distinct
            Filter UserMedia records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserMedia
            The first UserMedia record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserMedia record ordered by the uploadDate field
        usermedia = await UserMedia.prisma().find_first_or_raise(
            skip=1,
            order={
                'uploadDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserMediaUpdateInput,
        where: types.UserMediaWhereUniqueInput,
        include: Optional[types.UserMediaInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserMedia record.

        Parameters
        ----------
        data
            UserMedia record data specifying what to update
        where
            UserMedia filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserMedia model

        Returns
        -------
        prisma.models.UserMedia
            The updated UserMedia record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        usermedia = await UserMedia.prisma().update(
            where={
                'mediaId': 'bbjfijjadg',
            },
            data={
                # data to update the UserMedia record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserMediaWhereUniqueInput,
        data: types.UserMediaUpsertInput,
        include: Optional[types.UserMediaInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserMedia filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserMedia model

        Returns
        -------
        prisma.models.UserMedia
            The created or updated UserMedia record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usermedia = await UserMedia.prisma().upsert(
            where={
                'mediaId': 'hdjacbehh',
            },
            data={
                'create': {
                    'mediaId': 'hdjacbehh',
                    'userId': 'bbcigiadhb',
                    'mediaType': enums.MediaType.IMAGE,
                    'mediaUrl': 'cfjagbbae',
                },
                'update': {
                    'userId': 'bbcigiadhb',
                    'mediaType': enums.MediaType.IMAGE,
                    'mediaUrl': 'cfjagbbae',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserMediaUpdateManyMutationInput,
        where: types.UserMediaWhereInput,
    ) -> int:
        """Update multiple UserMedia records

        Parameters
        ----------
        data
            UserMedia data to update the selected UserMedia records to
        where
            Filter to select the UserMedia records to update

        Returns
        -------
        int
            The total number of UserMedia records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserMedia records
        total = await UserMedia.prisma().update_many(
            data={
                'mediaId': 'bhcccbeaba'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserMediaWhereInput] = None,
        cursor: Optional[types.UserMediaWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserMedia records present in the database

        Parameters
        ----------
        select
            Select the UserMedia fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserMedia filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserMediaCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserMedia.prisma().count()

        # results: prisma.types.UserMediaCountAggregateOutput
        results = await UserMedia.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserMediaCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserMediaWhereInput] = None,
        cursor: Optional[types.UserMediaWhereUniqueInput] = None,
    ) -> types.UserMediaCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserMediaCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserMediaWhereInput] = None,
        cursor: Optional[types.UserMediaWhereUniqueInput] = None,
    ) -> Union[int, types.UserMediaCountAggregateOutput]:
        """Count the number of UserMedia records present in the database

        Parameters
        ----------
        select
            Select the UserMedia fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserMedia filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserMediaCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserMedia.prisma().count()

        # results: prisma.types.UserMediaCountAggregateOutput
        results = await UserMedia.prisma().count(
            select={
                '_all': True,
                'mediaType': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserMediaCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserMediaWhereInput] = None
    ) -> int:
        """Delete multiple UserMedia records.

        Parameters
        ----------
        where
            Optional UserMedia filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserMedia records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserMedia records
        total = await UserMedia.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserMediaScalarFieldKeys'],
        *,
        where: Optional['types.UserMediaWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserMediaAvgAggregateInput'] = None,
        sum: Optional['types.UserMediaSumAggregateInput'] = None,
        min: Optional['types.UserMediaMinAggregateInput'] = None,
        max: Optional['types.UserMediaMaxAggregateInput'] = None,
        having: Optional['types.UserMediaScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserMediaCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserMediaScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserMediaScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserMediaGroupByOutput']:
        """Group UserMedia records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserMedia fields to group records by
        where
            UserMedia filter to select records
        take
            Limit the maximum number of UserMedia records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserMediaGroupByOutput]
            A list of dictionaries representing the UserMedia record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserMedia records by mediaUrl values
        # and count how many records are in each group
        results = await UserMedia.prisma().group_by(
            ['mediaUrl'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TenantActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Tenant]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Tenant.prisma().query_raw(
            'SELECT * FROM Tenant WHERE id = $1',
            'bcgjbdgjdj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Tenant
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Tenant.prisma().query_first(
            'SELECT * FROM Tenant WHERE alias = $1',
            'fhdbhifae',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TenantCreateInput,
        include: Optional[types.TenantInclude] = None
    ) -> _PrismaModelT:
        """Create a new Tenant record.

        Parameters
        ----------
        data
            Tenant record data
        include
            Specifies which relations should be loaded on the returned Tenant model

        Returns
        -------
        prisma.models.Tenant
            The created Tenant record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Tenant record from just the required fields
        tenant = await Tenant.prisma().create(
            data={
                # data to create a Tenant record
                'alias': 'beeacgfcej',
                'display_name': 'bbifhdiicc',
                'menu_items': Json({'bgjeccejad': True}),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TenantCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Tenant records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Tenant record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Tenant.prisma().create_many(
            data=[
                {
                    # data to create a Tenant record
                    'alias': 'bjagdgabbg',
                    'display_name': 'bjbbcffdij',
                    'menu_items': Json({'begcgchdi': True}),
                },
                {
                    # data to create a Tenant record
                    'alias': 'bhbjceagbb',
                    'display_name': 'bjeifffjdg',
                    'menu_items': Json({'bdidcfdfjd': True}),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TenantWhereUniqueInput,
        include: Optional[types.TenantInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Tenant record.

        Parameters
        ----------
        where
            Tenant filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Tenant model

        Returns
        -------
        prisma.models.Tenant
            The deleted Tenant record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tenant = await Tenant.prisma().delete(
            where={
                'id': 'dfeggejja',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TenantWhereUniqueInput,
        include: Optional[types.TenantInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Tenant record.

        Parameters
        ----------
        where
            Tenant filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Tenant model

        Returns
        -------
        prisma.models.Tenant
            The found Tenant record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tenant = await Tenant.prisma().find_unique(
            where={
                'id': 'gehbgghbj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TenantWhereUniqueInput,
        include: Optional[types.TenantInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Tenant record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Tenant filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Tenant model

        Returns
        -------
        prisma.models.Tenant
            The found Tenant record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tenant = await Tenant.prisma().find_unique_or_raise(
            where={
                'id': 'dfhaijeie',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TenantWhereInput] = None,
        cursor: Optional[types.TenantWhereUniqueInput] = None,
        include: Optional[types.TenantInclude] = None,
        order: Optional[Union[types.TenantOrderByInput, List[types.TenantOrderByInput]]] = None,
        distinct: Optional[List[types.TenantScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Tenant records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Tenant records returned
        skip
            Ignore the first N results
        where
            Tenant filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tenant model
        order
            Order the returned Tenant records by any field
        distinct
            Filter Tenant records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Tenant]
            The list of all Tenant records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Tenant records
        tenants = await Tenant.prisma().find_many(take=10)

        # find the first 5 Tenant records ordered by the display_name field
        tenants = await Tenant.prisma().find_many(
            take=5,
            order={
                'display_name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TenantWhereInput] = None,
        cursor: Optional[types.TenantWhereUniqueInput] = None,
        include: Optional[types.TenantInclude] = None,
        order: Optional[Union[types.TenantOrderByInput, List[types.TenantOrderByInput]]] = None,
        distinct: Optional[List[types.TenantScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Tenant record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Tenant filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tenant model
        order
            Order the returned Tenant records by any field
        distinct
            Filter Tenant records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Tenant
            The first Tenant record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Tenant record ordered by the menu_items field
        tenant = await Tenant.prisma().find_first(
            skip=1,
            order={
                'menu_items': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TenantWhereInput] = None,
        cursor: Optional[types.TenantWhereUniqueInput] = None,
        include: Optional[types.TenantInclude] = None,
        order: Optional[Union[types.TenantOrderByInput, List[types.TenantOrderByInput]]] = None,
        distinct: Optional[List[types.TenantScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Tenant record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Tenant filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tenant model
        order
            Order the returned Tenant records by any field
        distinct
            Filter Tenant records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Tenant
            The first Tenant record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Tenant record ordered by the address field
        tenant = await Tenant.prisma().find_first_or_raise(
            skip=1,
            order={
                'address': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TenantUpdateInput,
        where: types.TenantWhereUniqueInput,
        include: Optional[types.TenantInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Tenant record.

        Parameters
        ----------
        data
            Tenant record data specifying what to update
        where
            Tenant filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Tenant model

        Returns
        -------
        prisma.models.Tenant
            The updated Tenant record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        tenant = await Tenant.prisma().update(
            where={
                'id': 'gbcdjgicb',
            },
            data={
                # data to update the Tenant record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TenantWhereUniqueInput,
        data: types.TenantUpsertInput,
        include: Optional[types.TenantInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Tenant filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Tenant model

        Returns
        -------
        prisma.models.Tenant
            The created or updated Tenant record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tenant = await Tenant.prisma().upsert(
            where={
                'id': 'biaibdagac',
            },
            data={
                'create': {
                    'id': 'biaibdagac',
                    'alias': 'bhbjceagbb',
                    'display_name': 'bjeifffjdg',
                    'menu_items': Json({'bdidcfdfjd': True}),
                },
                'update': {
                    'alias': 'bhbjceagbb',
                    'display_name': 'bjeifffjdg',
                    'menu_items': Json({'bdidcfdfjd': True}),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TenantUpdateManyMutationInput,
        where: types.TenantWhereInput,
    ) -> int:
        """Update multiple Tenant records

        Parameters
        ----------
        data
            Tenant data to update the selected Tenant records to
        where
            Filter to select the Tenant records to update

        Returns
        -------
        int
            The total number of Tenant records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Tenant records
        total = await Tenant.prisma().update_many(
            data={
                'status': 'bbfbheibcd'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TenantWhereInput] = None,
        cursor: Optional[types.TenantWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Tenant records present in the database

        Parameters
        ----------
        select
            Select the Tenant fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Tenant filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TenantCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Tenant.prisma().count()

        # results: prisma.types.TenantCountAggregateOutput
        results = await Tenant.prisma().count(
            select={
                '_all': True,
                'created_at': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TenantCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TenantWhereInput] = None,
        cursor: Optional[types.TenantWhereUniqueInput] = None,
    ) -> types.TenantCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TenantCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TenantWhereInput] = None,
        cursor: Optional[types.TenantWhereUniqueInput] = None,
    ) -> Union[int, types.TenantCountAggregateOutput]:
        """Count the number of Tenant records present in the database

        Parameters
        ----------
        select
            Select the Tenant fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Tenant filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TenantCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Tenant.prisma().count()

        # results: prisma.types.TenantCountAggregateOutput
        results = await Tenant.prisma().count(
            select={
                '_all': True,
                'updated_at': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TenantCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TenantWhereInput] = None
    ) -> int:
        """Delete multiple Tenant records.

        Parameters
        ----------
        where
            Optional Tenant filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Tenant records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Tenant records
        total = await Tenant.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TenantScalarFieldKeys'],
        *,
        where: Optional['types.TenantWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TenantAvgAggregateInput'] = None,
        sum: Optional['types.TenantSumAggregateInput'] = None,
        min: Optional['types.TenantMinAggregateInput'] = None,
        max: Optional['types.TenantMaxAggregateInput'] = None,
        having: Optional['types.TenantScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TenantCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TenantScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TenantScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TenantGroupByOutput']:
        """Group Tenant records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Tenant fields to group records by
        where
            Tenant filter to select records
        take
            Limit the maximum number of Tenant records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TenantGroupByOutput]
            A list of dictionaries representing the Tenant record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Tenant records by id values
        # and count how many records are in each group
        results = await Tenant.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class OrderActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Order]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Order.prisma().query_raw(
            'SELECT * FROM Order WHERE id = $1',
            'hiagajie',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Order
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Order.prisma().query_first(
            'SELECT * FROM Order WHERE customer_name = $1',
            'eeejidbif',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.OrderCreateInput,
        include: Optional[types.OrderInclude] = None
    ) -> _PrismaModelT:
        """Create a new Order record.

        Parameters
        ----------
        data
            Order record data
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The created Order record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Order record from just the required fields
        order = await Order.prisma().create(
            data={
                # data to create a Order record
                'customer_name': 'efgbahec',
                'items': 'hgjaiebfb',
                'total_price': 1334599012.111676,
                'status': 'bbhcgagaic',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.OrderCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Order records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Order record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Order.prisma().create_many(
            data=[
                {
                    # data to create a Order record
                    'customer_name': 'ddaabegbb',
                    'items': 'bhgibfgbbc',
                    'total_price': 71628745.5576,
                    'status': 'ibcadcejf',
                },
                {
                    # data to create a Order record
                    'customer_name': 'bdcdfgccdg',
                    'items': 'edhjgdfh',
                    'total_price': 1345530330.196538,
                    'status': 'iaeihdeei',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.OrderWhereUniqueInput,
        include: Optional[types.OrderInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Order record.

        Parameters
        ----------
        where
            Order filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The deleted Order record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        order = await Order.prisma().delete(
            where={
                'id': 'bfggejgfbd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.OrderWhereUniqueInput,
        include: Optional[types.OrderInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Order record.

        Parameters
        ----------
        where
            Order filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The found Order record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        order = await Order.prisma().find_unique(
            where={
                'id': 'ifaaaedja',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.OrderWhereUniqueInput,
        include: Optional[types.OrderInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Order record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Order filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The found Order record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        order = await Order.prisma().find_unique_or_raise(
            where={
                'id': 'cbajdjjabf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
        include: Optional[types.OrderInclude] = None,
        order: Optional[Union[types.OrderOrderByInput, List[types.OrderOrderByInput]]] = None,
        distinct: Optional[List[types.OrderScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Order records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Order records returned
        skip
            Ignore the first N results
        where
            Order filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Order model
        order
            Order the returned Order records by any field
        distinct
            Filter Order records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Order]
            The list of all Order records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Order records
        orders = await Order.prisma().find_many(take=10)

        # find the first 5 Order records ordered by the items field
        orders = await Order.prisma().find_many(
            take=5,
            order={
                'items': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
        include: Optional[types.OrderInclude] = None,
        order: Optional[Union[types.OrderOrderByInput, List[types.OrderOrderByInput]]] = None,
        distinct: Optional[List[types.OrderScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Order record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Order filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Order model
        order
            Order the returned Order records by any field
        distinct
            Filter Order records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Order
            The first Order record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Order record ordered by the total_price field
        order = await Order.prisma().find_first(
            skip=1,
            order={
                'total_price': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
        include: Optional[types.OrderInclude] = None,
        order: Optional[Union[types.OrderOrderByInput, List[types.OrderOrderByInput]]] = None,
        distinct: Optional[List[types.OrderScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Order record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Order filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Order model
        order
            Order the returned Order records by any field
        distinct
            Filter Order records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Order
            The first Order record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Order record ordered by the status field
        order = await Order.prisma().find_first_or_raise(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.OrderUpdateInput,
        where: types.OrderWhereUniqueInput,
        include: Optional[types.OrderInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Order record.

        Parameters
        ----------
        data
            Order record data specifying what to update
        where
            Order filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The updated Order record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        order = await Order.prisma().update(
            where={
                'id': 'bcicggedea',
            },
            data={
                # data to update the Order record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.OrderWhereUniqueInput,
        data: types.OrderUpsertInput,
        include: Optional[types.OrderInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Order filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The created or updated Order record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        order = await Order.prisma().upsert(
            where={
                'id': 'cebcdadjh',
            },
            data={
                'create': {
                    'id': 'cebcdadjh',
                    'customer_name': 'bdcdfgccdg',
                    'items': 'edhjgdfh',
                    'total_price': 1345530330.196538,
                    'status': 'iaeihdeei',
                },
                'update': {
                    'customer_name': 'bdcdfgccdg',
                    'items': 'edhjgdfh',
                    'total_price': 1345530330.196538,
                    'status': 'iaeihdeei',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.OrderUpdateManyMutationInput,
        where: types.OrderWhereInput,
    ) -> int:
        """Update multiple Order records

        Parameters
        ----------
        data
            Order data to update the selected Order records to
        where
            Filter to select the Order records to update

        Returns
        -------
        int
            The total number of Order records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Order records
        total = await Order.prisma().update_many(
            data={
                'created_at': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Order records present in the database

        Parameters
        ----------
        select
            Select the Order fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Order filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OrderCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Order.prisma().count()

        # results: prisma.types.OrderCountAggregateOutput
        results = await Order.prisma().count(
            select={
                '_all': True,
                'updated_at': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.OrderCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
    ) -> types.OrderCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.OrderCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
    ) -> Union[int, types.OrderCountAggregateOutput]:
        """Count the number of Order records present in the database

        Parameters
        ----------
        select
            Select the Order fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Order filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OrderCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Order.prisma().count()

        # results: prisma.types.OrderCountAggregateOutput
        results = await Order.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.OrderCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.OrderWhereInput] = None
    ) -> int:
        """Delete multiple Order records.

        Parameters
        ----------
        where
            Optional Order filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Order records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Order records
        total = await Order.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.OrderScalarFieldKeys'],
        *,
        where: Optional['types.OrderWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.OrderAvgAggregateInput'] = None,
        sum: Optional['types.OrderSumAggregateInput'] = None,
        min: Optional['types.OrderMinAggregateInput'] = None,
        max: Optional['types.OrderMaxAggregateInput'] = None,
        having: Optional['types.OrderScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.OrderCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.OrderScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.OrderScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.OrderGroupByOutput']:
        """Group Order records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Order fields to group records by
        where
            Order filter to select records
        take
            Limit the maximum number of Order records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.OrderGroupByOutput]
            A list of dictionaries representing the Order record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Order records by customer_name values
        # and count how many records are in each group
        results = await Order.prisma().group_by(
            ['customer_name'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class MemoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Memory]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Memory.prisma().query_raw(
            'SELECT * FROM Memory WHERE id = $1',
            475863602,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Memory
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Memory.prisma().query_first(
            'SELECT * FROM Memory WHERE title = $1',
            'bhbgccijjf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.MemoryCreateInput,
        include: Optional[types.MemoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new Memory record.

        Parameters
        ----------
        data
            Memory record data
        include
            Specifies which relations should be loaded on the returned Memory model

        Returns
        -------
        prisma.models.Memory
            The created Memory record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Memory record from just the required fields
        memory = await Memory.prisma().create(
            data={
                # data to create a Memory record
                'title': 'bigjhdgbjc',
                'content': 'bfifdebhfd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.MemoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Memory records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Memory record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Memory.prisma().create_many(
            data=[
                {
                    # data to create a Memory record
                    'title': 'cjchbjde',
                    'content': 'bfiibjcehj',
                },
                {
                    # data to create a Memory record
                    'title': 'ijieafghg',
                    'content': 'hhhegahcf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.MemoryWhereUniqueInput,
        include: Optional[types.MemoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Memory record.

        Parameters
        ----------
        where
            Memory filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Memory model

        Returns
        -------
        prisma.models.Memory
            The deleted Memory record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        memory = await Memory.prisma().delete(
            where={
                'id': 437894538,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.MemoryWhereUniqueInput,
        include: Optional[types.MemoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Memory record.

        Parameters
        ----------
        where
            Memory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Memory model

        Returns
        -------
        prisma.models.Memory
            The found Memory record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        memory = await Memory.prisma().find_unique(
            where={
                'id': 393342971,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.MemoryWhereUniqueInput,
        include: Optional[types.MemoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Memory record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Memory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Memory model

        Returns
        -------
        prisma.models.Memory
            The found Memory record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        memory = await Memory.prisma().find_unique_or_raise(
            where={
                'id': 163829784,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MemoryWhereInput] = None,
        cursor: Optional[types.MemoryWhereUniqueInput] = None,
        include: Optional[types.MemoryInclude] = None,
        order: Optional[Union[types.MemoryOrderByInput, List[types.MemoryOrderByInput]]] = None,
        distinct: Optional[List[types.MemoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Memory records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Memory records returned
        skip
            Ignore the first N results
        where
            Memory filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Memory model
        order
            Order the returned Memory records by any field
        distinct
            Filter Memory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Memory]
            The list of all Memory records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Memory records
        memorys = await Memory.prisma().find_many(take=10)

        # find the first 5 Memory records ordered by the content field
        memorys = await Memory.prisma().find_many(
            take=5,
            order={
                'content': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MemoryWhereInput] = None,
        cursor: Optional[types.MemoryWhereUniqueInput] = None,
        include: Optional[types.MemoryInclude] = None,
        order: Optional[Union[types.MemoryOrderByInput, List[types.MemoryOrderByInput]]] = None,
        distinct: Optional[List[types.MemoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Memory record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Memory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Memory model
        order
            Order the returned Memory records by any field
        distinct
            Filter Memory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Memory
            The first Memory record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Memory record ordered by the createdAt field
        memory = await Memory.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MemoryWhereInput] = None,
        cursor: Optional[types.MemoryWhereUniqueInput] = None,
        include: Optional[types.MemoryInclude] = None,
        order: Optional[Union[types.MemoryOrderByInput, List[types.MemoryOrderByInput]]] = None,
        distinct: Optional[List[types.MemoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Memory record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Memory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Memory model
        order
            Order the returned Memory records by any field
        distinct
            Filter Memory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Memory
            The first Memory record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Memory record ordered by the updatedAt field
        memory = await Memory.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.MemoryUpdateInput,
        where: types.MemoryWhereUniqueInput,
        include: Optional[types.MemoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Memory record.

        Parameters
        ----------
        data
            Memory record data specifying what to update
        where
            Memory filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Memory model

        Returns
        -------
        prisma.models.Memory
            The updated Memory record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        memory = await Memory.prisma().update(
            where={
                'id': 248152689,
            },
            data={
                # data to update the Memory record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.MemoryWhereUniqueInput,
        data: types.MemoryUpsertInput,
        include: Optional[types.MemoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Memory filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Memory model

        Returns
        -------
        prisma.models.Memory
            The created or updated Memory record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        memory = await Memory.prisma().upsert(
            where={
                'id': 341715030,
            },
            data={
                'create': {
                    'id': 341715030,
                    'title': 'ijieafghg',
                    'content': 'hhhegahcf',
                },
                'update': {
                    'title': 'ijieafghg',
                    'content': 'hhhegahcf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.MemoryUpdateManyMutationInput,
        where: types.MemoryWhereInput,
    ) -> int:
        """Update multiple Memory records

        Parameters
        ----------
        data
            Memory data to update the selected Memory records to
        where
            Filter to select the Memory records to update

        Returns
        -------
        int
            The total number of Memory records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Memory records
        total = await Memory.prisma().update_many(
            data={
                'id': 1692766423
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MemoryWhereInput] = None,
        cursor: Optional[types.MemoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Memory records present in the database

        Parameters
        ----------
        select
            Select the Memory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Memory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MemoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Memory.prisma().count()

        # results: prisma.types.MemoryCountAggregateOutput
        results = await Memory.prisma().count(
            select={
                '_all': True,
                'title': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.MemoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MemoryWhereInput] = None,
        cursor: Optional[types.MemoryWhereUniqueInput] = None,
    ) -> types.MemoryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.MemoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MemoryWhereInput] = None,
        cursor: Optional[types.MemoryWhereUniqueInput] = None,
    ) -> Union[int, types.MemoryCountAggregateOutput]:
        """Count the number of Memory records present in the database

        Parameters
        ----------
        select
            Select the Memory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Memory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MemoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Memory.prisma().count()

        # results: prisma.types.MemoryCountAggregateOutput
        results = await Memory.prisma().count(
            select={
                '_all': True,
                'content': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.MemoryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.MemoryWhereInput] = None
    ) -> int:
        """Delete multiple Memory records.

        Parameters
        ----------
        where
            Optional Memory filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Memory records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Memory records
        total = await Memory.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.MemoryScalarFieldKeys'],
        *,
        where: Optional['types.MemoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.MemoryAvgAggregateInput'] = None,
        sum: Optional['types.MemorySumAggregateInput'] = None,
        min: Optional['types.MemoryMinAggregateInput'] = None,
        max: Optional['types.MemoryMaxAggregateInput'] = None,
        having: Optional['types.MemoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.MemoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.MemoryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.MemoryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.MemoryGroupByOutput']:
        """Group Memory records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Memory fields to group records by
        where
            Memory filter to select records
        take
            Limit the maximum number of Memory records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.MemoryGroupByOutput]
            A list of dictionaries representing the Memory record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Memory records by createdAt values
        # and count how many records are in each group
        results = await Memory.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class RagDocumentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.RagDocument]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await RagDocument.prisma().query_raw(
            'SELECT * FROM RagDocument WHERE id = $1',
            86662596,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.RagDocument
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await RagDocument.prisma().query_first(
            'SELECT * FROM RagDocument WHERE tenantId = $1',
            'bgjhijffjh',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.RagDocumentCreateInput,
        include: Optional[types.RagDocumentInclude] = None
    ) -> _PrismaModelT:
        """Create a new RagDocument record.

        Parameters
        ----------
        data
            RagDocument record data
        include
            Specifies which relations should be loaded on the returned RagDocument model

        Returns
        -------
        prisma.models.RagDocument
            The created RagDocument record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a RagDocument record from just the required fields
        ragdocument = await RagDocument.prisma().create(
            data={
                # data to create a RagDocument record
                'tenantId': 'bcigdhache',
                'title': 'igefhgdhb',
                'content': 'ejbiifbae',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.RagDocumentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple RagDocument records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of RagDocument record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await RagDocument.prisma().create_many(
            data=[
                {
                    # data to create a RagDocument record
                    'tenantId': 'djcfgedjd',
                    'title': 'bdbjcdegag',
                    'content': 'hbchfebch',
                },
                {
                    # data to create a RagDocument record
                    'tenantId': 'bcjjffegfc',
                    'title': 'cahaeaicjd',
                    'content': 'ibbjaacbi',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.RagDocumentWhereUniqueInput,
        include: Optional[types.RagDocumentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single RagDocument record.

        Parameters
        ----------
        where
            RagDocument filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned RagDocument model

        Returns
        -------
        prisma.models.RagDocument
            The deleted RagDocument record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        ragdocument = await RagDocument.prisma().delete(
            where={
                'id': 396021227,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.RagDocumentWhereUniqueInput,
        include: Optional[types.RagDocumentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique RagDocument record.

        Parameters
        ----------
        where
            RagDocument filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned RagDocument model

        Returns
        -------
        prisma.models.RagDocument
            The found RagDocument record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        ragdocument = await RagDocument.prisma().find_unique(
            where={
                'id': 644446024,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.RagDocumentWhereUniqueInput,
        include: Optional[types.RagDocumentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique RagDocument record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            RagDocument filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned RagDocument model

        Returns
        -------
        prisma.models.RagDocument
            The found RagDocument record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        ragdocument = await RagDocument.prisma().find_unique_or_raise(
            where={
                'id': 116386273,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RagDocumentWhereInput] = None,
        cursor: Optional[types.RagDocumentWhereUniqueInput] = None,
        include: Optional[types.RagDocumentInclude] = None,
        order: Optional[Union[types.RagDocumentOrderByInput, List[types.RagDocumentOrderByInput]]] = None,
        distinct: Optional[List[types.RagDocumentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple RagDocument records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of RagDocument records returned
        skip
            Ignore the first N results
        where
            RagDocument filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RagDocument model
        order
            Order the returned RagDocument records by any field
        distinct
            Filter RagDocument records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.RagDocument]
            The list of all RagDocument records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 RagDocument records
        ragdocuments = await RagDocument.prisma().find_many(take=10)

        # find the first 5 RagDocument records ordered by the title field
        ragdocuments = await RagDocument.prisma().find_many(
            take=5,
            order={
                'title': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RagDocumentWhereInput] = None,
        cursor: Optional[types.RagDocumentWhereUniqueInput] = None,
        include: Optional[types.RagDocumentInclude] = None,
        order: Optional[Union[types.RagDocumentOrderByInput, List[types.RagDocumentOrderByInput]]] = None,
        distinct: Optional[List[types.RagDocumentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single RagDocument record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            RagDocument filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RagDocument model
        order
            Order the returned RagDocument records by any field
        distinct
            Filter RagDocument records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.RagDocument
            The first RagDocument record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second RagDocument record ordered by the content field
        ragdocument = await RagDocument.prisma().find_first(
            skip=1,
            order={
                'content': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RagDocumentWhereInput] = None,
        cursor: Optional[types.RagDocumentWhereUniqueInput] = None,
        include: Optional[types.RagDocumentInclude] = None,
        order: Optional[Union[types.RagDocumentOrderByInput, List[types.RagDocumentOrderByInput]]] = None,
        distinct: Optional[List[types.RagDocumentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single RagDocument record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            RagDocument filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RagDocument model
        order
            Order the returned RagDocument records by any field
        distinct
            Filter RagDocument records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.RagDocument
            The first RagDocument record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second RagDocument record ordered by the source field
        ragdocument = await RagDocument.prisma().find_first_or_raise(
            skip=1,
            order={
                'source': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.RagDocumentUpdateInput,
        where: types.RagDocumentWhereUniqueInput,
        include: Optional[types.RagDocumentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single RagDocument record.

        Parameters
        ----------
        data
            RagDocument record data specifying what to update
        where
            RagDocument filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned RagDocument model

        Returns
        -------
        prisma.models.RagDocument
            The updated RagDocument record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        ragdocument = await RagDocument.prisma().update(
            where={
                'id': 309285638,
            },
            data={
                # data to update the RagDocument record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.RagDocumentWhereUniqueInput,
        data: types.RagDocumentUpsertInput,
        include: Optional[types.RagDocumentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            RagDocument filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned RagDocument model

        Returns
        -------
        prisma.models.RagDocument
            The created or updated RagDocument record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        ragdocument = await RagDocument.prisma().upsert(
            where={
                'id': 22437319,
            },
            data={
                'create': {
                    'id': 22437319,
                    'tenantId': 'bcjjffegfc',
                    'title': 'cahaeaicjd',
                    'content': 'ibbjaacbi',
                },
                'update': {
                    'tenantId': 'bcjjffegfc',
                    'title': 'cahaeaicjd',
                    'content': 'ibbjaacbi',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.RagDocumentUpdateManyMutationInput,
        where: types.RagDocumentWhereInput,
    ) -> int:
        """Update multiple RagDocument records

        Parameters
        ----------
        data
            RagDocument data to update the selected RagDocument records to
        where
            Filter to select the RagDocument records to update

        Returns
        -------
        int
            The total number of RagDocument records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all RagDocument records
        total = await RagDocument.prisma().update_many(
            data={
                'tags': 'bjaabjjjce'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RagDocumentWhereInput] = None,
        cursor: Optional[types.RagDocumentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of RagDocument records present in the database

        Parameters
        ----------
        select
            Select the RagDocument fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            RagDocument filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RagDocumentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await RagDocument.prisma().count()

        # results: prisma.types.RagDocumentCountAggregateOutput
        results = await RagDocument.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.RagDocumentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RagDocumentWhereInput] = None,
        cursor: Optional[types.RagDocumentWhereUniqueInput] = None,
    ) -> types.RagDocumentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.RagDocumentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RagDocumentWhereInput] = None,
        cursor: Optional[types.RagDocumentWhereUniqueInput] = None,
    ) -> Union[int, types.RagDocumentCountAggregateOutput]:
        """Count the number of RagDocument records present in the database

        Parameters
        ----------
        select
            Select the RagDocument fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            RagDocument filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RagDocumentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await RagDocument.prisma().count()

        # results: prisma.types.RagDocumentCountAggregateOutput
        results = await RagDocument.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.RagDocumentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.RagDocumentWhereInput] = None
    ) -> int:
        """Delete multiple RagDocument records.

        Parameters
        ----------
        where
            Optional RagDocument filter to find the records to be deleted

        Returns
        -------
        int
            The total number of RagDocument records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all RagDocument records
        total = await RagDocument.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.RagDocumentScalarFieldKeys'],
        *,
        where: Optional['types.RagDocumentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.RagDocumentAvgAggregateInput'] = None,
        sum: Optional['types.RagDocumentSumAggregateInput'] = None,
        min: Optional['types.RagDocumentMinAggregateInput'] = None,
        max: Optional['types.RagDocumentMaxAggregateInput'] = None,
        having: Optional['types.RagDocumentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.RagDocumentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.RagDocumentScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.RagDocumentScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.RagDocumentGroupByOutput']:
        """Group RagDocument records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar RagDocument fields to group records by
        where
            RagDocument filter to select records
        take
            Limit the maximum number of RagDocument records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.RagDocumentGroupByOutput]
            A list of dictionaries representing the RagDocument record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group RagDocument records by embeddings values
        # and count how many records are in each group
        results = await RagDocument.prisma().group_by(
            ['embeddings'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models